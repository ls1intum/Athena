# Generated from JavaParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    return [
        4, 1, 126, 2946, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6,
        7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7,
        13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2,
        20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7,
        26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2,
        33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7,
        39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2,
        46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
        52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2,
        59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7,
        65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2,
        72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
        78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2,
        85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7,
        91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2,
        98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103,
        2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109,
        7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114,
        2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120,
        7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125,
        2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131,
        7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136,
        2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142,
        7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147,
        2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153,
        7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158, 7, 158,
        2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164,
        7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169,
        2, 170, 7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175,
        7, 175, 2, 176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180,
        2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186,
        7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 2, 191, 7, 191,
        2, 192, 7, 192, 2, 193, 7, 193, 2, 194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197,
        7, 197, 2, 198, 7, 198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202,
        2, 203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 207, 2, 208,
        7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 212, 7, 212, 2, 213, 7, 213,
        2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219,
        7, 219, 2, 220, 7, 220, 2, 221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224,
        2, 225, 7, 225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 230,
        7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 234, 2, 235, 7, 235,
        2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 239, 7, 239, 2, 240, 7, 240, 2, 241,
        7, 241, 2, 242, 7, 242, 2, 243, 7, 243, 2, 244, 7, 244, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1,
        2, 1, 2, 1, 3, 1, 3, 1, 4, 5, 4, 501, 8, 4, 10, 4, 12, 4, 504, 9, 4, 1, 4, 1, 4, 3, 4, 508,
        8, 4, 1, 5, 1, 5, 3, 5, 512, 8, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 521, 8, 8,
        1, 9, 1, 9, 5, 9, 525, 8, 9, 10, 9, 12, 9, 528, 9, 9, 1, 9, 1, 9, 3, 9, 532, 8, 9, 1, 9, 3,
        9, 535, 8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 540, 8, 10, 1, 10, 5, 10, 543, 8, 10, 10, 10,
        12, 10, 546, 9, 10, 1, 10, 1, 10, 3, 10, 550, 8, 10, 1, 10, 3, 10, 553, 8, 10, 1, 11, 5,
        11, 556, 8, 11, 10, 11, 12, 11, 559, 9, 11, 1, 11, 1, 11, 3, 11, 563, 8, 11, 1, 11, 1,
        11, 1, 11, 5, 11, 568, 8, 11, 10, 11, 12, 11, 571, 9, 11, 1, 11, 1, 11, 3, 11, 575, 8,
        11, 1, 11, 1, 11, 1, 11, 5, 11, 580, 8, 11, 10, 11, 12, 11, 583, 9, 11, 1, 11, 1, 11, 3,
        11, 587, 8, 11, 3, 11, 589, 8, 11, 1, 12, 1, 12, 1, 13, 5, 13, 594, 8, 13, 10, 13, 12,
        13, 597, 9, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
        14, 3, 14, 610, 8, 14, 1, 15, 5, 15, 613, 8, 15, 10, 15, 12, 15, 616, 9, 15, 1, 15, 1,
        15, 1, 15, 5, 15, 621, 8, 15, 10, 15, 12, 15, 624, 9, 15, 1, 15, 1, 15, 5, 15, 628, 8,
        15, 10, 15, 12, 15, 631, 9, 15, 1, 16, 5, 16, 634, 8, 16, 10, 16, 12, 16, 637, 9, 16,
        1, 16, 1, 16, 3, 16, 641, 8, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 649, 8,
        18, 10, 18, 12, 18, 652, 9, 18, 3, 18, 654, 8, 18, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1,
        20, 1, 20, 1, 21, 1, 21, 1, 21, 5, 21, 666, 8, 21, 10, 21, 12, 21, 669, 9, 21, 1, 22, 1,
        22, 3, 22, 673, 8, 22, 1, 23, 5, 23, 676, 8, 23, 10, 23, 12, 23, 679, 9, 23, 1, 23, 1,
        23, 3, 23, 683, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 689, 8, 24, 1, 25, 1, 25, 1, 25,
        3, 25, 694, 8, 25, 1, 26, 1, 26, 1, 26, 3, 26, 699, 8, 26, 1, 27, 1, 27, 1, 27, 3, 27, 704,
        8, 27, 1, 28, 1, 28, 1, 28, 3, 28, 709, 8, 28, 1, 29, 1, 29, 1, 29, 3, 29, 714, 8, 29, 1,
        29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 3, 31, 723, 8, 31, 1, 32, 1, 32, 3, 32, 727,
        8, 32, 1, 33, 3, 33, 730, 8, 33, 1, 33, 5, 33, 733, 8, 33, 10, 33, 12, 33, 736, 9, 33,
        1, 33, 5, 33, 739, 8, 33, 10, 33, 12, 33, 742, 9, 33, 1, 34, 5, 34, 745, 8, 34, 10, 34,
        12, 34, 748, 9, 34, 1, 34, 1, 34, 1, 35, 5, 35, 753, 8, 35, 10, 35, 12, 35, 756, 9, 35,
        1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 762, 8, 35, 10, 35, 12, 35, 765, 9, 35, 1, 35, 1, 35,
        1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 775, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38,
        1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
        1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 3, 42, 804, 8, 42,
        1, 43, 5, 43, 807, 8, 43, 10, 43, 12, 43, 810, 9, 43, 1, 43, 3, 43, 813, 8, 43, 1, 43,
        1, 43, 1, 43, 1, 43, 5, 43, 819, 8, 43, 10, 43, 12, 43, 822, 9, 43, 1, 43, 1, 43, 5, 43,
        826, 8, 43, 10, 43, 12, 43, 829, 9, 43, 1, 43, 1, 43, 1, 44, 1, 44, 5, 44, 835, 8, 44,
        10, 44, 12, 44, 838, 9, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        5, 44, 849, 8, 44, 10, 44, 12, 44, 852, 9, 44, 3, 44, 854, 8, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 864, 8, 44, 10, 44, 12, 44, 867, 9, 44, 3, 44,
        869, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 5, 44, 883, 8, 44, 10, 44, 12, 44, 886, 9, 44, 1, 44, 1, 44, 3, 44, 890, 8, 44,
        1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 3, 46, 897, 8, 46, 1, 47, 5, 47, 900, 8, 47, 10, 47,
        12, 47, 903, 9, 47, 1, 47, 1, 47, 1, 47, 3, 47, 908, 8, 47, 1, 47, 3, 47, 911, 8, 47, 1,
        47, 3, 47, 914, 8, 47, 1, 47, 3, 47, 917, 8, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48,
        1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 931, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49,
        1, 50, 1, 50, 1, 50, 5, 50, 940, 8, 50, 10, 50, 12, 50, 943, 9, 50, 1, 51, 1, 51, 1, 51,
        1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 5, 53, 954, 8, 53, 10, 53, 12, 53, 957, 9, 53,
        1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 963, 8, 54, 10, 54, 12, 54, 966, 9, 54, 1, 55, 1, 55,
        5, 55, 970, 8, 55, 10, 55, 12, 55, 973, 9, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56,
        3, 56, 981, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 988, 8, 57, 1, 58, 5, 58, 991,
        8, 58, 10, 58, 12, 58, 994, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59,
        1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1008, 8, 59, 1, 60, 1, 60, 1, 60, 5, 60, 1013, 8, 60,
        10, 60, 12, 60, 1016, 9, 60, 1, 61, 1, 61, 1, 61, 3, 61, 1021, 8, 61, 1, 62, 1, 62, 3,
        62, 1025, 8, 62, 1, 63, 1, 63, 3, 63, 1029, 8, 63, 1, 64, 1, 64, 3, 64, 1033, 8, 64, 1,
        65, 1, 65, 3, 65, 1037, 8, 65, 1, 66, 1, 66, 1, 66, 3, 66, 1042, 8, 66, 1, 67, 1, 67, 1,
        67, 5, 67, 1047, 8, 67, 10, 67, 12, 67, 1050, 9, 67, 3, 67, 1052, 8, 67, 1, 67, 1, 67,
        3, 67, 1056, 8, 67, 1, 67, 3, 67, 1059, 8, 67, 1, 68, 1, 68, 5, 68, 1063, 8, 68, 10, 68,
        12, 68, 1066, 9, 68, 1, 68, 1, 68, 3, 68, 1070, 8, 68, 1, 68, 3, 68, 1073, 8, 68, 1, 69,
        1, 69, 3, 69, 1077, 8, 69, 1, 69, 1, 69, 3, 69, 1081, 8, 69, 1, 69, 1, 69, 5, 69, 1085,
        8, 69, 10, 69, 12, 69, 1088, 9, 69, 1, 69, 1, 69, 3, 69, 1092, 8, 69, 3, 69, 1094, 8,
        69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 3, 72, 1103, 8, 72, 1, 72, 1, 72, 1,
        73, 5, 73, 1108, 8, 73, 10, 73, 12, 73, 1111, 9, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74,
        1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1126, 8, 74, 1, 75, 1, 75,
        5, 75, 1130, 8, 75, 10, 75, 12, 75, 1133, 9, 75, 3, 75, 1135, 8, 75, 1, 75, 1, 75, 1,
        75, 3, 75, 1140, 8, 75, 1, 76, 1, 76, 3, 76, 1144, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1,
        77, 3, 77, 1151, 8, 77, 1, 77, 3, 77, 1154, 8, 77, 1, 77, 1, 77, 3, 77, 1158, 8, 77, 1,
        78, 5, 78, 1161, 8, 78, 10, 78, 12, 78, 1164, 9, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1169,
        8, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 5, 79, 1176, 8, 79, 10, 79, 12, 79, 1179, 9,
        79, 1, 80, 5, 80, 1182, 8, 80, 10, 80, 12, 80, 1185, 9, 80, 1, 80, 1, 80, 1, 80, 1, 80,
        3, 80, 1191, 8, 80, 1, 81, 5, 81, 1194, 8, 81, 10, 81, 12, 81, 1197, 9, 81, 1, 81, 1,
        81, 5, 81, 1201, 8, 81, 10, 81, 12, 81, 1204, 9, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82,
        3, 82, 1211, 8, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 5, 84, 1219, 8, 84, 10, 84,
        12, 84, 1222, 9, 84, 1, 85, 1, 85, 3, 85, 1226, 8, 85, 1, 86, 1, 86, 3, 86, 1230, 8, 86,
        1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 89, 5, 89, 1238, 8, 89, 10, 89, 12, 89, 1241, 9,
        89, 1, 89, 1, 89, 3, 89, 1245, 8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1253,
        8, 90, 1, 91, 3, 91, 1256, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 1263, 8, 91,
        1, 91, 3, 91, 1266, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 3, 93, 1274, 8, 93,
        1, 93, 3, 93, 1277, 8, 93, 1, 93, 1, 93, 1, 94, 3, 94, 1282, 8, 94, 1, 94, 1, 94, 1, 94,
        3, 94, 1287, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1293, 8, 94, 1, 94, 1, 94, 3, 94,
        1297, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1302, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1307,
        8, 94, 1, 95, 5, 95, 1310, 8, 95, 10, 95, 12, 95, 1313, 9, 95, 1, 95, 1, 95, 1, 95, 3,
        95, 1318, 8, 95, 1, 95, 1, 95, 1, 96, 1, 96, 3, 96, 1324, 8, 96, 1, 96, 3, 96, 1327, 8,
        96, 1, 96, 3, 96, 1330, 8, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1337, 8, 97, 10,
        97, 12, 97, 1340, 9, 97, 1, 98, 5, 98, 1343, 8, 98, 10, 98, 12, 98, 1346, 9, 98, 1, 98,
        1, 98, 1, 98, 3, 98, 1351, 8, 98, 1, 98, 3, 98, 1354, 8, 98, 1, 98, 3, 98, 1357, 8, 98,
        1, 99, 1, 99, 1, 100, 1, 100, 5, 100, 1363, 8, 100, 10, 100, 12, 100, 1366, 9, 100,
        1, 101, 5, 101, 1369, 8, 101, 10, 101, 12, 101, 1372, 9, 101, 1, 101, 1, 101, 1, 101,
        3, 101, 1377, 8, 101, 1, 101, 1, 101, 3, 101, 1381, 8, 101, 1, 101, 1, 101, 1, 102,
        1, 102, 3, 102, 1387, 8, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 5, 103, 1394,
        8, 103, 10, 103, 12, 103, 1397, 9, 103, 1, 104, 5, 104, 1400, 8, 104, 10, 104, 12,
        104, 1403, 9, 104, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1409, 8, 104, 1, 105, 5,
        105, 1412, 8, 105, 10, 105, 12, 105, 1415, 9, 105, 1, 105, 1, 105, 5, 105, 1419, 8,
        105, 10, 105, 12, 105, 1422, 9, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 107,
        1, 107, 5, 107, 1431, 8, 107, 10, 107, 12, 107, 1434, 9, 107, 1, 107, 1, 107, 1, 108,
        1, 108, 3, 108, 1440, 8, 108, 1, 109, 5, 109, 1443, 8, 109, 10, 109, 12, 109, 1446,
        9, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 3, 110, 1453, 8, 110, 1, 111, 5, 111,
        1456, 8, 111, 10, 111, 12, 111, 1459, 9, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1464,
        8, 111, 1, 111, 3, 111, 1467, 8, 111, 1, 111, 3, 111, 1470, 8, 111, 1, 111, 1, 111,
        1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 1483,
        8, 112, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1492, 8, 114,
        10, 114, 12, 114, 1495, 9, 114, 1, 115, 1, 115, 5, 115, 1499, 8, 115, 10, 115, 12,
        115, 1502, 9, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1511,
        8, 116, 1, 117, 5, 117, 1514, 8, 117, 10, 117, 12, 117, 1517, 9, 117, 1, 117, 1, 117,
        1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1527, 8, 118, 1, 119, 5, 119,
        1530, 8, 119, 10, 119, 12, 119, 1533, 9, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120,
        1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1545, 8, 120, 1, 121, 5, 121, 1548,
        8, 121, 10, 121, 12, 121, 1551, 9, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122,
        1, 122, 5, 122, 1560, 8, 122, 10, 122, 12, 122, 1563, 9, 122, 1, 122, 1, 122, 1, 123,
        1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1572, 8, 123, 1, 124, 5, 124, 1575, 8, 124,
        10, 124, 12, 124, 1578, 9, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1585,
        8, 124, 1, 124, 3, 124, 1588, 8, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 3, 125,
        1595, 8, 125, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 3, 127, 1603, 8, 127,
        1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1609, 8, 128, 1, 128, 1, 128, 1, 129, 1, 129,
        1, 129, 5, 129, 1616, 8, 129, 10, 129, 12, 129, 1619, 9, 129, 1, 130, 1, 130, 1, 130,
        1, 130, 1, 131, 1, 131, 1, 131, 3, 131, 1628, 8, 131, 1, 132, 1, 132, 3, 132, 1632,
        8, 132, 1, 132, 3, 132, 1635, 8, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 5, 133,
        1642, 8, 133, 10, 133, 12, 133, 1645, 9, 133, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135,
        1, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 3, 136, 1658, 8, 136, 1, 136, 3, 136,
        1661, 8, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 5, 137, 1668, 8, 137, 10, 137,
        12, 137, 1671, 9, 137, 1, 138, 1, 138, 3, 138, 1675, 8, 138, 1, 138, 1, 138, 1, 139,
        1, 139, 5, 139, 1681, 8, 139, 10, 139, 12, 139, 1684, 9, 139, 1, 140, 1, 140, 1, 140,
        3, 140, 1689, 8, 140, 1, 141, 1, 141, 3, 141, 1693, 8, 141, 1, 142, 5, 142, 1696, 8,
        142, 10, 142, 12, 142, 1699, 9, 142, 1, 142, 1, 142, 3, 142, 1703, 8, 142, 1, 143,
        1, 143, 3, 143, 1707, 8, 143, 1, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145,
        1, 145, 1, 145, 3, 145, 1718, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146,
        1725, 8, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147,
        1, 147, 1, 147, 1, 147, 1, 147, 3, 147, 1740, 8, 147, 1, 148, 1, 148, 1, 149, 1, 149,
        1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152,
        1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 1762, 8, 152, 1, 153, 1, 153, 1, 153,
        1, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154,
        1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156,
        1, 156, 3, 156, 1790, 8, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157,
        1, 157, 1, 158, 1, 158, 1, 158, 5, 158, 1803, 8, 158, 10, 158, 12, 158, 1806, 9, 158,
        1, 158, 1, 158, 1, 158, 1, 158, 5, 158, 1812, 8, 158, 10, 158, 12, 158, 1815, 9, 158,
        1, 158, 1, 158, 1, 158, 5, 158, 1820, 8, 158, 10, 158, 12, 158, 1823, 9, 158, 1, 158,
        3, 158, 1826, 8, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 3, 159,
        1835, 8, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 1842, 8, 160, 10, 160,
        12, 160, 1845, 9, 160, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 5, 161, 1853,
        8, 161, 10, 161, 12, 161, 1856, 9, 161, 1, 161, 3, 161, 1859, 8, 161, 1, 162, 1, 162,
        1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164,
        1, 164, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166,
        3, 166, 1885, 8, 166, 1, 167, 1, 167, 3, 167, 1889, 8, 167, 1, 168, 1, 168, 1, 168,
        3, 168, 1894, 8, 168, 1, 168, 1, 168, 3, 168, 1898, 8, 168, 1, 168, 1, 168, 3, 168,
        1902, 8, 168, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 3, 169, 1910, 8, 169,
        1, 169, 1, 169, 3, 169, 1914, 8, 169, 1, 169, 1, 169, 3, 169, 1918, 8, 169, 1, 169,
        1, 169, 1, 169, 1, 170, 1, 170, 3, 170, 1925, 8, 170, 1, 171, 1, 171, 1, 172, 1, 172,
        1, 172, 5, 172, 1932, 8, 172, 10, 172, 12, 172, 1935, 9, 172, 1, 173, 1, 173, 1, 173,
        1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
        1, 174, 1, 174, 1, 175, 1, 175, 3, 175, 1955, 8, 175, 1, 175, 1, 175, 1, 176, 1, 176,
        3, 176, 1961, 8, 176, 1, 176, 1, 176, 1, 177, 1, 177, 3, 177, 1967, 8, 177, 1, 177,
        1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
        1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
        3, 180, 1992, 8, 180, 1, 180, 1, 180, 1, 180, 3, 180, 1997, 8, 180, 1, 181, 1, 181,
        5, 181, 2001, 8, 181, 10, 181, 12, 181, 2004, 9, 181, 1, 182, 1, 182, 1, 182, 1, 182,
        1, 182, 1, 182, 1, 183, 5, 183, 2013, 8, 183, 10, 183, 12, 183, 2016, 9, 183, 1, 183,
        1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 5, 184, 2024, 8, 184, 10, 184, 12, 184, 2027,
        9, 184, 1, 185, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 2036, 8, 186,
        1, 186, 3, 186, 2039, 8, 186, 1, 187, 1, 187, 1, 187, 3, 187, 2044, 8, 187, 1, 187,
        1, 187, 1, 188, 1, 188, 1, 188, 5, 188, 2051, 8, 188, 10, 188, 12, 188, 2054, 9, 188,
        1, 189, 1, 189, 3, 189, 2058, 8, 189, 1, 190, 1, 190, 3, 190, 2062, 8, 190, 1, 191,
        1, 191, 1, 191, 1, 191, 1, 192, 1, 192, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 2074,
        8, 194, 1, 195, 1, 195, 3, 195, 2078, 8, 195, 1, 196, 1, 196, 3, 196, 2082, 8, 196,
        1, 196, 1, 196, 3, 196, 2086, 8, 196, 1, 196, 1, 196, 3, 196, 2090, 8, 196, 1, 196,
        1, 196, 1, 196, 1, 196, 3, 196, 2096, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196,
        2102, 8, 196, 1, 196, 1, 196, 3, 196, 2106, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196,
        3, 196, 2112, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2118, 8, 196, 1, 196,
        1, 196, 1, 196, 1, 196, 3, 196, 2124, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196,
        2130, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2138, 8, 196,
        1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2145, 8, 196, 1, 196, 1, 196, 1, 196,
        1, 196, 1, 196, 3, 196, 2152, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2157, 8, 196,
        1, 196, 1, 196, 3, 196, 2161, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2166, 8, 196,
        1, 196, 1, 196, 1, 196, 3, 196, 2171, 8, 196, 1, 196, 1, 196, 3, 196, 2175, 8, 196,
        1, 196, 1, 196, 1, 196, 3, 196, 2180, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2185,
        8, 196, 1, 196, 1, 196, 3, 196, 2189, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2194,
        8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2199, 8, 196, 1, 196, 1, 196, 3, 196, 2203,
        8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2208, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196,
        2213, 8, 196, 1, 196, 1, 196, 3, 196, 2217, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196,
        1, 196, 3, 196, 2224, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2229, 8, 196, 1, 196,
        1, 196, 3, 196, 2233, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2238, 8, 196, 1, 196,
        1, 196, 3, 196, 2242, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2247, 8, 196, 1, 196,
        1, 196, 3, 196, 2251, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2256, 8, 196, 1, 196,
        1, 196, 3, 196, 2260, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2265, 8, 196, 1, 196,
        1, 196, 3, 196, 2269, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2276,
        8, 196, 1, 196, 1, 196, 3, 196, 2280, 8, 196, 1, 196, 1, 196, 1, 196, 3, 196, 2285,
        8, 196, 1, 196, 1, 196, 3, 196, 2289, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196,
        2295, 8, 196, 3, 196, 2297, 8, 196, 1, 197, 1, 197, 1, 197, 3, 197, 2302, 8, 197, 1,
        197, 1, 197, 1, 197, 3, 197, 2307, 8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 2313,
        8, 197, 1, 197, 1, 197, 3, 197, 2317, 8, 197, 1, 197, 1, 197, 1, 197, 3, 197, 2322,
        8, 197, 1, 197, 1, 197, 3, 197, 2326, 8, 197, 1, 197, 1, 197, 3, 197, 2330, 8, 197,
        1, 197, 1, 197, 3, 197, 2334, 8, 197, 3, 197, 2336, 8, 197, 1, 198, 1, 198, 1, 198,
        5, 198, 2341, 8, 198, 10, 198, 12, 198, 2344, 9, 198, 1, 198, 1, 198, 1, 198, 1, 198,
        1, 198, 1, 198, 5, 198, 2352, 8, 198, 10, 198, 12, 198, 2355, 9, 198, 1, 198, 1, 198,
        1, 198, 1, 198, 1, 198, 1, 198, 5, 198, 2363, 8, 198, 10, 198, 12, 198, 2366, 9, 198,
        1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 2373, 8, 198, 1, 199, 1, 199, 1, 199,
        1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 2384, 8, 199, 1, 200, 1, 200,
        3, 200, 2388, 8, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2393, 8, 200, 1, 200, 1, 200,
        3, 200, 2397, 8, 200, 1, 201, 5, 201, 2400, 8, 201, 10, 201, 12, 201, 2403, 9, 201,
        1, 201, 1, 201, 1, 201, 5, 201, 2408, 8, 201, 10, 201, 12, 201, 2411, 9, 201, 1, 201,
        5, 201, 2414, 8, 201, 10, 201, 12, 201, 2417, 9, 201, 1, 201, 3, 201, 2420, 8, 201,
        1, 202, 1, 202, 3, 202, 2424, 8, 202, 1, 203, 1, 203, 3, 203, 2428, 8, 203, 1, 204,
        1, 204, 1, 204, 1, 204, 3, 204, 2434, 8, 204, 1, 204, 1, 204, 1, 204, 1, 204, 3, 204,
        2440, 8, 204, 3, 204, 2442, 8, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205,
        1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 2454, 8, 205, 1, 206, 1, 206, 5, 206, 2458,
        8, 206, 10, 206, 12, 206, 2461, 9, 206, 1, 207, 5, 207, 2464, 8, 207, 10, 207, 12,
        207, 2467, 9, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1,
        208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208,
        3, 208, 2488, 8, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
        1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 2503, 8, 209, 1, 210, 1, 210, 1, 210,
        3, 210, 2508, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2515, 8, 210,
        1, 210, 1, 210, 1, 210, 3, 210, 2520, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
        3, 210, 2527, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2532, 8, 210, 1, 210, 1, 210,
        1, 210, 1, 210, 1, 210, 3, 210, 2539, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2544,
        8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2551, 8, 210, 1, 210, 1, 210,
        1, 210, 3, 210, 2556, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210,
        2564, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2569, 8, 210, 1, 210, 1, 210, 3, 210,
        2573, 8, 210, 1, 211, 1, 211, 1, 211, 5, 211, 2578, 8, 211, 10, 211, 12, 211, 2581,
        9, 211, 1, 212, 1, 212, 1, 212, 3, 212, 2586, 8, 212, 1, 212, 1, 212, 1, 212, 1, 212,
        1, 212, 3, 212, 2593, 8, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 3, 212, 2600,
        8, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 3, 212, 2607, 8, 212, 1, 212, 1, 212,
        1, 212, 1, 212, 1, 212, 1, 212, 3, 212, 2615, 8, 212, 1, 212, 1, 212, 1, 212, 1, 212,
        1, 212, 3, 212, 2622, 8, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 3, 212,
        2630, 8, 212, 1, 213, 1, 213, 3, 213, 2634, 8, 213, 1, 213, 1, 213, 3, 213, 2638, 8,
        213, 3, 213, 2640, 8, 213, 1, 214, 1, 214, 3, 214, 2644, 8, 214, 1, 214, 1, 214, 3,
        214, 2648, 8, 214, 3, 214, 2650, 8, 214, 1, 215, 1, 215, 1, 215, 1, 216, 1, 216, 1,
        216, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 2665, 8, 217, 1,
        218, 1, 218, 1, 218, 1, 219, 1, 219, 1, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220,
        1, 220, 1, 220, 3, 220, 2680, 8, 220, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221,
        1, 221, 1, 221, 5, 221, 2690, 8, 221, 10, 221, 12, 221, 2693, 9, 221, 1, 221, 1, 221,
        1, 221, 1, 221, 1, 221, 1, 221, 5, 221, 2701, 8, 221, 10, 221, 12, 221, 2704, 9, 221,
        1, 221, 1, 221, 1, 221, 3, 221, 2709, 8, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222,
        1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 5, 222, 2723, 8, 222, 10, 222,
        12, 222, 2726, 9, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223,
        1, 223, 5, 223, 2737, 8, 223, 10, 223, 12, 223, 2740, 9, 223, 1, 224, 1, 224, 1, 224,
        1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224,
        1, 224, 1, 224, 5, 224, 2758, 8, 224, 10, 224, 12, 224, 2761, 9, 224, 1, 225, 1, 225,
        1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225,
        1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225, 2782, 8, 225, 5, 225, 2784,
        8, 225, 10, 225, 12, 225, 2787, 9, 225, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
        1, 226, 1, 226, 1, 226, 5, 226, 2798, 8, 226, 10, 226, 12, 226, 2801, 9, 226, 1, 227,
        1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 5, 227, 2809, 8, 227, 10, 227, 12, 227, 2812,
        9, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 5, 228, 2820, 8, 228, 10, 228,
        12, 228, 2823, 9, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 5, 229, 2831,
        8, 229, 10, 229, 12, 229, 2834, 9, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230,
        5, 230, 2842, 8, 230, 10, 230, 12, 230, 2845, 9, 230, 1, 231, 1, 231, 1, 231, 1, 231,
        1, 231, 1, 231, 5, 231, 2853, 8, 231, 10, 231, 12, 231, 2856, 9, 231, 1, 232, 1, 232,
        1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232,
        3, 232, 2871, 8, 232, 1, 233, 1, 233, 3, 233, 2875, 8, 233, 1, 234, 1, 234, 1, 234,
        1, 234, 1, 235, 1, 235, 1, 235, 3, 235, 2884, 8, 235, 1, 236, 1, 236, 1, 237, 1, 237,
        1, 237, 1, 237, 1, 238, 1, 238, 3, 238, 2894, 8, 238, 1, 238, 1, 238, 3, 238, 2898,
        8, 238, 1, 239, 1, 239, 1, 239, 5, 239, 2903, 8, 239, 10, 239, 12, 239, 2906, 9, 239,
        1, 239, 1, 239, 1, 239, 5, 239, 2911, 8, 239, 10, 239, 12, 239, 2914, 9, 239, 3, 239,
        2916, 8, 239, 1, 240, 5, 240, 2919, 8, 240, 10, 240, 12, 240, 2922, 9, 240, 1, 240,
        1, 240, 1, 240, 1, 240, 3, 240, 2928, 8, 240, 1, 241, 1, 241, 3, 241, 2932, 8, 241,
        1, 242, 1, 242, 3, 242, 2936, 8, 242, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243,
        1, 244, 1, 244, 1, 244, 0, 10, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 245,
        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
        46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
        90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
        126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
        158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
        190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220,
        222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252,
        254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
        286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316,
        318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
        350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380,
        382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
        414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444,
        446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476,
        478, 480, 482, 484, 486, 488, 0, 6, 1, 0, 69, 75, 5, 0, 22, 22, 25, 25, 44, 44, 46, 46,
        54, 54, 2, 0, 31, 31, 37, 37, 2, 0, 13, 13, 55, 55, 2, 0, 57, 57, 60, 60, 2, 0, 88, 88,
        112, 122, 3206, 0, 490, 1, 0, 0, 0, 2, 493, 1, 0, 0, 0, 4, 495, 1, 0, 0, 0, 6, 497, 1, 0,
        0, 0, 8, 502, 1, 0, 0, 0, 10, 511, 1, 0, 0, 0, 12, 513, 1, 0, 0, 0, 14, 515, 1, 0, 0, 0, 16,
        520, 1, 0, 0, 0, 18, 522, 1, 0, 0, 0, 20, 539, 1, 0, 0, 0, 22, 588, 1, 0, 0, 0, 24, 590,
        1, 0, 0, 0, 26, 595, 1, 0, 0, 0, 28, 609, 1, 0, 0, 0, 30, 614, 1, 0, 0, 0, 32, 635, 1, 0,
        0, 0, 34, 642, 1, 0, 0, 0, 36, 644, 1, 0, 0, 0, 38, 655, 1, 0, 0, 0, 40, 658, 1, 0, 0, 0,
        42, 662, 1, 0, 0, 0, 44, 672, 1, 0, 0, 0, 46, 677, 1, 0, 0, 0, 48, 688, 1, 0, 0, 0, 50, 690,
        1, 0, 0, 0, 52, 695, 1, 0, 0, 0, 54, 700, 1, 0, 0, 0, 56, 705, 1, 0, 0, 0, 58, 713, 1, 0,
        0, 0, 60, 717, 1, 0, 0, 0, 62, 719, 1, 0, 0, 0, 64, 726, 1, 0, 0, 0, 66, 729, 1, 0, 0, 0,
        68, 746, 1, 0, 0, 0, 70, 754, 1, 0, 0, 0, 72, 768, 1, 0, 0, 0, 74, 774, 1, 0, 0, 0, 76, 776,
        1, 0, 0, 0, 78, 780, 1, 0, 0, 0, 80, 786, 1, 0, 0, 0, 82, 793, 1, 0, 0, 0, 84, 803, 1, 0,
        0, 0, 86, 808, 1, 0, 0, 0, 88, 889, 1, 0, 0, 0, 90, 891, 1, 0, 0, 0, 92, 896, 1, 0, 0, 0,
        94, 901, 1, 0, 0, 0, 96, 930, 1, 0, 0, 0, 98, 932, 1, 0, 0, 0, 100, 936, 1, 0, 0, 0, 102,
        944, 1, 0, 0, 0, 104, 947, 1, 0, 0, 0, 106, 950, 1, 0, 0, 0, 108, 958, 1, 0, 0, 0, 110,
        967, 1, 0, 0, 0, 112, 980, 1, 0, 0, 0, 114, 987, 1, 0, 0, 0, 116, 992, 1, 0, 0, 0, 118,
        1007, 1, 0, 0, 0, 120, 1009, 1, 0, 0, 0, 122, 1017, 1, 0, 0, 0, 124, 1022, 1, 0, 0, 0,
        126, 1028, 1, 0, 0, 0, 128, 1032, 1, 0, 0, 0, 130, 1036, 1, 0, 0, 0, 132, 1041, 1, 0,
        0, 0, 134, 1051, 1, 0, 0, 0, 136, 1060, 1, 0, 0, 0, 138, 1093, 1, 0, 0, 0, 140, 1095,
        1, 0, 0, 0, 142, 1097, 1, 0, 0, 0, 144, 1102, 1, 0, 0, 0, 146, 1109, 1, 0, 0, 0, 148, 1125,
        1, 0, 0, 0, 150, 1134, 1, 0, 0, 0, 152, 1143, 1, 0, 0, 0, 154, 1145, 1, 0, 0, 0, 156, 1162,
        1, 0, 0, 0, 158, 1172, 1, 0, 0, 0, 160, 1190, 1, 0, 0, 0, 162, 1195, 1, 0, 0, 0, 164, 1210,
        1, 0, 0, 0, 166, 1212, 1, 0, 0, 0, 168, 1215, 1, 0, 0, 0, 170, 1225, 1, 0, 0, 0, 172, 1229,
        1, 0, 0, 0, 174, 1231, 1, 0, 0, 0, 176, 1233, 1, 0, 0, 0, 178, 1239, 1, 0, 0, 0, 180, 1252,
        1, 0, 0, 0, 182, 1255, 1, 0, 0, 0, 184, 1269, 1, 0, 0, 0, 186, 1271, 1, 0, 0, 0, 188, 1306,
        1, 0, 0, 0, 190, 1311, 1, 0, 0, 0, 192, 1321, 1, 0, 0, 0, 194, 1333, 1, 0, 0, 0, 196, 1344,
        1, 0, 0, 0, 198, 1358, 1, 0, 0, 0, 200, 1360, 1, 0, 0, 0, 202, 1370, 1, 0, 0, 0, 204, 1384,
        1, 0, 0, 0, 206, 1390, 1, 0, 0, 0, 208, 1408, 1, 0, 0, 0, 210, 1413, 1, 0, 0, 0, 212, 1426,
        1, 0, 0, 0, 214, 1428, 1, 0, 0, 0, 216, 1439, 1, 0, 0, 0, 218, 1444, 1, 0, 0, 0, 220, 1452,
        1, 0, 0, 0, 222, 1457, 1, 0, 0, 0, 224, 1482, 1, 0, 0, 0, 226, 1484, 1, 0, 0, 0, 228, 1487,
        1, 0, 0, 0, 230, 1496, 1, 0, 0, 0, 232, 1510, 1, 0, 0, 0, 234, 1515, 1, 0, 0, 0, 236, 1526,
        1, 0, 0, 0, 238, 1531, 1, 0, 0, 0, 240, 1544, 1, 0, 0, 0, 242, 1549, 1, 0, 0, 0, 244, 1557,
        1, 0, 0, 0, 246, 1571, 1, 0, 0, 0, 248, 1576, 1, 0, 0, 0, 250, 1594, 1, 0, 0, 0, 252, 1596,
        1, 0, 0, 0, 254, 1602, 1, 0, 0, 0, 256, 1604, 1, 0, 0, 0, 258, 1612, 1, 0, 0, 0, 260, 1620,
        1, 0, 0, 0, 262, 1627, 1, 0, 0, 0, 264, 1629, 1, 0, 0, 0, 266, 1638, 1, 0, 0, 0, 268, 1646,
        1, 0, 0, 0, 270, 1649, 1, 0, 0, 0, 272, 1655, 1, 0, 0, 0, 274, 1664, 1, 0, 0, 0, 276, 1672,
        1, 0, 0, 0, 278, 1678, 1, 0, 0, 0, 280, 1688, 1, 0, 0, 0, 282, 1692, 1, 0, 0, 0, 284, 1697,
        1, 0, 0, 0, 286, 1706, 1, 0, 0, 0, 288, 1708, 1, 0, 0, 0, 290, 1717, 1, 0, 0, 0, 292, 1724,
        1, 0, 0, 0, 294, 1739, 1, 0, 0, 0, 296, 1741, 1, 0, 0, 0, 298, 1743, 1, 0, 0, 0, 300, 1747,
        1, 0, 0, 0, 302, 1751, 1, 0, 0, 0, 304, 1761, 1, 0, 0, 0, 306, 1763, 1, 0, 0, 0, 308, 1769,
        1, 0, 0, 0, 310, 1777, 1, 0, 0, 0, 312, 1785, 1, 0, 0, 0, 314, 1793, 1, 0, 0, 0, 316, 1825,
        1, 0, 0, 0, 318, 1827, 1, 0, 0, 0, 320, 1836, 1, 0, 0, 0, 322, 1858, 1, 0, 0, 0, 324, 1860,
        1, 0, 0, 0, 326, 1862, 1, 0, 0, 0, 328, 1868, 1, 0, 0, 0, 330, 1874, 1, 0, 0, 0, 332, 1884,
        1, 0, 0, 0, 334, 1888, 1, 0, 0, 0, 336, 1890, 1, 0, 0, 0, 338, 1906, 1, 0, 0, 0, 340, 1924,
        1, 0, 0, 0, 342, 1926, 1, 0, 0, 0, 344, 1928, 1, 0, 0, 0, 346, 1936, 1, 0, 0, 0, 348, 1944,
        1, 0, 0, 0, 350, 1952, 1, 0, 0, 0, 352, 1958, 1, 0, 0, 0, 354, 1964, 1, 0, 0, 0, 356, 1970,
        1, 0, 0, 0, 358, 1974, 1, 0, 0, 0, 360, 1996, 1, 0, 0, 0, 362, 1998, 1, 0, 0, 0, 364, 2005,
        1, 0, 0, 0, 366, 2014, 1, 0, 0, 0, 368, 2020, 1, 0, 0, 0, 370, 2028, 1, 0, 0, 0, 372, 2031,
        1, 0, 0, 0, 374, 2040, 1, 0, 0, 0, 376, 2047, 1, 0, 0, 0, 378, 2057, 1, 0, 0, 0, 380, 2061,
        1, 0, 0, 0, 382, 2063, 1, 0, 0, 0, 384, 2067, 1, 0, 0, 0, 386, 2069, 1, 0, 0, 0, 388, 2073,
        1, 0, 0, 0, 390, 2077, 1, 0, 0, 0, 392, 2296, 1, 0, 0, 0, 394, 2335, 1, 0, 0, 0, 396, 2372,
        1, 0, 0, 0, 398, 2383, 1, 0, 0, 0, 400, 2385, 1, 0, 0, 0, 402, 2401, 1, 0, 0, 0, 404, 2423,
        1, 0, 0, 0, 406, 2427, 1, 0, 0, 0, 408, 2441, 1, 0, 0, 0, 410, 2453, 1, 0, 0, 0, 412, 2455,
        1, 0, 0, 0, 414, 2465, 1, 0, 0, 0, 416, 2487, 1, 0, 0, 0, 418, 2502, 1, 0, 0, 0, 420, 2572,
        1, 0, 0, 0, 422, 2574, 1, 0, 0, 0, 424, 2629, 1, 0, 0, 0, 426, 2639, 1, 0, 0, 0, 428, 2649,
        1, 0, 0, 0, 430, 2651, 1, 0, 0, 0, 432, 2654, 1, 0, 0, 0, 434, 2664, 1, 0, 0, 0, 436, 2666,
        1, 0, 0, 0, 438, 2669, 1, 0, 0, 0, 440, 2679, 1, 0, 0, 0, 442, 2708, 1, 0, 0, 0, 444, 2710,
        1, 0, 0, 0, 446, 2727, 1, 0, 0, 0, 448, 2741, 1, 0, 0, 0, 450, 2762, 1, 0, 0, 0, 452, 2788,
        1, 0, 0, 0, 454, 2802, 1, 0, 0, 0, 456, 2813, 1, 0, 0, 0, 458, 2824, 1, 0, 0, 0, 460, 2835,
        1, 0, 0, 0, 462, 2846, 1, 0, 0, 0, 464, 2870, 1, 0, 0, 0, 466, 2874, 1, 0, 0, 0, 468, 2876,
        1, 0, 0, 0, 470, 2883, 1, 0, 0, 0, 472, 2885, 1, 0, 0, 0, 474, 2887, 1, 0, 0, 0, 476, 2897,
        1, 0, 0, 0, 478, 2915, 1, 0, 0, 0, 480, 2927, 1, 0, 0, 0, 482, 2931, 1, 0, 0, 0, 484, 2935,
        1, 0, 0, 0, 486, 2937, 1, 0, 0, 0, 488, 2943, 1, 0, 0, 0, 490, 491, 3, 64, 32, 0, 491,
        492, 5, 0, 0, 1, 492, 1, 1, 0, 0, 0, 493, 494, 7, 0, 0, 0, 494, 3, 1, 0, 0, 0, 495, 496,
        5, 123, 0, 0, 496, 5, 1, 0, 0, 0, 497, 498, 5, 123, 0, 0, 498, 7, 1, 0, 0, 0, 499, 501,
        3, 254, 127, 0, 500, 499, 1, 0, 0, 0, 501, 504, 1, 0, 0, 0, 502, 500, 1, 0, 0, 0, 502,
        503, 1, 0, 0, 0, 503, 507, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 505, 508, 3, 10, 5, 0, 506,
        508, 5, 20, 0, 0, 507, 505, 1, 0, 0, 0, 507, 506, 1, 0, 0, 0, 508, 9, 1, 0, 0, 0, 509, 512,
        3, 12, 6, 0, 510, 512, 3, 14, 7, 0, 511, 509, 1, 0, 0, 0, 511, 510, 1, 0, 0, 0, 512, 11,
        1, 0, 0, 0, 513, 514, 7, 1, 0, 0, 514, 13, 1, 0, 0, 0, 515, 516, 7, 2, 0, 0, 516, 15, 1,
        0, 0, 0, 517, 521, 3, 20, 10, 0, 518, 521, 3, 26, 13, 0, 519, 521, 3, 28, 14, 0, 520,
        517, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 519, 1, 0, 0, 0, 521, 17, 1, 0, 0, 0, 522, 526,
        5, 84, 0, 0, 523, 525, 3, 254, 127, 0, 524, 523, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526,
        524, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 529, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529,
        531, 3, 4, 2, 0, 530, 532, 3, 40, 20, 0, 531, 530, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532,
        534, 1, 0, 0, 0, 533, 535, 3, 18, 9, 0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535,
        19, 1, 0, 0, 0, 536, 537, 3, 52, 26, 0, 537, 538, 5, 84, 0, 0, 538, 540, 1, 0, 0, 0, 539,
        536, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 544, 1, 0, 0, 0, 541, 543, 3, 254, 127, 0,
        542, 541, 1, 0, 0, 0, 543, 546, 1, 0, 0, 0, 544, 542, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0,
        545, 547, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 547, 549, 3, 4, 2, 0, 548, 550, 3, 40, 20,
        0, 549, 548, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 552, 1, 0, 0, 0, 551, 553, 3, 18, 9,
        0, 552, 551, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 21, 1, 0, 0, 0, 554, 556, 3, 254, 127,
        0, 555, 554, 1, 0, 0, 0, 556, 559, 1, 0, 0, 0, 557, 555, 1, 0, 0, 0, 557, 558, 1, 0, 0,
        0, 558, 560, 1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 560, 562, 3, 4, 2, 0, 561, 563, 3, 40, 20,
        0, 562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 589, 1, 0, 0, 0, 564, 565, 3, 52, 26,
        0, 565, 569, 5, 84, 0, 0, 566, 568, 3, 254, 127, 0, 567, 566, 1, 0, 0, 0, 568, 571, 1,
        0, 0, 0, 569, 567, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 572, 1, 0, 0, 0, 571, 569, 1,
        0, 0, 0, 572, 574, 3, 4, 2, 0, 573, 575, 3, 40, 20, 0, 574, 573, 1, 0, 0, 0, 574, 575,
        1, 0, 0, 0, 575, 589, 1, 0, 0, 0, 576, 577, 3, 20, 10, 0, 577, 581, 5, 84, 0, 0, 578, 580,
        3, 254, 127, 0, 579, 578, 1, 0, 0, 0, 580, 583, 1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 581,
        582, 1, 0, 0, 0, 582, 584, 1, 0, 0, 0, 583, 581, 1, 0, 0, 0, 584, 586, 3, 4, 2, 0, 585,
        587, 3, 40, 20, 0, 586, 585, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 589, 1, 0, 0, 0, 588,
        557, 1, 0, 0, 0, 588, 564, 1, 0, 0, 0, 588, 576, 1, 0, 0, 0, 589, 23, 1, 0, 0, 0, 590, 591,
        3, 22, 11, 0, 591, 25, 1, 0, 0, 0, 592, 594, 3, 254, 127, 0, 593, 592, 1, 0, 0, 0, 594,
        597, 1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 598, 1, 0, 0, 0, 597,
        595, 1, 0, 0, 0, 598, 599, 3, 4, 2, 0, 599, 27, 1, 0, 0, 0, 600, 601, 3, 8, 4, 0, 601, 602,
        3, 30, 15, 0, 602, 610, 1, 0, 0, 0, 603, 604, 3, 22, 11, 0, 604, 605, 3, 30, 15, 0, 605,
        610, 1, 0, 0, 0, 606, 607, 3, 26, 13, 0, 607, 608, 3, 30, 15, 0, 608, 610, 1, 0, 0, 0,
        609, 600, 1, 0, 0, 0, 609, 603, 1, 0, 0, 0, 609, 606, 1, 0, 0, 0, 610, 29, 1, 0, 0, 0, 611,
        613, 3, 254, 127, 0, 612, 611, 1, 0, 0, 0, 613, 616, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0,
        614, 615, 1, 0, 0, 0, 615, 617, 1, 0, 0, 0, 616, 614, 1, 0, 0, 0, 617, 618, 5, 80, 0, 0,
        618, 629, 5, 81, 0, 0, 619, 621, 3, 254, 127, 0, 620, 619, 1, 0, 0, 0, 621, 624, 1, 0,
        0, 0, 622, 620, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 625, 1, 0, 0, 0, 624, 622, 1, 0,
        0, 0, 625, 626, 5, 80, 0, 0, 626, 628, 5, 81, 0, 0, 627, 622, 1, 0, 0, 0, 628, 631, 1,
        0, 0, 0, 629, 627, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630, 31, 1, 0, 0, 0, 631, 629, 1, 0,
        0, 0, 632, 634, 3, 34, 17, 0, 633, 632, 1, 0, 0, 0, 634, 637, 1, 0, 0, 0, 635, 633, 1,
        0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 638, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0, 638, 640, 3,
        4, 2, 0, 639, 641, 3, 36, 18, 0, 640, 639, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 33, 1,
        0, 0, 0, 642, 643, 3, 254, 127, 0, 643, 35, 1, 0, 0, 0, 644, 653, 5, 34, 0, 0, 645, 654,
        3, 26, 13, 0, 646, 650, 3, 20, 10, 0, 647, 649, 3, 38, 19, 0, 648, 647, 1, 0, 0, 0, 649,
        652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650, 651, 1, 0, 0, 0, 651, 654, 1, 0, 0, 0, 652,
        650, 1, 0, 0, 0, 653, 645, 1, 0, 0, 0, 653, 646, 1, 0, 0, 0, 654, 37, 1, 0, 0, 0, 655, 656,
        5, 108, 0, 0, 656, 657, 3, 24, 12, 0, 657, 39, 1, 0, 0, 0, 658, 659, 5, 90, 0, 0, 659,
        660, 3, 42, 21, 0, 660, 661, 5, 89, 0, 0, 661, 41, 1, 0, 0, 0, 662, 667, 3, 44, 22, 0,
        663, 664, 5, 83, 0, 0, 664, 666, 3, 44, 22, 0, 665, 663, 1, 0, 0, 0, 666, 669, 1, 0, 0,
        0, 667, 665, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 43, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0,
        670, 673, 3, 16, 8, 0, 671, 673, 3, 46, 23, 0, 672, 670, 1, 0, 0, 0, 672, 671, 1, 0, 0,
        0, 673, 45, 1, 0, 0, 0, 674, 676, 3, 254, 127, 0, 675, 674, 1, 0, 0, 0, 676, 679, 1, 0,
        0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 680, 1, 0, 0, 0, 679, 677, 1, 0,
        0, 0, 680, 682, 5, 93, 0, 0, 681, 683, 3, 48, 24, 0, 682, 681, 1, 0, 0, 0, 682, 683, 1,
        0, 0, 0, 683, 47, 1, 0, 0, 0, 684, 685, 5, 34, 0, 0, 685, 689, 3, 16, 8, 0, 686, 687, 5,
        57, 0, 0, 687, 689, 3, 16, 8, 0, 688, 684, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 689, 49, 1,
        0, 0, 0, 690, 693, 5, 123, 0, 0, 691, 692, 5, 84, 0, 0, 692, 694, 3, 50, 25, 0, 693, 691,
        1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 51, 1, 0, 0, 0, 695, 698, 5, 123, 0, 0, 696, 697,
        5, 84, 0, 0, 697, 699, 3, 52, 26, 0, 698, 696, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 53,
        1, 0, 0, 0, 700, 703, 3, 52, 26, 0, 701, 702, 5, 84, 0, 0, 702, 704, 3, 4, 2, 0, 703, 701,
        1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 55, 1, 0, 0, 0, 705, 708, 5, 123, 0, 0, 706, 707,
        5, 84, 0, 0, 707, 709, 3, 56, 28, 0, 708, 706, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 57,
        1, 0, 0, 0, 710, 711, 3, 62, 31, 0, 711, 712, 5, 84, 0, 0, 712, 714, 1, 0, 0, 0, 713, 710,
        1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 716, 5, 123, 0, 0, 716, 59,
        1, 0, 0, 0, 717, 718, 3, 6, 3, 0, 718, 61, 1, 0, 0, 0, 719, 722, 5, 123, 0, 0, 720, 721,
        5, 84, 0, 0, 721, 723, 3, 62, 31, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 63,
        1, 0, 0, 0, 724, 727, 3, 66, 33, 0, 725, 727, 3, 68, 34, 0, 726, 724, 1, 0, 0, 0, 726,
        725, 1, 0, 0, 0, 727, 65, 1, 0, 0, 0, 728, 730, 3, 70, 35, 0, 729, 728, 1, 0, 0, 0, 729,
        730, 1, 0, 0, 0, 730, 734, 1, 0, 0, 0, 731, 733, 3, 74, 37, 0, 732, 731, 1, 0, 0, 0, 733,
        736, 1, 0, 0, 0, 734, 732, 1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 740, 1, 0, 0, 0, 736,
        734, 1, 0, 0, 0, 737, 739, 3, 84, 42, 0, 738, 737, 1, 0, 0, 0, 739, 742, 1, 0, 0, 0, 740,
        738, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 67, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 743, 745,
        3, 74, 37, 0, 744, 743, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 746, 747,
        1, 0, 0, 0, 747, 749, 1, 0, 0, 0, 748, 746, 1, 0, 0, 0, 749, 750, 3, 86, 43, 0, 750, 69,
        1, 0, 0, 0, 751, 753, 3, 72, 36, 0, 752, 751, 1, 0, 0, 0, 753, 756, 1, 0, 0, 0, 754, 752,
        1, 0, 0, 0, 754, 755, 1, 0, 0, 0, 755, 757, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 757, 758,
        5, 49, 0, 0, 758, 763, 5, 123, 0, 0, 759, 760, 5, 84, 0, 0, 760, 762, 5, 123, 0, 0, 761,
        759, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764,
        766, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766, 767, 5, 82, 0, 0, 767, 71, 1, 0, 0, 0, 768,
        769, 3, 254, 127, 0, 769, 73, 1, 0, 0, 0, 770, 775, 3, 76, 38, 0, 771, 775, 3, 78, 39,
        0, 772, 775, 3, 80, 40, 0, 773, 775, 3, 82, 41, 0, 774, 770, 1, 0, 0, 0, 774, 771, 1,
        0, 0, 0, 774, 772, 1, 0, 0, 0, 774, 773, 1, 0, 0, 0, 775, 75, 1, 0, 0, 0, 776, 777, 5, 42,
        0, 0, 777, 778, 3, 54, 27, 0, 778, 779, 5, 82, 0, 0, 779, 77, 1, 0, 0, 0, 780, 781, 5,
        42, 0, 0, 781, 782, 3, 56, 28, 0, 782, 783, 5, 84, 0, 0, 783, 784, 5, 106, 0, 0, 784,
        785, 5, 82, 0, 0, 785, 79, 1, 0, 0, 0, 786, 787, 5, 42, 0, 0, 787, 788, 5, 55, 0, 0, 788,
        789, 3, 54, 27, 0, 789, 790, 5, 84, 0, 0, 790, 791, 5, 123, 0, 0, 791, 792, 5, 82, 0,
        0, 792, 81, 1, 0, 0, 0, 793, 794, 5, 42, 0, 0, 794, 795, 5, 55, 0, 0, 795, 796, 3, 54,
        27, 0, 796, 797, 5, 84, 0, 0, 797, 798, 5, 106, 0, 0, 798, 799, 5, 82, 0, 0, 799, 83,
        1, 0, 0, 0, 800, 804, 3, 92, 46, 0, 801, 804, 3, 220, 110, 0, 802, 804, 5, 82, 0, 0, 803,
        800, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 803, 802, 1, 0, 0, 0, 804, 85, 1, 0, 0, 0, 805, 807,
        3, 254, 127, 0, 806, 805, 1, 0, 0, 0, 807, 810, 1, 0, 0, 0, 808, 806, 1, 0, 0, 0, 808,
        809, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 808, 1, 0, 0, 0, 811, 813, 5, 5, 0, 0, 812,
        811, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 815, 5, 2, 0, 0, 815,
        820, 5, 123, 0, 0, 816, 817, 5, 84, 0, 0, 817, 819, 5, 123, 0, 0, 818, 816, 1, 0, 0, 0,
        819, 822, 1, 0, 0, 0, 820, 818, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821, 823, 1, 0, 0, 0,
        822, 820, 1, 0, 0, 0, 823, 827, 5, 78, 0, 0, 824, 826, 3, 88, 44, 0, 825, 824, 1, 0, 0,
        0, 826, 829, 1, 0, 0, 0, 827, 825, 1, 0, 0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 1, 0, 0,
        0, 829, 827, 1, 0, 0, 0, 830, 831, 5, 79, 0, 0, 831, 87, 1, 0, 0, 0, 832, 836, 5, 10, 0,
        0, 833, 835, 3, 90, 45, 0, 834, 833, 1, 0, 0, 0, 835, 838, 1, 0, 0, 0, 836, 834, 1, 0,
        0, 0, 836, 837, 1, 0, 0, 0, 837, 839, 1, 0, 0, 0, 838, 836, 1, 0, 0, 0, 839, 840, 3, 50,
        25, 0, 840, 841, 5, 82, 0, 0, 841, 890, 1, 0, 0, 0, 842, 843, 5, 1, 0, 0, 843, 853, 3,
        52, 26, 0, 844, 845, 5, 12, 0, 0, 845, 850, 3, 50, 25, 0, 846, 847, 5, 83, 0, 0, 847,
        849, 3, 50, 25, 0, 848, 846, 1, 0, 0, 0, 849, 852, 1, 0, 0, 0, 850, 848, 1, 0, 0, 0, 850,
        851, 1, 0, 0, 0, 851, 854, 1, 0, 0, 0, 852, 850, 1, 0, 0, 0, 853, 844, 1, 0, 0, 0, 853,
        854, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 856, 5, 82, 0, 0, 856, 890, 1, 0, 0, 0, 857,
        858, 5, 6, 0, 0, 858, 868, 3, 52, 26, 0, 859, 860, 5, 12, 0, 0, 860, 865, 3, 50, 25, 0,
        861, 862, 5, 83, 0, 0, 862, 864, 3, 50, 25, 0, 863, 861, 1, 0, 0, 0, 864, 867, 1, 0, 0,
        0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 869, 1, 0, 0, 0, 867, 865, 1, 0, 0,
        0, 868, 859, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 5, 82, 0,
        0, 871, 890, 1, 0, 0, 0, 872, 873, 5, 14, 0, 0, 873, 874, 3, 54, 27, 0, 874, 875, 5, 82,
        0, 0, 875, 890, 1, 0, 0, 0, 876, 877, 5, 8, 0, 0, 877, 878, 3, 54, 27, 0, 878, 879, 5,
        16, 0, 0, 879, 884, 3, 54, 27, 0, 880, 881, 5, 83, 0, 0, 881, 883, 3, 54, 27, 0, 882,
        880, 1, 0, 0, 0, 883, 886, 1, 0, 0, 0, 884, 882, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885,
        887, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 887, 888, 5, 82, 0, 0, 888, 890, 1, 0, 0, 0, 889,
        832, 1, 0, 0, 0, 889, 842, 1, 0, 0, 0, 889, 857, 1, 0, 0, 0, 889, 872, 1, 0, 0, 0, 889,
        876, 1, 0, 0, 0, 890, 89, 1, 0, 0, 0, 891, 892, 7, 3, 0, 0, 892, 91, 1, 0, 0, 0, 893, 897,
        3, 94, 47, 0, 894, 897, 3, 190, 95, 0, 895, 897, 3, 202, 101, 0, 896, 893, 1, 0, 0, 0,
        896, 894, 1, 0, 0, 0, 896, 895, 1, 0, 0, 0, 897, 93, 1, 0, 0, 0, 898, 900, 3, 96, 48, 0,
        899, 898, 1, 0, 0, 0, 900, 903, 1, 0, 0, 0, 901, 899, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0,
        902, 904, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 904, 905, 5, 26, 0, 0, 905, 907, 3, 4, 2, 0,
        906, 908, 3, 98, 49, 0, 907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 910, 1, 0, 0,
        0, 909, 911, 3, 102, 51, 0, 910, 909, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 913, 1, 0,
        0, 0, 912, 914, 3, 104, 52, 0, 913, 912, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 916, 1,
        0, 0, 0, 915, 917, 3, 108, 54, 0, 916, 915, 1, 0, 0, 0, 916, 917, 1, 0, 0, 0, 917, 918,
        1, 0, 0, 0, 918, 919, 3, 110, 55, 0, 919, 95, 1, 0, 0, 0, 920, 931, 3, 254, 127, 0, 921,
        931, 5, 52, 0, 0, 922, 931, 5, 51, 0, 0, 923, 931, 5, 50, 0, 0, 924, 931, 5, 18, 0, 0,
        925, 931, 5, 55, 0, 0, 926, 931, 5, 35, 0, 0, 927, 931, 5, 11, 0, 0, 928, 931, 5, 3, 0,
        0, 929, 931, 5, 56, 0, 0, 930, 920, 1, 0, 0, 0, 930, 921, 1, 0, 0, 0, 930, 922, 1, 0, 0,
        0, 930, 923, 1, 0, 0, 0, 930, 924, 1, 0, 0, 0, 930, 925, 1, 0, 0, 0, 930, 926, 1, 0, 0,
        0, 930, 927, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 930, 929, 1, 0, 0, 0, 931, 97, 1, 0, 0, 0,
        932, 933, 5, 90, 0, 0, 933, 934, 3, 100, 50, 0, 934, 935, 5, 89, 0, 0, 935, 99, 1, 0,
        0, 0, 936, 941, 3, 32, 16, 0, 937, 938, 5, 83, 0, 0, 938, 940, 3, 32, 16, 0, 939, 937,
        1, 0, 0, 0, 940, 943, 1, 0, 0, 0, 941, 939, 1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 101,
        1, 0, 0, 0, 943, 941, 1, 0, 0, 0, 944, 945, 5, 34, 0, 0, 945, 946, 3, 22, 11, 0, 946, 103,
        1, 0, 0, 0, 947, 948, 5, 41, 0, 0, 948, 949, 3, 106, 53, 0, 949, 105, 1, 0, 0, 0, 950,
        955, 3, 24, 12, 0, 951, 952, 5, 83, 0, 0, 952, 954, 3, 24, 12, 0, 953, 951, 1, 0, 0, 0,
        954, 957, 1, 0, 0, 0, 955, 953, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 107, 1, 0, 0, 0,
        957, 955, 1, 0, 0, 0, 958, 959, 5, 7, 0, 0, 959, 964, 3, 54, 27, 0, 960, 961, 5, 83, 0,
        0, 961, 963, 3, 54, 27, 0, 962, 960, 1, 0, 0, 0, 963, 966, 1, 0, 0, 0, 964, 962, 1, 0,
        0, 0, 964, 965, 1, 0, 0, 0, 965, 109, 1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 971, 5, 78,
        0, 0, 968, 970, 3, 112, 56, 0, 969, 968, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1,
        0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 974, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 974, 975, 5,
        79, 0, 0, 975, 111, 1, 0, 0, 0, 976, 981, 3, 114, 57, 0, 977, 981, 3, 174, 87, 0, 978,
        981, 3, 176, 88, 0, 979, 981, 3, 178, 89, 0, 980, 976, 1, 0, 0, 0, 980, 977, 1, 0, 0,
        0, 980, 978, 1, 0, 0, 0, 980, 979, 1, 0, 0, 0, 981, 113, 1, 0, 0, 0, 982, 988, 3, 116,
        58, 0, 983, 988, 3, 146, 73, 0, 984, 988, 3, 92, 46, 0, 985, 988, 3, 220, 110, 0, 986,
        988, 5, 82, 0, 0, 987, 982, 1, 0, 0, 0, 987, 983, 1, 0, 0, 0, 987, 984, 1, 0, 0, 0, 987,
        985, 1, 0, 0, 0, 987, 986, 1, 0, 0, 0, 988, 115, 1, 0, 0, 0, 989, 991, 3, 118, 59, 0, 990,
        989, 1, 0, 0, 0, 991, 994, 1, 0, 0, 0, 992, 990, 1, 0, 0, 0, 992, 993, 1, 0, 0, 0, 993,
        995, 1, 0, 0, 0, 994, 992, 1, 0, 0, 0, 995, 996, 3, 128, 64, 0, 996, 997, 3, 120, 60,
        0, 997, 998, 5, 82, 0, 0, 998, 117, 1, 0, 0, 0, 999, 1008, 3, 254, 127, 0, 1000, 1008,
        5, 52, 0, 0, 1001, 1008, 5, 51, 0, 0, 1002, 1008, 5, 50, 0, 0, 1003, 1008, 5, 55, 0,
        0, 1004, 1008, 5, 35, 0, 0, 1005, 1008, 5, 63, 0, 0, 1006, 1008, 5, 66, 0, 0, 1007,
        999, 1, 0, 0, 0, 1007, 1000, 1, 0, 0, 0, 1007, 1001, 1, 0, 0, 0, 1007, 1002, 1, 0, 0,
        0, 1007, 1003, 1, 0, 0, 0, 1007, 1004, 1, 0, 0, 0, 1007, 1005, 1, 0, 0, 0, 1007, 1006,
        1, 0, 0, 0, 1008, 119, 1, 0, 0, 0, 1009, 1014, 3, 122, 61, 0, 1010, 1011, 5, 83, 0, 0,
        1011, 1013, 3, 122, 61, 0, 1012, 1010, 1, 0, 0, 0, 1013, 1016, 1, 0, 0, 0, 1014, 1012,
        1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 121, 1, 0, 0, 0, 1016, 1014, 1, 0, 0, 0, 1017,
        1020, 3, 124, 62, 0, 1018, 1019, 5, 88, 0, 0, 1019, 1021, 3, 126, 63, 0, 1020, 1018,
        1, 0, 0, 0, 1020, 1021, 1, 0, 0, 0, 1021, 123, 1, 0, 0, 0, 1022, 1024, 5, 123, 0, 0, 1023,
        1025, 3, 30, 15, 0, 1024, 1023, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 125, 1, 0,
        0, 0, 1026, 1029, 3, 388, 194, 0, 1027, 1029, 3, 272, 136, 0, 1028, 1026, 1, 0, 0,
        0, 1028, 1027, 1, 0, 0, 0, 1029, 127, 1, 0, 0, 0, 1030, 1033, 3, 130, 65, 0, 1031, 1033,
        3, 132, 66, 0, 1032, 1030, 1, 0, 0, 0, 1032, 1031, 1, 0, 0, 0, 1033, 129, 1, 0, 0, 0,
        1034, 1037, 3, 10, 5, 0, 1035, 1037, 5, 20, 0, 0, 1036, 1034, 1, 0, 0, 0, 1036, 1035,
        1, 0, 0, 0, 1037, 131, 1, 0, 0, 0, 1038, 1042, 3, 134, 67, 0, 1039, 1042, 3, 142, 71,
        0, 1040, 1042, 3, 144, 72, 0, 1041, 1038, 1, 0, 0, 0, 1041, 1039, 1, 0, 0, 0, 1041,
        1040, 1, 0, 0, 0, 1042, 133, 1, 0, 0, 0, 1043, 1044, 3, 52, 26, 0, 1044, 1048, 5, 84,
        0, 0, 1045, 1047, 3, 254, 127, 0, 1046, 1045, 1, 0, 0, 0, 1047, 1050, 1, 0, 0, 0, 1048,
        1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 1052, 1, 0, 0, 0, 1050, 1048, 1, 0, 0,
        0, 1051, 1043, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1055,
        3, 4, 2, 0, 1054, 1056, 3, 40, 20, 0, 1055, 1054, 1, 0, 0, 0, 1055, 1056, 1, 0, 0, 0,
        1056, 1058, 1, 0, 0, 0, 1057, 1059, 3, 136, 68, 0, 1058, 1057, 1, 0, 0, 0, 1058, 1059,
        1, 0, 0, 0, 1059, 135, 1, 0, 0, 0, 1060, 1064, 5, 84, 0, 0, 1061, 1063, 3, 254, 127,
        0, 1062, 1061, 1, 0, 0, 0, 1063, 1066, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0, 1064, 1065,
        1, 0, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1064, 1, 0, 0, 0, 1067, 1069, 3, 4, 2, 0, 1068,
        1070, 3, 40, 20, 0, 1069, 1068, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0, 1070, 1072, 1, 0,
        0, 0, 1071, 1073, 3, 136, 68, 0, 1072, 1071, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073,
        137, 1, 0, 0, 0, 1074, 1076, 3, 4, 2, 0, 1075, 1077, 3, 40, 20, 0, 1076, 1075, 1, 0,
        0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1094, 1, 0, 0, 0, 1078, 1081, 3, 52, 26, 0, 1079,
        1081, 3, 134, 67, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081, 1082, 1,
        0, 0, 0, 1082, 1086, 5, 84, 0, 0, 1083, 1085, 3, 254, 127, 0, 1084, 1083, 1, 0, 0, 0,
        1085, 1088, 1, 0, 0, 0, 1086, 1084, 1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1089,
        1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1089, 1091, 3, 4, 2, 0, 1090, 1092, 3, 40, 20, 0,
        1091, 1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1094, 1, 0, 0, 0, 1093, 1074,
        1, 0, 0, 0, 1093, 1080, 1, 0, 0, 0, 1094, 139, 1, 0, 0, 0, 1095, 1096, 3, 138, 69, 0,
        1096, 141, 1, 0, 0, 0, 1097, 1098, 3, 4, 2, 0, 1098, 143, 1, 0, 0, 0, 1099, 1103, 3,
        130, 65, 0, 1100, 1103, 3, 134, 67, 0, 1101, 1103, 3, 142, 71, 0, 1102, 1099, 1, 0,
        0, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1101, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1105,
        3, 30, 15, 0, 1105, 145, 1, 0, 0, 0, 1106, 1108, 3, 148, 74, 0, 1107, 1106, 1, 0, 0,
        0, 1108, 1111, 1, 0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1112,
        1, 0, 0, 0, 1111, 1109, 1, 0, 0, 0, 1112, 1113, 3, 150, 75, 0, 1113, 1114, 3, 172, 86,
        0, 1114, 147, 1, 0, 0, 0, 1115, 1126, 3, 254, 127, 0, 1116, 1126, 5, 52, 0, 0, 1117,
        1126, 5, 51, 0, 0, 1118, 1126, 5, 50, 0, 0, 1119, 1126, 5, 18, 0, 0, 1120, 1126, 5,
        55, 0, 0, 1121, 1126, 5, 35, 0, 0, 1122, 1126, 5, 59, 0, 0, 1123, 1126, 5, 47, 0, 0,
        1124, 1126, 5, 56, 0, 0, 1125, 1115, 1, 0, 0, 0, 1125, 1116, 1, 0, 0, 0, 1125, 1117,
        1, 0, 0, 0, 1125, 1118, 1, 0, 0, 0, 1125, 1119, 1, 0, 0, 0, 1125, 1120, 1, 0, 0, 0, 1125,
        1121, 1, 0, 0, 0, 1125, 1122, 1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1124, 1, 0, 0,
        0, 1126, 149, 1, 0, 0, 0, 1127, 1131, 3, 98, 49, 0, 1128, 1130, 3, 254, 127, 0, 1129,
        1128, 1, 0, 0, 0, 1130, 1133, 1, 0, 0, 0, 1131, 1129, 1, 0, 0, 0, 1131, 1132, 1, 0, 0,
        0, 1132, 1135, 1, 0, 0, 0, 1133, 1131, 1, 0, 0, 0, 1134, 1127, 1, 0, 0, 0, 1134, 1135,
        1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1137, 3, 152, 76, 0, 1137, 1139, 3, 154, 77,
        0, 1138, 1140, 3, 166, 83, 0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140,
        151, 1, 0, 0, 0, 1141, 1144, 3, 128, 64, 0, 1142, 1144, 5, 65, 0, 0, 1143, 1141, 1,
        0, 0, 0, 1143, 1142, 1, 0, 0, 0, 1144, 153, 1, 0, 0, 0, 1145, 1146, 5, 123, 0, 0, 1146,
        1150, 5, 76, 0, 0, 1147, 1148, 3, 156, 78, 0, 1148, 1149, 5, 83, 0, 0, 1149, 1151,
        1, 0, 0, 0, 1150, 1147, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1153, 1, 0, 0, 0, 1152,
        1154, 3, 158, 79, 0, 1153, 1152, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154, 1155, 1,
        0, 0, 0, 1155, 1157, 5, 77, 0, 0, 1156, 1158, 3, 30, 15, 0, 1157, 1156, 1, 0, 0, 0, 1157,
        1158, 1, 0, 0, 0, 1158, 155, 1, 0, 0, 0, 1159, 1161, 3, 254, 127, 0, 1160, 1159, 1,
        0, 0, 0, 1161, 1164, 1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163,
        1165, 1, 0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1165, 1168, 3, 128, 64, 0, 1166, 1167, 5,
        123, 0, 0, 1167, 1169, 5, 84, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169,
        1170, 1, 0, 0, 0, 1170, 1171, 5, 60, 0, 0, 1171, 157, 1, 0, 0, 0, 1172, 1177, 3, 160,
        80, 0, 1173, 1174, 5, 83, 0, 0, 1174, 1176, 3, 160, 80, 0, 1175, 1173, 1, 0, 0, 0, 1176,
        1179, 1, 0, 0, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 159, 1, 0, 0,
        0, 1179, 1177, 1, 0, 0, 0, 1180, 1182, 3, 164, 82, 0, 1181, 1180, 1, 0, 0, 0, 1182,
        1185, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0,
        0, 1185, 1183, 1, 0, 0, 0, 1186, 1187, 3, 128, 64, 0, 1187, 1188, 3, 124, 62, 0, 1188,
        1191, 1, 0, 0, 0, 1189, 1191, 3, 162, 81, 0, 1190, 1183, 1, 0, 0, 0, 1190, 1189, 1,
        0, 0, 0, 1191, 161, 1, 0, 0, 0, 1192, 1194, 3, 164, 82, 0, 1193, 1192, 1, 0, 0, 0, 1194,
        1197, 1, 0, 0, 0, 1195, 1193, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1198, 1, 0, 0,
        0, 1197, 1195, 1, 0, 0, 0, 1198, 1202, 3, 128, 64, 0, 1199, 1201, 3, 254, 127, 0, 1200,
        1199, 1, 0, 0, 0, 1201, 1204, 1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0, 1202, 1203, 1, 0, 0,
        0, 1203, 1205, 1, 0, 0, 0, 1204, 1202, 1, 0, 0, 0, 1205, 1206, 5, 85, 0, 0, 1206, 1207,
        5, 123, 0, 0, 1207, 163, 1, 0, 0, 0, 1208, 1211, 3, 254, 127, 0, 1209, 1211, 5, 35,
        0, 0, 1210, 1208, 1, 0, 0, 0, 1210, 1209, 1, 0, 0, 0, 1211, 165, 1, 0, 0, 0, 1212, 1213,
        5, 62, 0, 0, 1213, 1214, 3, 168, 84, 0, 1214, 167, 1, 0, 0, 0, 1215, 1220, 3, 170, 85,
        0, 1216, 1217, 5, 83, 0, 0, 1217, 1219, 3, 170, 85, 0, 1218, 1216, 1, 0, 0, 0, 1219,
        1222, 1, 0, 0, 0, 1220, 1218, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 169, 1, 0, 0,
        0, 1222, 1220, 1, 0, 0, 0, 1223, 1226, 3, 22, 11, 0, 1224, 1226, 3, 26, 13, 0, 1225,
        1223, 1, 0, 0, 0, 1225, 1224, 1, 0, 0, 0, 1226, 171, 1, 0, 0, 0, 1227, 1230, 3, 276,
        138, 0, 1228, 1230, 5, 82, 0, 0, 1229, 1227, 1, 0, 0, 0, 1229, 1228, 1, 0, 0, 0, 1230,
        173, 1, 0, 0, 0, 1231, 1232, 3, 276, 138, 0, 1232, 175, 1, 0, 0, 0, 1233, 1234, 5, 55,
        0, 0, 1234, 1235, 3, 276, 138, 0, 1235, 177, 1, 0, 0, 0, 1236, 1238, 3, 180, 90, 0,
        1237, 1236, 1, 0, 0, 0, 1238, 1241, 1, 0, 0, 0, 1239, 1237, 1, 0, 0, 0, 1239, 1240,
        1, 0, 0, 0, 1240, 1242, 1, 0, 0, 0, 1241, 1239, 1, 0, 0, 0, 1242, 1244, 3, 182, 91, 0,
        1243, 1245, 3, 166, 83, 0, 1244, 1243, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 1246,
        1, 0, 0, 0, 1246, 1247, 3, 186, 93, 0, 1247, 179, 1, 0, 0, 0, 1248, 1253, 3, 254, 127,
        0, 1249, 1253, 5, 52, 0, 0, 1250, 1253, 5, 51, 0, 0, 1251, 1253, 5, 50, 0, 0, 1252,
        1248, 1, 0, 0, 0, 1252, 1249, 1, 0, 0, 0, 1252, 1250, 1, 0, 0, 0, 1252, 1251, 1, 0, 0,
        0, 1253, 181, 1, 0, 0, 0, 1254, 1256, 3, 98, 49, 0, 1255, 1254, 1, 0, 0, 0, 1255, 1256,
        1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1258, 3, 184, 92, 0, 1258, 1262, 5, 76, 0,
        0, 1259, 1260, 3, 156, 78, 0, 1260, 1261, 5, 83, 0, 0, 1261, 1263, 1, 0, 0, 0, 1262,
        1259, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1265, 1, 0, 0, 0, 1264, 1266, 3, 158,
        79, 0, 1265, 1264, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267,
        1268, 5, 77, 0, 0, 1268, 183, 1, 0, 0, 0, 1269, 1270, 3, 4, 2, 0, 1270, 185, 1, 0, 0,
        0, 1271, 1273, 5, 78, 0, 0, 1272, 1274, 3, 188, 94, 0, 1273, 1272, 1, 0, 0, 0, 1273,
        1274, 1, 0, 0, 0, 1274, 1276, 1, 0, 0, 0, 1275, 1277, 3, 278, 139, 0, 1276, 1275, 1,
        0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 1279, 5, 79, 0, 0, 1279,
        187, 1, 0, 0, 0, 1280, 1282, 3, 40, 20, 0, 1281, 1280, 1, 0, 0, 0, 1281, 1282, 1, 0,
        0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1284, 7, 4, 0, 0, 1284, 1286, 5, 76, 0, 0, 1285,
        1287, 3, 422, 211, 0, 1286, 1285, 1, 0, 0, 0, 1286, 1287, 1, 0, 0, 0, 1287, 1288, 1,
        0, 0, 0, 1288, 1289, 5, 77, 0, 0, 1289, 1307, 5, 82, 0, 0, 1290, 1293, 3, 58, 29, 0,
        1291, 1293, 3, 390, 195, 0, 1292, 1290, 1, 0, 0, 0, 1292, 1291, 1, 0, 0, 0, 1293, 1294,
        1, 0, 0, 0, 1294, 1296, 5, 84, 0, 0, 1295, 1297, 3, 40, 20, 0, 1296, 1295, 1, 0, 0, 0,
        1296, 1297, 1, 0, 0, 0, 1297, 1298, 1, 0, 0, 0, 1298, 1299, 5, 57, 0, 0, 1299, 1301,
        5, 76, 0, 0, 1300, 1302, 3, 422, 211, 0, 1301, 1300, 1, 0, 0, 0, 1301, 1302, 1, 0, 0,
        0, 1302, 1303, 1, 0, 0, 0, 1303, 1304, 5, 77, 0, 0, 1304, 1305, 5, 82, 0, 0, 1305, 1307,
        1, 0, 0, 0, 1306, 1281, 1, 0, 0, 0, 1306, 1292, 1, 0, 0, 0, 1307, 189, 1, 0, 0, 0, 1308,
        1310, 3, 96, 48, 0, 1309, 1308, 1, 0, 0, 0, 1310, 1313, 1, 0, 0, 0, 1311, 1309, 1, 0,
        0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1314, 1, 0, 0, 0, 1313, 1311, 1, 0, 0, 0, 1314, 1315,
        5, 33, 0, 0, 1315, 1317, 3, 4, 2, 0, 1316, 1318, 3, 104, 52, 0, 1317, 1316, 1, 0, 0,
        0, 1317, 1318, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1320, 3, 192, 96, 0, 1320,
        191, 1, 0, 0, 0, 1321, 1323, 5, 78, 0, 0, 1322, 1324, 3, 194, 97, 0, 1323, 1322, 1,
        0, 0, 0, 1323, 1324, 1, 0, 0, 0, 1324, 1326, 1, 0, 0, 0, 1325, 1327, 5, 83, 0, 0, 1326,
        1325, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1329, 1, 0, 0, 0, 1328, 1330, 3, 200,
        100, 0, 1329, 1328, 1, 0, 0, 0, 1329, 1330, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 1331,
        1332, 5, 79, 0, 0, 1332, 193, 1, 0, 0, 0, 1333, 1338, 3, 196, 98, 0, 1334, 1335, 5,
        83, 0, 0, 1335, 1337, 3, 196, 98, 0, 1336, 1334, 1, 0, 0, 0, 1337, 1340, 1, 0, 0, 0,
        1338, 1336, 1, 0, 0, 0, 1338, 1339, 1, 0, 0, 0, 1339, 195, 1, 0, 0, 0, 1340, 1338, 1,
        0, 0, 0, 1341, 1343, 3, 198, 99, 0, 1342, 1341, 1, 0, 0, 0, 1343, 1346, 1, 0, 0, 0, 1344,
        1342, 1, 0, 0, 0, 1344, 1345, 1, 0, 0, 0, 1345, 1347, 1, 0, 0, 0, 1346, 1344, 1, 0, 0,
        0, 1347, 1353, 5, 123, 0, 0, 1348, 1350, 5, 76, 0, 0, 1349, 1351, 3, 422, 211, 0, 1350,
        1349, 1, 0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1354, 5, 77,
        0, 0, 1353, 1348, 1, 0, 0, 0, 1353, 1354, 1, 0, 0, 0, 1354, 1356, 1, 0, 0, 0, 1355, 1357,
        3, 110, 55, 0, 1356, 1355, 1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 197, 1, 0, 0, 0,
        1358, 1359, 3, 254, 127, 0, 1359, 199, 1, 0, 0, 0, 1360, 1364, 5, 82, 0, 0, 1361, 1363,
        3, 112, 56, 0, 1362, 1361, 1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0,
        1364, 1365, 1, 0, 0, 0, 1365, 201, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1369, 3,
        96, 48, 0, 1368, 1367, 1, 0, 0, 0, 1369, 1372, 1, 0, 0, 0, 1370, 1368, 1, 0, 0, 0, 1370,
        1371, 1, 0, 0, 0, 1371, 1373, 1, 0, 0, 0, 1372, 1370, 1, 0, 0, 0, 1373, 1374, 5, 9, 0,
        0, 1374, 1376, 3, 4, 2, 0, 1375, 1377, 3, 98, 49, 0, 1376, 1375, 1, 0, 0, 0, 1376, 1377,
        1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378, 1380, 3, 204, 102, 0, 1379, 1381, 3, 104,
        52, 0, 1380, 1379, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382,
        1383, 3, 214, 107, 0, 1383, 203, 1, 0, 0, 0, 1384, 1386, 5, 76, 0, 0, 1385, 1387, 3,
        206, 103, 0, 1386, 1385, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0,
        1388, 1389, 5, 77, 0, 0, 1389, 205, 1, 0, 0, 0, 1390, 1395, 3, 208, 104, 0, 1391, 1392,
        5, 83, 0, 0, 1392, 1394, 3, 208, 104, 0, 1393, 1391, 1, 0, 0, 0, 1394, 1397, 1, 0, 0,
        0, 1395, 1393, 1, 0, 0, 0, 1395, 1396, 1, 0, 0, 0, 1396, 207, 1, 0, 0, 0, 1397, 1395,
        1, 0, 0, 0, 1398, 1400, 3, 212, 106, 0, 1399, 1398, 1, 0, 0, 0, 1400, 1403, 1, 0, 0,
        0, 1401, 1399, 1, 0, 0, 0, 1401, 1402, 1, 0, 0, 0, 1402, 1404, 1, 0, 0, 0, 1403, 1401,
        1, 0, 0, 0, 1404, 1405, 3, 128, 64, 0, 1405, 1406, 5, 123, 0, 0, 1406, 1409, 1, 0, 0,
        0, 1407, 1409, 3, 210, 105, 0, 1408, 1401, 1, 0, 0, 0, 1408, 1407, 1, 0, 0, 0, 1409,
        209, 1, 0, 0, 0, 1410, 1412, 3, 212, 106, 0, 1411, 1410, 1, 0, 0, 0, 1412, 1415, 1,
        0, 0, 0, 1413, 1411, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1416, 1, 0, 0, 0, 1415,
        1413, 1, 0, 0, 0, 1416, 1420, 3, 128, 64, 0, 1417, 1419, 3, 254, 127, 0, 1418, 1417,
        1, 0, 0, 0, 1419, 1422, 1, 0, 0, 0, 1420, 1418, 1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421,
        1423, 1, 0, 0, 0, 1422, 1420, 1, 0, 0, 0, 1423, 1424, 5, 85, 0, 0, 1424, 1425, 5, 123,
        0, 0, 1425, 211, 1, 0, 0, 0, 1426, 1427, 3, 254, 127, 0, 1427, 213, 1, 0, 0, 0, 1428,
        1432, 5, 78, 0, 0, 1429, 1431, 3, 216, 108, 0, 1430, 1429, 1, 0, 0, 0, 1431, 1434,
        1, 0, 0, 0, 1432, 1430, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1435, 1, 0, 0, 0, 1434,
        1432, 1, 0, 0, 0, 1435, 1436, 5, 79, 0, 0, 1436, 215, 1, 0, 0, 0, 1437, 1440, 3, 112,
        56, 0, 1438, 1440, 3, 218, 109, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1438, 1, 0, 0, 0, 1440,
        217, 1, 0, 0, 0, 1441, 1443, 3, 180, 90, 0, 1442, 1441, 1, 0, 0, 0, 1443, 1446, 1, 0,
        0, 0, 1444, 1442, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445, 1447, 1, 0, 0, 0, 1446, 1444,
        1, 0, 0, 0, 1447, 1448, 3, 184, 92, 0, 1448, 1449, 3, 186, 93, 0, 1449, 219, 1, 0, 0,
        0, 1450, 1453, 3, 222, 111, 0, 1451, 1453, 3, 242, 121, 0, 1452, 1450, 1, 0, 0, 0,
        1452, 1451, 1, 0, 0, 0, 1453, 221, 1, 0, 0, 0, 1454, 1456, 3, 224, 112, 0, 1455, 1454,
        1, 0, 0, 0, 1456, 1459, 1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458,
        1460, 1, 0, 0, 0, 1459, 1457, 1, 0, 0, 0, 1460, 1461, 5, 45, 0, 0, 1461, 1463, 3, 4,
        2, 0, 1462, 1464, 3, 98, 49, 0, 1463, 1462, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464,
        1466, 1, 0, 0, 0, 1465, 1467, 3, 226, 113, 0, 1466, 1465, 1, 0, 0, 0, 1466, 1467, 1,
        0, 0, 0, 1467, 1469, 1, 0, 0, 0, 1468, 1470, 3, 228, 114, 0, 1469, 1468, 1, 0, 0, 0,
        1469, 1470, 1, 0, 0, 0, 1470, 1471, 1, 0, 0, 0, 1471, 1472, 3, 230, 115, 0, 1472, 223,
        1, 0, 0, 0, 1473, 1483, 3, 254, 127, 0, 1474, 1483, 5, 52, 0, 0, 1475, 1483, 5, 51,
        0, 0, 1476, 1483, 5, 50, 0, 0, 1477, 1483, 5, 18, 0, 0, 1478, 1483, 5, 55, 0, 0, 1479,
        1483, 5, 11, 0, 0, 1480, 1483, 5, 3, 0, 0, 1481, 1483, 5, 56, 0, 0, 1482, 1473, 1, 0,
        0, 0, 1482, 1474, 1, 0, 0, 0, 1482, 1475, 1, 0, 0, 0, 1482, 1476, 1, 0, 0, 0, 1482, 1477,
        1, 0, 0, 0, 1482, 1478, 1, 0, 0, 0, 1482, 1479, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482,
        1481, 1, 0, 0, 0, 1483, 225, 1, 0, 0, 0, 1484, 1485, 5, 34, 0, 0, 1485, 1486, 3, 106,
        53, 0, 1486, 227, 1, 0, 0, 0, 1487, 1488, 5, 7, 0, 0, 1488, 1493, 3, 54, 27, 0, 1489,
        1490, 5, 83, 0, 0, 1490, 1492, 3, 54, 27, 0, 1491, 1489, 1, 0, 0, 0, 1492, 1495, 1,
        0, 0, 0, 1493, 1491, 1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 229, 1, 0, 0, 0, 1495,
        1493, 1, 0, 0, 0, 1496, 1500, 5, 78, 0, 0, 1497, 1499, 3, 232, 116, 0, 1498, 1497,
        1, 0, 0, 0, 1499, 1502, 1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501,
        1503, 1, 0, 0, 0, 1502, 1500, 1, 0, 0, 0, 1503, 1504, 5, 79, 0, 0, 1504, 231, 1, 0, 0,
        0, 1505, 1511, 3, 234, 117, 0, 1506, 1511, 3, 238, 119, 0, 1507, 1511, 3, 92, 46,
        0, 1508, 1511, 3, 220, 110, 0, 1509, 1511, 5, 82, 0, 0, 1510, 1505, 1, 0, 0, 0, 1510,
        1506, 1, 0, 0, 0, 1510, 1507, 1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1510, 1509, 1, 0, 0,
        0, 1511, 233, 1, 0, 0, 0, 1512, 1514, 3, 236, 118, 0, 1513, 1512, 1, 0, 0, 0, 1514,
        1517, 1, 0, 0, 0, 1515, 1513, 1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516, 1518, 1, 0, 0,
        0, 1517, 1515, 1, 0, 0, 0, 1518, 1519, 3, 128, 64, 0, 1519, 1520, 3, 120, 60, 0, 1520,
        1521, 5, 82, 0, 0, 1521, 235, 1, 0, 0, 0, 1522, 1527, 3, 254, 127, 0, 1523, 1527, 5,
        52, 0, 0, 1524, 1527, 5, 55, 0, 0, 1525, 1527, 5, 35, 0, 0, 1526, 1522, 1, 0, 0, 0, 1526,
        1523, 1, 0, 0, 0, 1526, 1524, 1, 0, 0, 0, 1526, 1525, 1, 0, 0, 0, 1527, 237, 1, 0, 0,
        0, 1528, 1530, 3, 240, 120, 0, 1529, 1528, 1, 0, 0, 0, 1530, 1533, 1, 0, 0, 0, 1531,
        1529, 1, 0, 0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1534, 1, 0, 0, 0, 1533, 1531, 1, 0, 0,
        0, 1534, 1535, 3, 150, 75, 0, 1535, 1536, 3, 172, 86, 0, 1536, 239, 1, 0, 0, 0, 1537,
        1545, 3, 254, 127, 0, 1538, 1545, 5, 52, 0, 0, 1539, 1545, 5, 50, 0, 0, 1540, 1545,
        5, 18, 0, 0, 1541, 1545, 5, 29, 0, 0, 1542, 1545, 5, 55, 0, 0, 1543, 1545, 5, 56, 0,
        0, 1544, 1537, 1, 0, 0, 0, 1544, 1538, 1, 0, 0, 0, 1544, 1539, 1, 0, 0, 0, 1544, 1540,
        1, 0, 0, 0, 1544, 1541, 1, 0, 0, 0, 1544, 1542, 1, 0, 0, 0, 1544, 1543, 1, 0, 0, 0, 1545,
        241, 1, 0, 0, 0, 1546, 1548, 3, 224, 112, 0, 1547, 1546, 1, 0, 0, 0, 1548, 1551, 1,
        0, 0, 0, 1549, 1547, 1, 0, 0, 0, 1549, 1550, 1, 0, 0, 0, 1550, 1552, 1, 0, 0, 0, 1551,
        1549, 1, 0, 0, 0, 1552, 1553, 5, 86, 0, 0, 1553, 1554, 5, 45, 0, 0, 1554, 1555, 3, 4,
        2, 0, 1555, 1556, 3, 244, 122, 0, 1556, 243, 1, 0, 0, 0, 1557, 1561, 5, 78, 0, 0, 1558,
        1560, 3, 246, 123, 0, 1559, 1558, 1, 0, 0, 0, 1560, 1563, 1, 0, 0, 0, 1561, 1559, 1,
        0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1564, 1, 0, 0, 0, 1563, 1561, 1, 0, 0, 0, 1564,
        1565, 5, 79, 0, 0, 1565, 245, 1, 0, 0, 0, 1566, 1572, 3, 248, 124, 0, 1567, 1572, 3,
        234, 117, 0, 1568, 1572, 3, 92, 46, 0, 1569, 1572, 3, 220, 110, 0, 1570, 1572, 5,
        82, 0, 0, 1571, 1566, 1, 0, 0, 0, 1571, 1567, 1, 0, 0, 0, 1571, 1568, 1, 0, 0, 0, 1571,
        1569, 1, 0, 0, 0, 1571, 1570, 1, 0, 0, 0, 1572, 247, 1, 0, 0, 0, 1573, 1575, 3, 250,
        125, 0, 1574, 1573, 1, 0, 0, 0, 1575, 1578, 1, 0, 0, 0, 1576, 1574, 1, 0, 0, 0, 1576,
        1577, 1, 0, 0, 0, 1577, 1579, 1, 0, 0, 0, 1578, 1576, 1, 0, 0, 0, 1579, 1580, 3, 128,
        64, 0, 1580, 1581, 5, 123, 0, 0, 1581, 1582, 5, 76, 0, 0, 1582, 1584, 5, 77, 0, 0, 1583,
        1585, 3, 30, 15, 0, 1584, 1583, 1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 1587, 1, 0,
        0, 0, 1586, 1588, 3, 252, 126, 0, 1587, 1586, 1, 0, 0, 0, 1587, 1588, 1, 0, 0, 0, 1588,
        1589, 1, 0, 0, 0, 1589, 1590, 5, 82, 0, 0, 1590, 249, 1, 0, 0, 0, 1591, 1595, 3, 254,
        127, 0, 1592, 1595, 5, 52, 0, 0, 1593, 1595, 5, 18, 0, 0, 1594, 1591, 1, 0, 0, 0, 1594,
        1592, 1, 0, 0, 0, 1594, 1593, 1, 0, 0, 0, 1595, 251, 1, 0, 0, 0, 1596, 1597, 5, 29, 0,
        0, 1597, 1598, 3, 262, 131, 0, 1598, 253, 1, 0, 0, 0, 1599, 1603, 3, 256, 128, 0, 1600,
        1603, 3, 268, 134, 0, 1601, 1603, 3, 270, 135, 0, 1602, 1599, 1, 0, 0, 0, 1602, 1600,
        1, 0, 0, 0, 1602, 1601, 1, 0, 0, 0, 1603, 255, 1, 0, 0, 0, 1604, 1605, 5, 86, 0, 0, 1605,
        1606, 3, 54, 27, 0, 1606, 1608, 5, 76, 0, 0, 1607, 1609, 3, 258, 129, 0, 1608, 1607,
        1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 1611, 5, 77, 0, 0, 1611,
        257, 1, 0, 0, 0, 1612, 1617, 3, 260, 130, 0, 1613, 1614, 5, 83, 0, 0, 1614, 1616, 3,
        260, 130, 0, 1615, 1613, 1, 0, 0, 0, 1616, 1619, 1, 0, 0, 0, 1617, 1615, 1, 0, 0, 0,
        1617, 1618, 1, 0, 0, 0, 1618, 259, 1, 0, 0, 0, 1619, 1617, 1, 0, 0, 0, 1620, 1621, 5,
        123, 0, 0, 1621, 1622, 5, 88, 0, 0, 1622, 1623, 3, 262, 131, 0, 1623, 261, 1, 0, 0,
        0, 1624, 1628, 3, 464, 232, 0, 1625, 1628, 3, 264, 132, 0, 1626, 1628, 3, 254, 127,
        0, 1627, 1624, 1, 0, 0, 0, 1627, 1625, 1, 0, 0, 0, 1627, 1626, 1, 0, 0, 0, 1628, 263,
        1, 0, 0, 0, 1629, 1631, 5, 78, 0, 0, 1630, 1632, 3, 266, 133, 0, 1631, 1630, 1, 0, 0,
        0, 1631, 1632, 1, 0, 0, 0, 1632, 1634, 1, 0, 0, 0, 1633, 1635, 5, 83, 0, 0, 1634, 1633,
        1, 0, 0, 0, 1634, 1635, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1637, 5, 79, 0, 0, 1637,
        265, 1, 0, 0, 0, 1638, 1643, 3, 262, 131, 0, 1639, 1640, 5, 83, 0, 0, 1640, 1642, 3,
        262, 131, 0, 1641, 1639, 1, 0, 0, 0, 1642, 1645, 1, 0, 0, 0, 1643, 1641, 1, 0, 0, 0,
        1643, 1644, 1, 0, 0, 0, 1644, 267, 1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1646, 1647, 5,
        86, 0, 0, 1647, 1648, 3, 54, 27, 0, 1648, 269, 1, 0, 0, 0, 1649, 1650, 5, 86, 0, 0, 1650,
        1651, 3, 54, 27, 0, 1651, 1652, 5, 76, 0, 0, 1652, 1653, 3, 262, 131, 0, 1653, 1654,
        5, 77, 0, 0, 1654, 271, 1, 0, 0, 0, 1655, 1657, 5, 78, 0, 0, 1656, 1658, 3, 274, 137,
        0, 1657, 1656, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1660, 1, 0, 0, 0, 1659, 1661,
        5, 83, 0, 0, 1660, 1659, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662,
        1663, 5, 79, 0, 0, 1663, 273, 1, 0, 0, 0, 1664, 1669, 3, 126, 63, 0, 1665, 1666, 5,
        83, 0, 0, 1666, 1668, 3, 126, 63, 0, 1667, 1665, 1, 0, 0, 0, 1668, 1671, 1, 0, 0, 0,
        1669, 1667, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 275, 1, 0, 0, 0, 1671, 1669, 1,
        0, 0, 0, 1672, 1674, 5, 78, 0, 0, 1673, 1675, 3, 278, 139, 0, 1674, 1673, 1, 0, 0, 0,
        1674, 1675, 1, 0, 0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1677, 5, 79, 0, 0, 1677, 277,
        1, 0, 0, 0, 1678, 1682, 3, 280, 140, 0, 1679, 1681, 3, 280, 140, 0, 1680, 1679, 1,
        0, 0, 0, 1681, 1684, 1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683,
        279, 1, 0, 0, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1689, 3, 282, 141, 0, 1686, 1689, 3,
        288, 144, 0, 1687, 1689, 3, 290, 145, 0, 1688, 1685, 1, 0, 0, 0, 1688, 1686, 1, 0,
        0, 0, 1688, 1687, 1, 0, 0, 0, 1689, 281, 1, 0, 0, 0, 1690, 1693, 3, 92, 46, 0, 1691,
        1693, 3, 222, 111, 0, 1692, 1690, 1, 0, 0, 0, 1692, 1691, 1, 0, 0, 0, 1693, 283, 1,
        0, 0, 0, 1694, 1696, 3, 164, 82, 0, 1695, 1694, 1, 0, 0, 0, 1696, 1699, 1, 0, 0, 0, 1697,
        1695, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1700, 1, 0, 0, 0, 1699, 1697, 1, 0, 0,
        0, 1700, 1702, 3, 286, 143, 0, 1701, 1703, 3, 120, 60, 0, 1702, 1701, 1, 0, 0, 0, 1702,
        1703, 1, 0, 0, 0, 1703, 285, 1, 0, 0, 0, 1704, 1707, 3, 128, 64, 0, 1705, 1707, 5, 15,
        0, 0, 1706, 1704, 1, 0, 0, 0, 1706, 1705, 1, 0, 0, 0, 1707, 287, 1, 0, 0, 0, 1708, 1709,
        3, 284, 142, 0, 1709, 1710, 5, 82, 0, 0, 1710, 289, 1, 0, 0, 0, 1711, 1718, 3, 294,
        147, 0, 1712, 1718, 3, 298, 149, 0, 1713, 1718, 3, 306, 153, 0, 1714, 1718, 3, 308,
        154, 0, 1715, 1718, 3, 326, 163, 0, 1716, 1718, 3, 332, 166, 0, 1717, 1711, 1, 0,
        0, 0, 1717, 1712, 1, 0, 0, 0, 1717, 1713, 1, 0, 0, 0, 1717, 1714, 1, 0, 0, 0, 1717, 1715,
        1, 0, 0, 0, 1717, 1716, 1, 0, 0, 0, 1718, 291, 1, 0, 0, 0, 1719, 1725, 3, 294, 147, 0,
        1720, 1725, 3, 300, 150, 0, 1721, 1725, 3, 310, 155, 0, 1722, 1725, 3, 328, 164,
        0, 1723, 1725, 3, 334, 167, 0, 1724, 1719, 1, 0, 0, 0, 1724, 1720, 1, 0, 0, 0, 1724,
        1721, 1, 0, 0, 0, 1724, 1722, 1, 0, 0, 0, 1724, 1723, 1, 0, 0, 0, 1725, 293, 1, 0, 0,
        0, 1726, 1740, 3, 276, 138, 0, 1727, 1740, 3, 296, 148, 0, 1728, 1740, 3, 302, 151,
        0, 1729, 1740, 3, 312, 156, 0, 1730, 1740, 3, 314, 157, 0, 1731, 1740, 3, 330, 165,
        0, 1732, 1740, 3, 350, 175, 0, 1733, 1740, 3, 352, 176, 0, 1734, 1740, 3, 354, 177,
        0, 1735, 1740, 3, 358, 179, 0, 1736, 1740, 3, 356, 178, 0, 1737, 1740, 3, 360, 180,
        0, 1738, 1740, 3, 382, 191, 0, 1739, 1726, 1, 0, 0, 0, 1739, 1727, 1, 0, 0, 0, 1739,
        1728, 1, 0, 0, 0, 1739, 1729, 1, 0, 0, 0, 1739, 1730, 1, 0, 0, 0, 1739, 1731, 1, 0, 0,
        0, 1739, 1732, 1, 0, 0, 0, 1739, 1733, 1, 0, 0, 0, 1739, 1734, 1, 0, 0, 0, 1739, 1735,
        1, 0, 0, 0, 1739, 1736, 1, 0, 0, 0, 1739, 1737, 1, 0, 0, 0, 1739, 1738, 1, 0, 0, 0, 1740,
        295, 1, 0, 0, 0, 1741, 1742, 5, 82, 0, 0, 1742, 297, 1, 0, 0, 0, 1743, 1744, 5, 123,
        0, 0, 1744, 1745, 5, 94, 0, 0, 1745, 1746, 3, 290, 145, 0, 1746, 299, 1, 0, 0, 0, 1747,
        1748, 5, 123, 0, 0, 1748, 1749, 5, 94, 0, 0, 1749, 1750, 3, 292, 146, 0, 1750, 301,
        1, 0, 0, 0, 1751, 1752, 3, 304, 152, 0, 1752, 1753, 5, 82, 0, 0, 1753, 303, 1, 0, 0,
        0, 1754, 1762, 3, 468, 234, 0, 1755, 1762, 3, 436, 218, 0, 1756, 1762, 3, 438, 219,
        0, 1757, 1762, 3, 430, 215, 0, 1758, 1762, 3, 432, 216, 0, 1759, 1762, 3, 420, 210,
        0, 1760, 1762, 3, 398, 199, 0, 1761, 1754, 1, 0, 0, 0, 1761, 1755, 1, 0, 0, 0, 1761,
        1756, 1, 0, 0, 0, 1761, 1757, 1, 0, 0, 0, 1761, 1758, 1, 0, 0, 0, 1761, 1759, 1, 0, 0,
        0, 1761, 1760, 1, 0, 0, 0, 1762, 305, 1, 0, 0, 0, 1763, 1764, 5, 39, 0, 0, 1764, 1765,
        5, 76, 0, 0, 1765, 1766, 3, 388, 194, 0, 1766, 1767, 5, 77, 0, 0, 1767, 1768, 3, 290,
        145, 0, 1768, 307, 1, 0, 0, 0, 1769, 1770, 5, 39, 0, 0, 1770, 1771, 5, 76, 0, 0, 1771,
        1772, 3, 388, 194, 0, 1772, 1773, 5, 77, 0, 0, 1773, 1774, 3, 292, 146, 0, 1774, 1775,
        5, 32, 0, 0, 1775, 1776, 3, 290, 145, 0, 1776, 309, 1, 0, 0, 0, 1777, 1778, 5, 39, 0,
        0, 1778, 1779, 5, 76, 0, 0, 1779, 1780, 3, 388, 194, 0, 1780, 1781, 5, 77, 0, 0, 1781,
        1782, 3, 292, 146, 0, 1782, 1783, 5, 32, 0, 0, 1783, 1784, 3, 292, 146, 0, 1784, 311,
        1, 0, 0, 0, 1785, 1786, 5, 19, 0, 0, 1786, 1789, 3, 388, 194, 0, 1787, 1788, 5, 94,
        0, 0, 1788, 1790, 3, 388, 194, 0, 1789, 1787, 1, 0, 0, 0, 1789, 1790, 1, 0, 0, 0, 1790,
        1791, 1, 0, 0, 0, 1791, 1792, 5, 82, 0, 0, 1792, 313, 1, 0, 0, 0, 1793, 1794, 5, 58,
        0, 0, 1794, 1795, 5, 76, 0, 0, 1795, 1796, 3, 388, 194, 0, 1796, 1797, 5, 77, 0, 0,
        1797, 1798, 3, 316, 158, 0, 1798, 315, 1, 0, 0, 0, 1799, 1800, 5, 78, 0, 0, 1800, 1804,
        3, 318, 159, 0, 1801, 1803, 3, 318, 159, 0, 1802, 1801, 1, 0, 0, 0, 1803, 1806, 1,
        0, 0, 0, 1804, 1802, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1807, 1, 0, 0, 0, 1806,
        1804, 1, 0, 0, 0, 1807, 1808, 5, 79, 0, 0, 1808, 1826, 1, 0, 0, 0, 1809, 1813, 5, 78,
        0, 0, 1810, 1812, 3, 320, 160, 0, 1811, 1810, 1, 0, 0, 0, 1812, 1815, 1, 0, 0, 0, 1813,
        1811, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1821, 1, 0, 0, 0, 1815, 1813, 1, 0, 0,
        0, 1816, 1817, 3, 322, 161, 0, 1817, 1818, 5, 94, 0, 0, 1818, 1820, 1, 0, 0, 0, 1819,
        1816, 1, 0, 0, 0, 1820, 1823, 1, 0, 0, 0, 1821, 1819, 1, 0, 0, 0, 1821, 1822, 1, 0, 0,
        0, 1822, 1824, 1, 0, 0, 0, 1823, 1821, 1, 0, 0, 0, 1824, 1826, 5, 79, 0, 0, 1825, 1799,
        1, 0, 0, 0, 1825, 1809, 1, 0, 0, 0, 1826, 317, 1, 0, 0, 0, 1827, 1828, 3, 322, 161, 0,
        1828, 1834, 5, 95, 0, 0, 1829, 1830, 3, 388, 194, 0, 1830, 1831, 5, 82, 0, 0, 1831,
        1835, 1, 0, 0, 0, 1832, 1835, 3, 276, 138, 0, 1833, 1835, 3, 356, 178, 0, 1834, 1829,
        1, 0, 0, 0, 1834, 1832, 1, 0, 0, 0, 1834, 1833, 1, 0, 0, 0, 1835, 319, 1, 0, 0, 0, 1836,
        1837, 3, 322, 161, 0, 1837, 1843, 5, 94, 0, 0, 1838, 1839, 3, 322, 161, 0, 1839, 1840,
        5, 94, 0, 0, 1840, 1842, 1, 0, 0, 0, 1841, 1838, 1, 0, 0, 0, 1842, 1845, 1, 0, 0, 0, 1843,
        1841, 1, 0, 0, 0, 1843, 1844, 1, 0, 0, 0, 1844, 1846, 1, 0, 0, 0, 1845, 1843, 1, 0, 0,
        0, 1846, 1847, 3, 278, 139, 0, 1847, 321, 1, 0, 0, 0, 1848, 1849, 5, 23, 0, 0, 1849,
        1854, 3, 324, 162, 0, 1850, 1851, 5, 83, 0, 0, 1851, 1853, 3, 324, 162, 0, 1852, 1850,
        1, 0, 0, 0, 1853, 1856, 1, 0, 0, 0, 1854, 1852, 1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855,
        1859, 1, 0, 0, 0, 1856, 1854, 1, 0, 0, 0, 1857, 1859, 5, 29, 0, 0, 1858, 1848, 1, 0,
        0, 0, 1858, 1857, 1, 0, 0, 0, 1859, 323, 1, 0, 0, 0, 1860, 1861, 3, 464, 232, 0, 1861,
        325, 1, 0, 0, 0, 1862, 1863, 5, 67, 0, 0, 1863, 1864, 5, 76, 0, 0, 1864, 1865, 3, 388,
        194, 0, 1865, 1866, 5, 77, 0, 0, 1866, 1867, 3, 290, 145, 0, 1867, 327, 1, 0, 0, 0,
        1868, 1869, 5, 67, 0, 0, 1869, 1870, 5, 76, 0, 0, 1870, 1871, 3, 388, 194, 0, 1871,
        1872, 5, 77, 0, 0, 1872, 1873, 3, 292, 146, 0, 1873, 329, 1, 0, 0, 0, 1874, 1875, 5,
        30, 0, 0, 1875, 1876, 3, 290, 145, 0, 1876, 1877, 5, 67, 0, 0, 1877, 1878, 5, 76, 0,
        0, 1878, 1879, 3, 388, 194, 0, 1879, 1880, 5, 77, 0, 0, 1880, 1881, 5, 82, 0, 0, 1881,
        331, 1, 0, 0, 0, 1882, 1885, 3, 336, 168, 0, 1883, 1885, 3, 346, 173, 0, 1884, 1882,
        1, 0, 0, 0, 1884, 1883, 1, 0, 0, 0, 1885, 333, 1, 0, 0, 0, 1886, 1889, 3, 338, 169, 0,
        1887, 1889, 3, 348, 174, 0, 1888, 1886, 1, 0, 0, 0, 1888, 1887, 1, 0, 0, 0, 1889, 335,
        1, 0, 0, 0, 1890, 1891, 5, 38, 0, 0, 1891, 1893, 5, 76, 0, 0, 1892, 1894, 3, 340, 170,
        0, 1893, 1892, 1, 0, 0, 0, 1893, 1894, 1, 0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1897,
        5, 82, 0, 0, 1896, 1898, 3, 388, 194, 0, 1897, 1896, 1, 0, 0, 0, 1897, 1898, 1, 0, 0,
        0, 1898, 1899, 1, 0, 0, 0, 1899, 1901, 5, 82, 0, 0, 1900, 1902, 3, 342, 171, 0, 1901,
        1900, 1, 0, 0, 0, 1901, 1902, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0, 1903, 1904, 5, 77,
        0, 0, 1904, 1905, 3, 290, 145, 0, 1905, 337, 1, 0, 0, 0, 1906, 1907, 5, 38, 0, 0, 1907,
        1909, 5, 76, 0, 0, 1908, 1910, 3, 340, 170, 0, 1909, 1908, 1, 0, 0, 0, 1909, 1910,
        1, 0, 0, 0, 1910, 1911, 1, 0, 0, 0, 1911, 1913, 5, 82, 0, 0, 1912, 1914, 3, 388, 194,
        0, 1913, 1912, 1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 1915, 1, 0, 0, 0, 1915, 1917,
        5, 82, 0, 0, 1916, 1918, 3, 342, 171, 0, 1917, 1916, 1, 0, 0, 0, 1917, 1918, 1, 0, 0,
        0, 1918, 1919, 1, 0, 0, 0, 1919, 1920, 5, 77, 0, 0, 1920, 1921, 3, 292, 146, 0, 1921,
        339, 1, 0, 0, 0, 1922, 1925, 3, 344, 172, 0, 1923, 1925, 3, 284, 142, 0, 1924, 1922,
        1, 0, 0, 0, 1924, 1923, 1, 0, 0, 0, 1925, 341, 1, 0, 0, 0, 1926, 1927, 3, 344, 172, 0,
        1927, 343, 1, 0, 0, 0, 1928, 1933, 3, 304, 152, 0, 1929, 1930, 5, 83, 0, 0, 1930, 1932,
        3, 304, 152, 0, 1931, 1929, 1, 0, 0, 0, 1932, 1935, 1, 0, 0, 0, 1933, 1931, 1, 0, 0,
        0, 1933, 1934, 1, 0, 0, 0, 1934, 345, 1, 0, 0, 0, 1935, 1933, 1, 0, 0, 0, 1936, 1937,
        5, 38, 0, 0, 1937, 1938, 5, 76, 0, 0, 1938, 1939, 3, 284, 142, 0, 1939, 1940, 5, 94,
        0, 0, 1940, 1941, 3, 388, 194, 0, 1941, 1942, 5, 77, 0, 0, 1942, 1943, 3, 290, 145,
        0, 1943, 347, 1, 0, 0, 0, 1944, 1945, 5, 38, 0, 0, 1945, 1946, 5, 76, 0, 0, 1946, 1947,
        3, 284, 142, 0, 1947, 1948, 5, 94, 0, 0, 1948, 1949, 3, 388, 194, 0, 1949, 1950, 5,
        77, 0, 0, 1950, 1951, 3, 292, 146, 0, 1951, 349, 1, 0, 0, 0, 1952, 1954, 5, 21, 0, 0,
        1953, 1955, 5, 123, 0, 0, 1954, 1953, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 1956,
        1, 0, 0, 0, 1956, 1957, 5, 82, 0, 0, 1957, 351, 1, 0, 0, 0, 1958, 1960, 5, 28, 0, 0, 1959,
        1961, 5, 123, 0, 0, 1960, 1959, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1962, 1, 0,
        0, 0, 1962, 1963, 5, 82, 0, 0, 1963, 353, 1, 0, 0, 0, 1964, 1966, 5, 53, 0, 0, 1965,
        1967, 3, 388, 194, 0, 1966, 1965, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1968, 1,
        0, 0, 0, 1968, 1969, 5, 82, 0, 0, 1969, 355, 1, 0, 0, 0, 1970, 1971, 5, 61, 0, 0, 1971,
        1972, 3, 388, 194, 0, 1972, 1973, 5, 82, 0, 0, 1973, 357, 1, 0, 0, 0, 1974, 1975, 5,
        59, 0, 0, 1975, 1976, 5, 76, 0, 0, 1976, 1977, 3, 388, 194, 0, 1977, 1978, 5, 77, 0,
        0, 1978, 1979, 3, 276, 138, 0, 1979, 359, 1, 0, 0, 0, 1980, 1981, 5, 64, 0, 0, 1981,
        1982, 3, 276, 138, 0, 1982, 1983, 3, 362, 181, 0, 1983, 1997, 1, 0, 0, 0, 1984, 1985,
        5, 64, 0, 0, 1985, 1986, 3, 276, 138, 0, 1986, 1987, 3, 370, 185, 0, 1987, 1997, 1,
        0, 0, 0, 1988, 1989, 5, 64, 0, 0, 1989, 1991, 3, 276, 138, 0, 1990, 1992, 3, 362, 181,
        0, 1991, 1990, 1, 0, 0, 0, 1991, 1992, 1, 0, 0, 0, 1992, 1993, 1, 0, 0, 0, 1993, 1994,
        3, 370, 185, 0, 1994, 1997, 1, 0, 0, 0, 1995, 1997, 3, 372, 186, 0, 1996, 1980, 1,
        0, 0, 0, 1996, 1984, 1, 0, 0, 0, 1996, 1988, 1, 0, 0, 0, 1996, 1995, 1, 0, 0, 0, 1997,
        361, 1, 0, 0, 0, 1998, 2002, 3, 364, 182, 0, 1999, 2001, 3, 364, 182, 0, 2000, 1999,
        1, 0, 0, 0, 2001, 2004, 1, 0, 0, 0, 2002, 2000, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003,
        363, 1, 0, 0, 0, 2004, 2002, 1, 0, 0, 0, 2005, 2006, 5, 24, 0, 0, 2006, 2007, 5, 76,
        0, 0, 2007, 2008, 3, 366, 183, 0, 2008, 2009, 5, 77, 0, 0, 2009, 2010, 3, 276, 138,
        0, 2010, 365, 1, 0, 0, 0, 2011, 2013, 3, 164, 82, 0, 2012, 2011, 1, 0, 0, 0, 2013, 2016,
        1, 0, 0, 0, 2014, 2012, 1, 0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015, 2017, 1, 0, 0, 0, 2016,
        2014, 1, 0, 0, 0, 2017, 2018, 3, 368, 184, 0, 2018, 2019, 3, 124, 62, 0, 2019, 367,
        1, 0, 0, 0, 2020, 2025, 3, 138, 69, 0, 2021, 2022, 5, 109, 0, 0, 2022, 2024, 3, 22,
        11, 0, 2023, 2021, 1, 0, 0, 0, 2024, 2027, 1, 0, 0, 0, 2025, 2023, 1, 0, 0, 0, 2025,
        2026, 1, 0, 0, 0, 2026, 369, 1, 0, 0, 0, 2027, 2025, 1, 0, 0, 0, 2028, 2029, 5, 36, 0,
        0, 2029, 2030, 3, 276, 138, 0, 2030, 371, 1, 0, 0, 0, 2031, 2032, 5, 64, 0, 0, 2032,
        2033, 3, 374, 187, 0, 2033, 2035, 3, 276, 138, 0, 2034, 2036, 3, 362, 181, 0, 2035,
        2034, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2038, 1, 0, 0, 0, 2037, 2039, 3, 370,
        185, 0, 2038, 2037, 1, 0, 0, 0, 2038, 2039, 1, 0, 0, 0, 2039, 373, 1, 0, 0, 0, 2040,
        2041, 5, 76, 0, 0, 2041, 2043, 3, 376, 188, 0, 2042, 2044, 5, 82, 0, 0, 2043, 2042,
        1, 0, 0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2046, 5, 77, 0, 0, 2046,
        375, 1, 0, 0, 0, 2047, 2052, 3, 378, 189, 0, 2048, 2049, 5, 82, 0, 0, 2049, 2051, 3,
        378, 189, 0, 2050, 2048, 1, 0, 0, 0, 2051, 2054, 1, 0, 0, 0, 2052, 2050, 1, 0, 0, 0,
        2052, 2053, 1, 0, 0, 0, 2053, 377, 1, 0, 0, 0, 2054, 2052, 1, 0, 0, 0, 2055, 2058, 3,
        284, 142, 0, 2056, 2058, 3, 380, 190, 0, 2057, 2055, 1, 0, 0, 0, 2057, 2056, 1, 0,
        0, 0, 2058, 379, 1, 0, 0, 0, 2059, 2062, 3, 58, 29, 0, 2060, 2062, 3, 418, 209, 0, 2061,
        2059, 1, 0, 0, 0, 2061, 2060, 1, 0, 0, 0, 2062, 381, 1, 0, 0, 0, 2063, 2064, 5, 17, 0,
        0, 2064, 2065, 3, 388, 194, 0, 2065, 2066, 5, 82, 0, 0, 2066, 383, 1, 0, 0, 0, 2067,
        2068, 3, 386, 193, 0, 2068, 385, 1, 0, 0, 0, 2069, 2070, 3, 284, 142, 0, 2070, 387,
        1, 0, 0, 0, 2071, 2074, 3, 474, 237, 0, 2072, 2074, 3, 466, 233, 0, 2073, 2071, 1,
        0, 0, 0, 2073, 2072, 1, 0, 0, 0, 2074, 389, 1, 0, 0, 0, 2075, 2078, 3, 392, 196, 0, 2076,
        2078, 3, 406, 203, 0, 2077, 2075, 1, 0, 0, 0, 2077, 2076, 1, 0, 0, 0, 2078, 391, 1,
        0, 0, 0, 2079, 2081, 3, 2, 1, 0, 2080, 2082, 3, 394, 197, 0, 2081, 2080, 1, 0, 0, 0,
        2081, 2082, 1, 0, 0, 0, 2082, 2297, 1, 0, 0, 0, 2083, 2085, 3, 396, 198, 0, 2084, 2086,
        3, 394, 197, 0, 2085, 2084, 1, 0, 0, 0, 2085, 2086, 1, 0, 0, 0, 2086, 2297, 1, 0, 0,
        0, 2087, 2089, 5, 60, 0, 0, 2088, 2090, 3, 394, 197, 0, 2089, 2088, 1, 0, 0, 0, 2089,
        2090, 1, 0, 0, 0, 2090, 2297, 1, 0, 0, 0, 2091, 2092, 3, 54, 27, 0, 2092, 2093, 5, 84,
        0, 0, 2093, 2095, 5, 60, 0, 0, 2094, 2096, 3, 394, 197, 0, 2095, 2094, 1, 0, 0, 0, 2095,
        2096, 1, 0, 0, 0, 2096, 2297, 1, 0, 0, 0, 2097, 2098, 5, 76, 0, 0, 2098, 2099, 3, 388,
        194, 0, 2099, 2101, 5, 77, 0, 0, 2100, 2102, 3, 394, 197, 0, 2101, 2100, 1, 0, 0, 0,
        2101, 2102, 1, 0, 0, 0, 2102, 2297, 1, 0, 0, 0, 2103, 2105, 3, 400, 200, 0, 2104, 2106,
        3, 394, 197, 0, 2105, 2104, 1, 0, 0, 0, 2105, 2106, 1, 0, 0, 0, 2106, 2297, 1, 0, 0,
        0, 2107, 2108, 3, 58, 29, 0, 2108, 2109, 5, 84, 0, 0, 2109, 2111, 3, 400, 200, 0, 2110,
        2112, 3, 394, 197, 0, 2111, 2110, 1, 0, 0, 0, 2111, 2112, 1, 0, 0, 0, 2112, 2297, 1,
        0, 0, 0, 2113, 2114, 3, 406, 203, 0, 2114, 2115, 5, 84, 0, 0, 2115, 2117, 3, 400, 200,
        0, 2116, 2118, 3, 394, 197, 0, 2117, 2116, 1, 0, 0, 0, 2117, 2118, 1, 0, 0, 0, 2118,
        2297, 1, 0, 0, 0, 2119, 2120, 3, 406, 203, 0, 2120, 2121, 5, 84, 0, 0, 2121, 2123,
        5, 123, 0, 0, 2122, 2124, 3, 394, 197, 0, 2123, 2122, 1, 0, 0, 0, 2123, 2124, 1, 0,
        0, 0, 2124, 2297, 1, 0, 0, 0, 2125, 2126, 5, 57, 0, 0, 2126, 2127, 5, 84, 0, 0, 2127,
        2129, 5, 123, 0, 0, 2128, 2130, 3, 394, 197, 0, 2129, 2128, 1, 0, 0, 0, 2129, 2130,
        1, 0, 0, 0, 2130, 2297, 1, 0, 0, 0, 2131, 2132, 3, 54, 27, 0, 2132, 2133, 5, 84, 0, 0,
        2133, 2134, 5, 57, 0, 0, 2134, 2135, 5, 84, 0, 0, 2135, 2137, 5, 123, 0, 0, 2136, 2138,
        3, 394, 197, 0, 2137, 2136, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2297, 1, 0, 0,
        0, 2139, 2140, 3, 58, 29, 0, 2140, 2141, 5, 80, 0, 0, 2141, 2142, 3, 388, 194, 0, 2142,
        2144, 5, 81, 0, 0, 2143, 2145, 3, 394, 197, 0, 2144, 2143, 1, 0, 0, 0, 2144, 2145,
        1, 0, 0, 0, 2145, 2297, 1, 0, 0, 0, 2146, 2147, 3, 410, 205, 0, 2147, 2148, 5, 80, 0,
        0, 2148, 2149, 3, 388, 194, 0, 2149, 2151, 5, 81, 0, 0, 2150, 2152, 3, 394, 197, 0,
        2151, 2150, 1, 0, 0, 0, 2151, 2152, 1, 0, 0, 0, 2152, 2297, 1, 0, 0, 0, 2153, 2154,
        3, 60, 30, 0, 2154, 2156, 5, 76, 0, 0, 2155, 2157, 3, 422, 211, 0, 2156, 2155, 1, 0,
        0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2158, 1, 0, 0, 0, 2158, 2160, 5, 77, 0, 0, 2159,
        2161, 3, 394, 197, 0, 2160, 2159, 1, 0, 0, 0, 2160, 2161, 1, 0, 0, 0, 2161, 2297, 1,
        0, 0, 0, 2162, 2163, 3, 54, 27, 0, 2163, 2165, 5, 84, 0, 0, 2164, 2166, 3, 40, 20, 0,
        2165, 2164, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2168,
        5, 123, 0, 0, 2168, 2170, 5, 76, 0, 0, 2169, 2171, 3, 422, 211, 0, 2170, 2169, 1, 0,
        0, 0, 2170, 2171, 1, 0, 0, 0, 2171, 2172, 1, 0, 0, 0, 2172, 2174, 5, 77, 0, 0, 2173,
        2175, 3, 394, 197, 0, 2174, 2173, 1, 0, 0, 0, 2174, 2175, 1, 0, 0, 0, 2175, 2297, 1,
        0, 0, 0, 2176, 2177, 3, 58, 29, 0, 2177, 2179, 5, 84, 0, 0, 2178, 2180, 3, 40, 20, 0,
        2179, 2178, 1, 0, 0, 0, 2179, 2180, 1, 0, 0, 0, 2180, 2181, 1, 0, 0, 0, 2181, 2182,
        5, 123, 0, 0, 2182, 2184, 5, 76, 0, 0, 2183, 2185, 3, 422, 211, 0, 2184, 2183, 1, 0,
        0, 0, 2184, 2185, 1, 0, 0, 0, 2185, 2186, 1, 0, 0, 0, 2186, 2188, 5, 77, 0, 0, 2187,
        2189, 3, 394, 197, 0, 2188, 2187, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2297, 1,
        0, 0, 0, 2190, 2191, 3, 406, 203, 0, 2191, 2193, 5, 84, 0, 0, 2192, 2194, 3, 40, 20,
        0, 2193, 2192, 1, 0, 0, 0, 2193, 2194, 1, 0, 0, 0, 2194, 2195, 1, 0, 0, 0, 2195, 2196,
        5, 123, 0, 0, 2196, 2198, 5, 76, 0, 0, 2197, 2199, 3, 422, 211, 0, 2198, 2197, 1, 0,
        0, 0, 2198, 2199, 1, 0, 0, 0, 2199, 2200, 1, 0, 0, 0, 2200, 2202, 5, 77, 0, 0, 2201,
        2203, 3, 394, 197, 0, 2202, 2201, 1, 0, 0, 0, 2202, 2203, 1, 0, 0, 0, 2203, 2297, 1,
        0, 0, 0, 2204, 2205, 5, 57, 0, 0, 2205, 2207, 5, 84, 0, 0, 2206, 2208, 3, 40, 20, 0,
        2207, 2206, 1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208, 2209, 1, 0, 0, 0, 2209, 2210,
        5, 123, 0, 0, 2210, 2212, 5, 76, 0, 0, 2211, 2213, 3, 422, 211, 0, 2212, 2211, 1, 0,
        0, 0, 2212, 2213, 1, 0, 0, 0, 2213, 2214, 1, 0, 0, 0, 2214, 2216, 5, 77, 0, 0, 2215,
        2217, 3, 394, 197, 0, 2216, 2215, 1, 0, 0, 0, 2216, 2217, 1, 0, 0, 0, 2217, 2297, 1,
        0, 0, 0, 2218, 2219, 3, 54, 27, 0, 2219, 2220, 5, 84, 0, 0, 2220, 2221, 5, 57, 0, 0,
        2221, 2223, 5, 84, 0, 0, 2222, 2224, 3, 40, 20, 0, 2223, 2222, 1, 0, 0, 0, 2223, 2224,
        1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 2226, 5, 123, 0, 0, 2226, 2228, 5, 76, 0, 0,
        2227, 2229, 3, 422, 211, 0, 2228, 2227, 1, 0, 0, 0, 2228, 2229, 1, 0, 0, 0, 2229, 2230,
        1, 0, 0, 0, 2230, 2232, 5, 77, 0, 0, 2231, 2233, 3, 394, 197, 0, 2232, 2231, 1, 0, 0,
        0, 2232, 2233, 1, 0, 0, 0, 2233, 2297, 1, 0, 0, 0, 2234, 2235, 3, 58, 29, 0, 2235, 2237,
        5, 87, 0, 0, 2236, 2238, 3, 40, 20, 0, 2237, 2236, 1, 0, 0, 0, 2237, 2238, 1, 0, 0, 0,
        2238, 2239, 1, 0, 0, 0, 2239, 2241, 5, 123, 0, 0, 2240, 2242, 3, 394, 197, 0, 2241,
        2240, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2297, 1, 0, 0, 0, 2243, 2244, 3, 406,
        203, 0, 2244, 2246, 5, 87, 0, 0, 2245, 2247, 3, 40, 20, 0, 2246, 2245, 1, 0, 0, 0, 2246,
        2247, 1, 0, 0, 0, 2247, 2248, 1, 0, 0, 0, 2248, 2250, 5, 123, 0, 0, 2249, 2251, 3, 394,
        197, 0, 2250, 2249, 1, 0, 0, 0, 2250, 2251, 1, 0, 0, 0, 2251, 2297, 1, 0, 0, 0, 2252,
        2253, 3, 16, 8, 0, 2253, 2255, 5, 87, 0, 0, 2254, 2256, 3, 40, 20, 0, 2255, 2254, 1,
        0, 0, 0, 2255, 2256, 1, 0, 0, 0, 2256, 2257, 1, 0, 0, 0, 2257, 2259, 5, 123, 0, 0, 2258,
        2260, 3, 394, 197, 0, 2259, 2258, 1, 0, 0, 0, 2259, 2260, 1, 0, 0, 0, 2260, 2297, 1,
        0, 0, 0, 2261, 2262, 5, 57, 0, 0, 2262, 2264, 5, 87, 0, 0, 2263, 2265, 3, 40, 20, 0,
        2264, 2263, 1, 0, 0, 0, 2264, 2265, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 2268,
        5, 123, 0, 0, 2267, 2269, 3, 394, 197, 0, 2268, 2267, 1, 0, 0, 0, 2268, 2269, 1, 0,
        0, 0, 2269, 2297, 1, 0, 0, 0, 2270, 2271, 3, 54, 27, 0, 2271, 2272, 5, 84, 0, 0, 2272,
        2273, 5, 57, 0, 0, 2273, 2275, 5, 87, 0, 0, 2274, 2276, 3, 40, 20, 0, 2275, 2274, 1,
        0, 0, 0, 2275, 2276, 1, 0, 0, 0, 2276, 2277, 1, 0, 0, 0, 2277, 2279, 5, 123, 0, 0, 2278,
        2280, 3, 394, 197, 0, 2279, 2278, 1, 0, 0, 0, 2279, 2280, 1, 0, 0, 0, 2280, 2297, 1,
        0, 0, 0, 2281, 2282, 3, 22, 11, 0, 2282, 2284, 5, 87, 0, 0, 2283, 2285, 3, 40, 20, 0,
        2284, 2283, 1, 0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 2286, 1, 0, 0, 0, 2286, 2288,
        5, 48, 0, 0, 2287, 2289, 3, 394, 197, 0, 2288, 2287, 1, 0, 0, 0, 2288, 2289, 1, 0, 0,
        0, 2289, 2297, 1, 0, 0, 0, 2290, 2291, 3, 28, 14, 0, 2291, 2292, 5, 87, 0, 0, 2292,
        2294, 5, 48, 0, 0, 2293, 2295, 3, 394, 197, 0, 2294, 2293, 1, 0, 0, 0, 2294, 2295,
        1, 0, 0, 0, 2295, 2297, 1, 0, 0, 0, 2296, 2079, 1, 0, 0, 0, 2296, 2083, 1, 0, 0, 0, 2296,
        2087, 1, 0, 0, 0, 2296, 2091, 1, 0, 0, 0, 2296, 2097, 1, 0, 0, 0, 2296, 2103, 1, 0, 0,
        0, 2296, 2107, 1, 0, 0, 0, 2296, 2113, 1, 0, 0, 0, 2296, 2119, 1, 0, 0, 0, 2296, 2125,
        1, 0, 0, 0, 2296, 2131, 1, 0, 0, 0, 2296, 2139, 1, 0, 0, 0, 2296, 2146, 1, 0, 0, 0, 2296,
        2153, 1, 0, 0, 0, 2296, 2162, 1, 0, 0, 0, 2296, 2176, 1, 0, 0, 0, 2296, 2190, 1, 0, 0,
        0, 2296, 2204, 1, 0, 0, 0, 2296, 2218, 1, 0, 0, 0, 2296, 2234, 1, 0, 0, 0, 2296, 2243,
        1, 0, 0, 0, 2296, 2252, 1, 0, 0, 0, 2296, 2261, 1, 0, 0, 0, 2296, 2270, 1, 0, 0, 0, 2296,
        2281, 1, 0, 0, 0, 2296, 2290, 1, 0, 0, 0, 2297, 393, 1, 0, 0, 0, 2298, 2299, 5, 84, 0,
        0, 2299, 2301, 3, 400, 200, 0, 2300, 2302, 3, 394, 197, 0, 2301, 2300, 1, 0, 0, 0,
        2301, 2302, 1, 0, 0, 0, 2302, 2336, 1, 0, 0, 0, 2303, 2304, 5, 84, 0, 0, 2304, 2306,
        5, 123, 0, 0, 2305, 2307, 3, 394, 197, 0, 2306, 2305, 1, 0, 0, 0, 2306, 2307, 1, 0,
        0, 0, 2307, 2336, 1, 0, 0, 0, 2308, 2309, 5, 80, 0, 0, 2309, 2310, 3, 388, 194, 0, 2310,
        2312, 5, 81, 0, 0, 2311, 2313, 3, 394, 197, 0, 2312, 2311, 1, 0, 0, 0, 2312, 2313,
        1, 0, 0, 0, 2313, 2336, 1, 0, 0, 0, 2314, 2316, 5, 84, 0, 0, 2315, 2317, 3, 40, 20, 0,
        2316, 2315, 1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 2318, 1, 0, 0, 0, 2318, 2319,
        5, 123, 0, 0, 2319, 2321, 5, 76, 0, 0, 2320, 2322, 3, 422, 211, 0, 2321, 2320, 1, 0,
        0, 0, 2321, 2322, 1, 0, 0, 0, 2322, 2323, 1, 0, 0, 0, 2323, 2325, 5, 77, 0, 0, 2324,
        2326, 3, 394, 197, 0, 2325, 2324, 1, 0, 0, 0, 2325, 2326, 1, 0, 0, 0, 2326, 2336, 1,
        0, 0, 0, 2327, 2329, 5, 87, 0, 0, 2328, 2330, 3, 40, 20, 0, 2329, 2328, 1, 0, 0, 0, 2329,
        2330, 1, 0, 0, 0, 2330, 2331, 1, 0, 0, 0, 2331, 2333, 5, 123, 0, 0, 2332, 2334, 3, 394,
        197, 0, 2333, 2332, 1, 0, 0, 0, 2333, 2334, 1, 0, 0, 0, 2334, 2336, 1, 0, 0, 0, 2335,
        2298, 1, 0, 0, 0, 2335, 2303, 1, 0, 0, 0, 2335, 2308, 1, 0, 0, 0, 2335, 2314, 1, 0, 0,
        0, 2335, 2327, 1, 0, 0, 0, 2336, 395, 1, 0, 0, 0, 2337, 2342, 3, 54, 27, 0, 2338, 2339,
        5, 80, 0, 0, 2339, 2341, 5, 81, 0, 0, 2340, 2338, 1, 0, 0, 0, 2341, 2344, 1, 0, 0, 0,
        2342, 2340, 1, 0, 0, 0, 2342, 2343, 1, 0, 0, 0, 2343, 2345, 1, 0, 0, 0, 2344, 2342,
        1, 0, 0, 0, 2345, 2346, 5, 84, 0, 0, 2346, 2347, 5, 26, 0, 0, 2347, 2373, 1, 0, 0, 0,
        2348, 2353, 3, 10, 5, 0, 2349, 2350, 5, 80, 0, 0, 2350, 2352, 5, 81, 0, 0, 2351, 2349,
        1, 0, 0, 0, 2352, 2355, 1, 0, 0, 0, 2353, 2351, 1, 0, 0, 0, 2353, 2354, 1, 0, 0, 0, 2354,
        2356, 1, 0, 0, 0, 2355, 2353, 1, 0, 0, 0, 2356, 2357, 5, 84, 0, 0, 2357, 2358, 5, 26,
        0, 0, 2358, 2373, 1, 0, 0, 0, 2359, 2364, 5, 20, 0, 0, 2360, 2361, 5, 80, 0, 0, 2361,
        2363, 5, 81, 0, 0, 2362, 2360, 1, 0, 0, 0, 2363, 2366, 1, 0, 0, 0, 2364, 2362, 1, 0,
        0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 2367, 1, 0, 0, 0, 2366, 2364, 1, 0, 0, 0, 2367, 2368,
        5, 84, 0, 0, 2368, 2373, 5, 26, 0, 0, 2369, 2370, 5, 65, 0, 0, 2370, 2371, 5, 84, 0,
        0, 2371, 2373, 5, 26, 0, 0, 2372, 2337, 1, 0, 0, 0, 2372, 2348, 1, 0, 0, 0, 2372, 2359,
        1, 0, 0, 0, 2372, 2369, 1, 0, 0, 0, 2373, 397, 1, 0, 0, 0, 2374, 2384, 3, 400, 200, 0,
        2375, 2376, 3, 58, 29, 0, 2376, 2377, 5, 84, 0, 0, 2377, 2378, 3, 400, 200, 0, 2378,
        2384, 1, 0, 0, 0, 2379, 2380, 3, 390, 195, 0, 2380, 2381, 5, 84, 0, 0, 2381, 2382,
        3, 400, 200, 0, 2382, 2384, 1, 0, 0, 0, 2383, 2374, 1, 0, 0, 0, 2383, 2375, 1, 0, 0,
        0, 2383, 2379, 1, 0, 0, 0, 2384, 399, 1, 0, 0, 0, 2385, 2387, 5, 48, 0, 0, 2386, 2388,
        3, 40, 20, 0, 2387, 2386, 1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0,
        2389, 2390, 3, 402, 201, 0, 2390, 2392, 5, 76, 0, 0, 2391, 2393, 3, 422, 211, 0, 2392,
        2391, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0, 2393, 2394, 1, 0, 0, 0, 2394, 2396, 5, 77,
        0, 0, 2395, 2397, 3, 110, 55, 0, 2396, 2395, 1, 0, 0, 0, 2396, 2397, 1, 0, 0, 0, 2397,
        401, 1, 0, 0, 0, 2398, 2400, 3, 254, 127, 0, 2399, 2398, 1, 0, 0, 0, 2400, 2403, 1,
        0, 0, 0, 2401, 2399, 1, 0, 0, 0, 2401, 2402, 1, 0, 0, 0, 2402, 2404, 1, 0, 0, 0, 2403,
        2401, 1, 0, 0, 0, 2404, 2415, 5, 123, 0, 0, 2405, 2409, 5, 84, 0, 0, 2406, 2408, 3,
        254, 127, 0, 2407, 2406, 1, 0, 0, 0, 2408, 2411, 1, 0, 0, 0, 2409, 2407, 1, 0, 0, 0,
        2409, 2410, 1, 0, 0, 0, 2410, 2412, 1, 0, 0, 0, 2411, 2409, 1, 0, 0, 0, 2412, 2414,
        5, 123, 0, 0, 2413, 2405, 1, 0, 0, 0, 2414, 2417, 1, 0, 0, 0, 2415, 2413, 1, 0, 0, 0,
        2415, 2416, 1, 0, 0, 0, 2416, 2419, 1, 0, 0, 0, 2417, 2415, 1, 0, 0, 0, 2418, 2420,
        3, 404, 202, 0, 2419, 2418, 1, 0, 0, 0, 2419, 2420, 1, 0, 0, 0, 2420, 403, 1, 0, 0, 0,
        2421, 2424, 3, 40, 20, 0, 2422, 2424, 5, 4, 0, 0, 2423, 2421, 1, 0, 0, 0, 2423, 2422,
        1, 0, 0, 0, 2424, 405, 1, 0, 0, 0, 2425, 2428, 3, 408, 204, 0, 2426, 2428, 3, 410, 205,
        0, 2427, 2425, 1, 0, 0, 0, 2427, 2426, 1, 0, 0, 0, 2428, 407, 1, 0, 0, 0, 2429, 2430,
        5, 48, 0, 0, 2430, 2431, 3, 8, 4, 0, 2431, 2433, 3, 412, 206, 0, 2432, 2434, 3, 30,
        15, 0, 2433, 2432, 1, 0, 0, 0, 2433, 2434, 1, 0, 0, 0, 2434, 2442, 1, 0, 0, 0, 2435,
        2436, 5, 48, 0, 0, 2436, 2437, 3, 22, 11, 0, 2437, 2439, 3, 412, 206, 0, 2438, 2440,
        3, 30, 15, 0, 2439, 2438, 1, 0, 0, 0, 2439, 2440, 1, 0, 0, 0, 2440, 2442, 1, 0, 0, 0,
        2441, 2429, 1, 0, 0, 0, 2441, 2435, 1, 0, 0, 0, 2442, 409, 1, 0, 0, 0, 2443, 2444, 5,
        48, 0, 0, 2444, 2445, 3, 8, 4, 0, 2445, 2446, 3, 30, 15, 0, 2446, 2447, 3, 272, 136,
        0, 2447, 2454, 1, 0, 0, 0, 2448, 2449, 5, 48, 0, 0, 2449, 2450, 3, 20, 10, 0, 2450,
        2451, 3, 30, 15, 0, 2451, 2452, 3, 272, 136, 0, 2452, 2454, 1, 0, 0, 0, 2453, 2443,
        1, 0, 0, 0, 2453, 2448, 1, 0, 0, 0, 2454, 411, 1, 0, 0, 0, 2455, 2459, 3, 414, 207, 0,
        2456, 2458, 3, 414, 207, 0, 2457, 2456, 1, 0, 0, 0, 2458, 2461, 1, 0, 0, 0, 2459, 2457,
        1, 0, 0, 0, 2459, 2460, 1, 0, 0, 0, 2460, 413, 1, 0, 0, 0, 2461, 2459, 1, 0, 0, 0, 2462,
        2464, 3, 254, 127, 0, 2463, 2462, 1, 0, 0, 0, 2464, 2467, 1, 0, 0, 0, 2465, 2463, 1,
        0, 0, 0, 2465, 2466, 1, 0, 0, 0, 2466, 2468, 1, 0, 0, 0, 2467, 2465, 1, 0, 0, 0, 2468,
        2469, 5, 80, 0, 0, 2469, 2470, 3, 388, 194, 0, 2470, 2471, 5, 81, 0, 0, 2471, 415,
        1, 0, 0, 0, 2472, 2473, 3, 58, 29, 0, 2473, 2474, 5, 80, 0, 0, 2474, 2475, 3, 388, 194,
        0, 2475, 2476, 5, 81, 0, 0, 2476, 2488, 1, 0, 0, 0, 2477, 2478, 3, 392, 196, 0, 2478,
        2479, 5, 80, 0, 0, 2479, 2480, 3, 388, 194, 0, 2480, 2481, 5, 81, 0, 0, 2481, 2488,
        1, 0, 0, 0, 2482, 2483, 3, 410, 205, 0, 2483, 2484, 5, 80, 0, 0, 2484, 2485, 3, 388,
        194, 0, 2485, 2486, 5, 81, 0, 0, 2486, 2488, 1, 0, 0, 0, 2487, 2472, 1, 0, 0, 0, 2487,
        2477, 1, 0, 0, 0, 2487, 2482, 1, 0, 0, 0, 2488, 417, 1, 0, 0, 0, 2489, 2490, 3, 390,
        195, 0, 2490, 2491, 5, 84, 0, 0, 2491, 2492, 5, 123, 0, 0, 2492, 2503, 1, 0, 0, 0, 2493,
        2494, 5, 57, 0, 0, 2494, 2495, 5, 84, 0, 0, 2495, 2503, 5, 123, 0, 0, 2496, 2497, 3,
        54, 27, 0, 2497, 2498, 5, 84, 0, 0, 2498, 2499, 5, 57, 0, 0, 2499, 2500, 5, 84, 0, 0,
        2500, 2501, 5, 123, 0, 0, 2501, 2503, 1, 0, 0, 0, 2502, 2489, 1, 0, 0, 0, 2502, 2493,
        1, 0, 0, 0, 2502, 2496, 1, 0, 0, 0, 2503, 419, 1, 0, 0, 0, 2504, 2505, 3, 60, 30, 0, 2505,
        2507, 5, 76, 0, 0, 2506, 2508, 3, 422, 211, 0, 2507, 2506, 1, 0, 0, 0, 2507, 2508,
        1, 0, 0, 0, 2508, 2509, 1, 0, 0, 0, 2509, 2510, 5, 77, 0, 0, 2510, 2573, 1, 0, 0, 0, 2511,
        2512, 3, 54, 27, 0, 2512, 2514, 5, 84, 0, 0, 2513, 2515, 3, 40, 20, 0, 2514, 2513,
        1, 0, 0, 0, 2514, 2515, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0, 2516, 2517, 5, 123, 0, 0,
        2517, 2519, 5, 76, 0, 0, 2518, 2520, 3, 422, 211, 0, 2519, 2518, 1, 0, 0, 0, 2519,
        2520, 1, 0, 0, 0, 2520, 2521, 1, 0, 0, 0, 2521, 2522, 5, 77, 0, 0, 2522, 2573, 1, 0,
        0, 0, 2523, 2524, 3, 58, 29, 0, 2524, 2526, 5, 84, 0, 0, 2525, 2527, 3, 40, 20, 0, 2526,
        2525, 1, 0, 0, 0, 2526, 2527, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 2529, 5, 123,
        0, 0, 2529, 2531, 5, 76, 0, 0, 2530, 2532, 3, 422, 211, 0, 2531, 2530, 1, 0, 0, 0, 2531,
        2532, 1, 0, 0, 0, 2532, 2533, 1, 0, 0, 0, 2533, 2534, 5, 77, 0, 0, 2534, 2573, 1, 0,
        0, 0, 2535, 2536, 3, 390, 195, 0, 2536, 2538, 5, 84, 0, 0, 2537, 2539, 3, 40, 20, 0,
        2538, 2537, 1, 0, 0, 0, 2538, 2539, 1, 0, 0, 0, 2539, 2540, 1, 0, 0, 0, 2540, 2541,
        5, 123, 0, 0, 2541, 2543, 5, 76, 0, 0, 2542, 2544, 3, 422, 211, 0, 2543, 2542, 1, 0,
        0, 0, 2543, 2544, 1, 0, 0, 0, 2544, 2545, 1, 0, 0, 0, 2545, 2546, 5, 77, 0, 0, 2546,
        2573, 1, 0, 0, 0, 2547, 2548, 5, 57, 0, 0, 2548, 2550, 5, 84, 0, 0, 2549, 2551, 3, 40,
        20, 0, 2550, 2549, 1, 0, 0, 0, 2550, 2551, 1, 0, 0, 0, 2551, 2552, 1, 0, 0, 0, 2552,
        2553, 5, 123, 0, 0, 2553, 2555, 5, 76, 0, 0, 2554, 2556, 3, 422, 211, 0, 2555, 2554,
        1, 0, 0, 0, 2555, 2556, 1, 0, 0, 0, 2556, 2557, 1, 0, 0, 0, 2557, 2573, 5, 77, 0, 0, 2558,
        2559, 3, 54, 27, 0, 2559, 2560, 5, 84, 0, 0, 2560, 2561, 5, 57, 0, 0, 2561, 2563, 5,
        84, 0, 0, 2562, 2564, 3, 40, 20, 0, 2563, 2562, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564,
        2565, 1, 0, 0, 0, 2565, 2566, 5, 123, 0, 0, 2566, 2568, 5, 76, 0, 0, 2567, 2569, 3,
        422, 211, 0, 2568, 2567, 1, 0, 0, 0, 2568, 2569, 1, 0, 0, 0, 2569, 2570, 1, 0, 0, 0,
        2570, 2571, 5, 77, 0, 0, 2571, 2573, 1, 0, 0, 0, 2572, 2504, 1, 0, 0, 0, 2572, 2511,
        1, 0, 0, 0, 2572, 2523, 1, 0, 0, 0, 2572, 2535, 1, 0, 0, 0, 2572, 2547, 1, 0, 0, 0, 2572,
        2558, 1, 0, 0, 0, 2573, 421, 1, 0, 0, 0, 2574, 2579, 3, 388, 194, 0, 2575, 2576, 5,
        83, 0, 0, 2576, 2578, 3, 388, 194, 0, 2577, 2575, 1, 0, 0, 0, 2578, 2581, 1, 0, 0, 0,
        2579, 2577, 1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 423, 1, 0, 0, 0, 2581, 2579, 1,
        0, 0, 0, 2582, 2583, 3, 58, 29, 0, 2583, 2585, 5, 87, 0, 0, 2584, 2586, 3, 40, 20, 0,
        2585, 2584, 1, 0, 0, 0, 2585, 2586, 1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 2588,
        5, 123, 0, 0, 2588, 2630, 1, 0, 0, 0, 2589, 2590, 3, 390, 195, 0, 2590, 2592, 5, 87,
        0, 0, 2591, 2593, 3, 40, 20, 0, 2592, 2591, 1, 0, 0, 0, 2592, 2593, 1, 0, 0, 0, 2593,
        2594, 1, 0, 0, 0, 2594, 2595, 5, 123, 0, 0, 2595, 2630, 1, 0, 0, 0, 2596, 2597, 3, 16,
        8, 0, 2597, 2599, 5, 87, 0, 0, 2598, 2600, 3, 40, 20, 0, 2599, 2598, 1, 0, 0, 0, 2599,
        2600, 1, 0, 0, 0, 2600, 2601, 1, 0, 0, 0, 2601, 2602, 5, 123, 0, 0, 2602, 2630, 1, 0,
        0, 0, 2603, 2604, 5, 57, 0, 0, 2604, 2606, 5, 87, 0, 0, 2605, 2607, 3, 40, 20, 0, 2606,
        2605, 1, 0, 0, 0, 2606, 2607, 1, 0, 0, 0, 2607, 2608, 1, 0, 0, 0, 2608, 2630, 5, 123,
        0, 0, 2609, 2610, 3, 54, 27, 0, 2610, 2611, 5, 84, 0, 0, 2611, 2612, 5, 57, 0, 0, 2612,
        2614, 5, 87, 0, 0, 2613, 2615, 3, 40, 20, 0, 2614, 2613, 1, 0, 0, 0, 2614, 2615, 1,
        0, 0, 0, 2615, 2616, 1, 0, 0, 0, 2616, 2617, 5, 123, 0, 0, 2617, 2630, 1, 0, 0, 0, 2618,
        2619, 3, 22, 11, 0, 2619, 2621, 5, 87, 0, 0, 2620, 2622, 3, 40, 20, 0, 2621, 2620,
        1, 0, 0, 0, 2621, 2622, 1, 0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2624, 5, 48, 0, 0, 2624,
        2630, 1, 0, 0, 0, 2625, 2626, 3, 28, 14, 0, 2626, 2627, 5, 87, 0, 0, 2627, 2628, 5,
        48, 0, 0, 2628, 2630, 1, 0, 0, 0, 2629, 2582, 1, 0, 0, 0, 2629, 2589, 1, 0, 0, 0, 2629,
        2596, 1, 0, 0, 0, 2629, 2603, 1, 0, 0, 0, 2629, 2609, 1, 0, 0, 0, 2629, 2618, 1, 0, 0,
        0, 2629, 2625, 1, 0, 0, 0, 2630, 425, 1, 0, 0, 0, 2631, 2633, 3, 390, 195, 0, 2632,
        2634, 3, 428, 214, 0, 2633, 2632, 1, 0, 0, 0, 2633, 2634, 1, 0, 0, 0, 2634, 2640, 1,
        0, 0, 0, 2635, 2637, 3, 58, 29, 0, 2636, 2638, 3, 428, 214, 0, 2637, 2636, 1, 0, 0,
        0, 2637, 2638, 1, 0, 0, 0, 2638, 2640, 1, 0, 0, 0, 2639, 2631, 1, 0, 0, 0, 2639, 2635,
        1, 0, 0, 0, 2640, 427, 1, 0, 0, 0, 2641, 2643, 5, 102, 0, 0, 2642, 2644, 3, 428, 214,
        0, 2643, 2642, 1, 0, 0, 0, 2643, 2644, 1, 0, 0, 0, 2644, 2650, 1, 0, 0, 0, 2645, 2647,
        5, 103, 0, 0, 2646, 2648, 3, 428, 214, 0, 2647, 2646, 1, 0, 0, 0, 2647, 2648, 1, 0,
        0, 0, 2648, 2650, 1, 0, 0, 0, 2649, 2641, 1, 0, 0, 0, 2649, 2645, 1, 0, 0, 0, 2650, 429,
        1, 0, 0, 0, 2651, 2652, 3, 426, 213, 0, 2652, 2653, 5, 102, 0, 0, 2653, 431, 1, 0, 0,
        0, 2654, 2655, 3, 426, 213, 0, 2655, 2656, 5, 103, 0, 0, 2656, 433, 1, 0, 0, 0, 2657,
        2665, 3, 436, 218, 0, 2658, 2665, 3, 438, 219, 0, 2659, 2660, 5, 104, 0, 0, 2660,
        2665, 3, 434, 217, 0, 2661, 2662, 5, 105, 0, 0, 2662, 2665, 3, 434, 217, 0, 2663,
        2665, 3, 440, 220, 0, 2664, 2657, 1, 0, 0, 0, 2664, 2658, 1, 0, 0, 0, 2664, 2659, 1,
        0, 0, 0, 2664, 2661, 1, 0, 0, 0, 2664, 2663, 1, 0, 0, 0, 2665, 435, 1, 0, 0, 0, 2666,
        2667, 5, 102, 0, 0, 2667, 2668, 3, 434, 217, 0, 2668, 437, 1, 0, 0, 0, 2669, 2670,
        5, 103, 0, 0, 2670, 2671, 3, 434, 217, 0, 2671, 439, 1, 0, 0, 0, 2672, 2680, 3, 426,
        213, 0, 2673, 2674, 5, 92, 0, 0, 2674, 2680, 3, 434, 217, 0, 2675, 2676, 5, 91, 0,
        0, 2676, 2680, 3, 434, 217, 0, 2677, 2680, 3, 442, 221, 0, 2678, 2680, 3, 486, 243,
        0, 2679, 2672, 1, 0, 0, 0, 2679, 2673, 1, 0, 0, 0, 2679, 2675, 1, 0, 0, 0, 2679, 2677,
        1, 0, 0, 0, 2679, 2678, 1, 0, 0, 0, 2680, 441, 1, 0, 0, 0, 2681, 2682, 5, 76, 0, 0, 2682,
        2683, 3, 8, 4, 0, 2683, 2684, 5, 77, 0, 0, 2684, 2685, 3, 434, 217, 0, 2685, 2709,
        1, 0, 0, 0, 2686, 2687, 5, 76, 0, 0, 2687, 2691, 3, 16, 8, 0, 2688, 2690, 3, 38, 19,
        0, 2689, 2688, 1, 0, 0, 0, 2690, 2693, 1, 0, 0, 0, 2691, 2689, 1, 0, 0, 0, 2691, 2692,
        1, 0, 0, 0, 2692, 2694, 1, 0, 0, 0, 2693, 2691, 1, 0, 0, 0, 2694, 2695, 5, 77, 0, 0, 2695,
        2696, 3, 440, 220, 0, 2696, 2709, 1, 0, 0, 0, 2697, 2698, 5, 76, 0, 0, 2698, 2702,
        3, 16, 8, 0, 2699, 2701, 3, 38, 19, 0, 2700, 2699, 1, 0, 0, 0, 2701, 2704, 1, 0, 0, 0,
        2702, 2700, 1, 0, 0, 0, 2702, 2703, 1, 0, 0, 0, 2703, 2705, 1, 0, 0, 0, 2704, 2702,
        1, 0, 0, 0, 2705, 2706, 5, 77, 0, 0, 2706, 2707, 3, 474, 237, 0, 2707, 2709, 1, 0, 0,
        0, 2708, 2681, 1, 0, 0, 0, 2708, 2686, 1, 0, 0, 0, 2708, 2697, 1, 0, 0, 0, 2709, 443,
        1, 0, 0, 0, 2710, 2711, 6, 222, -1, 0, 2711, 2712, 3, 434, 217, 0, 2712, 2724, 1, 0,
        0, 0, 2713, 2714, 10, 3, 0, 0, 2714, 2715, 5, 106, 0, 0, 2715, 2723, 3, 434, 217, 0,
        2716, 2717, 10, 2, 0, 0, 2717, 2718, 5, 107, 0, 0, 2718, 2723, 3, 434, 217, 0, 2719,
        2720, 10, 1, 0, 0, 2720, 2721, 5, 111, 0, 0, 2721, 2723, 3, 434, 217, 0, 2722, 2713,
        1, 0, 0, 0, 2722, 2716, 1, 0, 0, 0, 2722, 2719, 1, 0, 0, 0, 2723, 2726, 1, 0, 0, 0, 2724,
        2722, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 445, 1, 0, 0, 0, 2726, 2724, 1, 0, 0,
        0, 2727, 2728, 6, 223, -1, 0, 2728, 2729, 3, 444, 222, 0, 2729, 2738, 1, 0, 0, 0, 2730,
        2731, 10, 2, 0, 0, 2731, 2732, 5, 104, 0, 0, 2732, 2737, 3, 444, 222, 0, 2733, 2734,
        10, 1, 0, 0, 2734, 2735, 5, 105, 0, 0, 2735, 2737, 3, 444, 222, 0, 2736, 2730, 1, 0,
        0, 0, 2736, 2733, 1, 0, 0, 0, 2737, 2740, 1, 0, 0, 0, 2738, 2736, 1, 0, 0, 0, 2738, 2739,
        1, 0, 0, 0, 2739, 447, 1, 0, 0, 0, 2740, 2738, 1, 0, 0, 0, 2741, 2742, 6, 224, -1, 0,
        2742, 2743, 3, 446, 223, 0, 2743, 2759, 1, 0, 0, 0, 2744, 2745, 10, 3, 0, 0, 2745,
        2746, 5, 90, 0, 0, 2746, 2747, 5, 90, 0, 0, 2747, 2758, 3, 446, 223, 0, 2748, 2749,
        10, 2, 0, 0, 2749, 2750, 5, 89, 0, 0, 2750, 2751, 5, 89, 0, 0, 2751, 2758, 3, 446, 223,
        0, 2752, 2753, 10, 1, 0, 0, 2753, 2754, 5, 89, 0, 0, 2754, 2755, 5, 89, 0, 0, 2755,
        2756, 5, 89, 0, 0, 2756, 2758, 3, 446, 223, 0, 2757, 2744, 1, 0, 0, 0, 2757, 2748,
        1, 0, 0, 0, 2757, 2752, 1, 0, 0, 0, 2758, 2761, 1, 0, 0, 0, 2759, 2757, 1, 0, 0, 0, 2759,
        2760, 1, 0, 0, 0, 2760, 449, 1, 0, 0, 0, 2761, 2759, 1, 0, 0, 0, 2762, 2763, 6, 225,
        -1, 0, 2763, 2764, 3, 448, 224, 0, 2764, 2785, 1, 0, 0, 0, 2765, 2766, 10, 5, 0, 0,
        2766, 2767, 5, 90, 0, 0, 2767, 2784, 3, 448, 224, 0, 2768, 2769, 10, 4, 0, 0, 2769,
        2770, 5, 89, 0, 0, 2770, 2784, 3, 448, 224, 0, 2771, 2772, 10, 3, 0, 0, 2772, 2773,
        5, 97, 0, 0, 2773, 2784, 3, 448, 224, 0, 2774, 2775, 10, 2, 0, 0, 2775, 2776, 5, 98,
        0, 0, 2776, 2784, 3, 448, 224, 0, 2777, 2778, 10, 1, 0, 0, 2778, 2781, 5, 43, 0, 0,
        2779, 2782, 3, 16, 8, 0, 2780, 2782, 3, 384, 192, 0, 2781, 2779, 1, 0, 0, 0, 2781,
        2780, 1, 0, 0, 0, 2782, 2784, 1, 0, 0, 0, 2783, 2765, 1, 0, 0, 0, 2783, 2768, 1, 0, 0,
        0, 2783, 2771, 1, 0, 0, 0, 2783, 2774, 1, 0, 0, 0, 2783, 2777, 1, 0, 0, 0, 2784, 2787,
        1, 0, 0, 0, 2785, 2783, 1, 0, 0, 0, 2785, 2786, 1, 0, 0, 0, 2786, 451, 1, 0, 0, 0, 2787,
        2785, 1, 0, 0, 0, 2788, 2789, 6, 226, -1, 0, 2789, 2790, 3, 450, 225, 0, 2790, 2799,
        1, 0, 0, 0, 2791, 2792, 10, 2, 0, 0, 2792, 2793, 5, 96, 0, 0, 2793, 2798, 3, 450, 225,
        0, 2794, 2795, 10, 1, 0, 0, 2795, 2796, 5, 99, 0, 0, 2796, 2798, 3, 450, 225, 0, 2797,
        2791, 1, 0, 0, 0, 2797, 2794, 1, 0, 0, 0, 2798, 2801, 1, 0, 0, 0, 2799, 2797, 1, 0, 0,
        0, 2799, 2800, 1, 0, 0, 0, 2800, 453, 1, 0, 0, 0, 2801, 2799, 1, 0, 0, 0, 2802, 2803,
        6, 227, -1, 0, 2803, 2804, 3, 452, 226, 0, 2804, 2810, 1, 0, 0, 0, 2805, 2806, 10,
        1, 0, 0, 2806, 2807, 5, 108, 0, 0, 2807, 2809, 3, 452, 226, 0, 2808, 2805, 1, 0, 0,
        0, 2809, 2812, 1, 0, 0, 0, 2810, 2808, 1, 0, 0, 0, 2810, 2811, 1, 0, 0, 0, 2811, 455,
        1, 0, 0, 0, 2812, 2810, 1, 0, 0, 0, 2813, 2814, 6, 228, -1, 0, 2814, 2815, 3, 454, 227,
        0, 2815, 2821, 1, 0, 0, 0, 2816, 2817, 10, 1, 0, 0, 2817, 2818, 5, 110, 0, 0, 2818,
        2820, 3, 454, 227, 0, 2819, 2816, 1, 0, 0, 0, 2820, 2823, 1, 0, 0, 0, 2821, 2819, 1,
        0, 0, 0, 2821, 2822, 1, 0, 0, 0, 2822, 457, 1, 0, 0, 0, 2823, 2821, 1, 0, 0, 0, 2824,
        2825, 6, 229, -1, 0, 2825, 2826, 3, 456, 228, 0, 2826, 2832, 1, 0, 0, 0, 2827, 2828,
        10, 1, 0, 0, 2828, 2829, 5, 109, 0, 0, 2829, 2831, 3, 456, 228, 0, 2830, 2827, 1, 0,
        0, 0, 2831, 2834, 1, 0, 0, 0, 2832, 2830, 1, 0, 0, 0, 2832, 2833, 1, 0, 0, 0, 2833, 459,
        1, 0, 0, 0, 2834, 2832, 1, 0, 0, 0, 2835, 2836, 6, 230, -1, 0, 2836, 2837, 3, 458, 229,
        0, 2837, 2843, 1, 0, 0, 0, 2838, 2839, 10, 1, 0, 0, 2839, 2840, 5, 100, 0, 0, 2840,
        2842, 3, 458, 229, 0, 2841, 2838, 1, 0, 0, 0, 2842, 2845, 1, 0, 0, 0, 2843, 2841, 1,
        0, 0, 0, 2843, 2844, 1, 0, 0, 0, 2844, 461, 1, 0, 0, 0, 2845, 2843, 1, 0, 0, 0, 2846,
        2847, 6, 231, -1, 0, 2847, 2848, 3, 460, 230, 0, 2848, 2854, 1, 0, 0, 0, 2849, 2850,
        10, 1, 0, 0, 2850, 2851, 5, 101, 0, 0, 2851, 2853, 3, 460, 230, 0, 2852, 2849, 1, 0,
        0, 0, 2853, 2856, 1, 0, 0, 0, 2854, 2852, 1, 0, 0, 0, 2854, 2855, 1, 0, 0, 0, 2855, 463,
        1, 0, 0, 0, 2856, 2854, 1, 0, 0, 0, 2857, 2871, 3, 462, 231, 0, 2858, 2859, 3, 462,
        231, 0, 2859, 2860, 5, 93, 0, 0, 2860, 2861, 3, 388, 194, 0, 2861, 2862, 5, 94, 0,
        0, 2862, 2863, 3, 464, 232, 0, 2863, 2871, 1, 0, 0, 0, 2864, 2865, 3, 462, 231, 0,
        2865, 2866, 5, 93, 0, 0, 2866, 2867, 3, 388, 194, 0, 2867, 2868, 5, 94, 0, 0, 2868,
        2869, 3, 474, 237, 0, 2869, 2871, 1, 0, 0, 0, 2870, 2857, 1, 0, 0, 0, 2870, 2858, 1,
        0, 0, 0, 2870, 2864, 1, 0, 0, 0, 2871, 465, 1, 0, 0, 0, 2872, 2875, 3, 464, 232, 0, 2873,
        2875, 3, 468, 234, 0, 2874, 2872, 1, 0, 0, 0, 2874, 2873, 1, 0, 0, 0, 2875, 467, 1,
        0, 0, 0, 2876, 2877, 3, 470, 235, 0, 2877, 2878, 3, 472, 236, 0, 2878, 2879, 3, 388,
        194, 0, 2879, 469, 1, 0, 0, 0, 2880, 2884, 3, 58, 29, 0, 2881, 2884, 3, 418, 209, 0,
        2882, 2884, 3, 416, 208, 0, 2883, 2880, 1, 0, 0, 0, 2883, 2881, 1, 0, 0, 0, 2883, 2882,
        1, 0, 0, 0, 2884, 471, 1, 0, 0, 0, 2885, 2886, 7, 5, 0, 0, 2886, 473, 1, 0, 0, 0, 2887,
        2888, 3, 476, 238, 0, 2888, 2889, 5, 95, 0, 0, 2889, 2890, 3, 484, 242, 0, 2890, 475,
        1, 0, 0, 0, 2891, 2893, 5, 76, 0, 0, 2892, 2894, 3, 478, 239, 0, 2893, 2892, 1, 0, 0,
        0, 2893, 2894, 1, 0, 0, 0, 2894, 2895, 1, 0, 0, 0, 2895, 2898, 5, 77, 0, 0, 2896, 2898,
        5, 123, 0, 0, 2897, 2891, 1, 0, 0, 0, 2897, 2896, 1, 0, 0, 0, 2898, 477, 1, 0, 0, 0, 2899,
        2904, 3, 480, 240, 0, 2900, 2901, 5, 83, 0, 0, 2901, 2903, 3, 480, 240, 0, 2902, 2900,
        1, 0, 0, 0, 2903, 2906, 1, 0, 0, 0, 2904, 2902, 1, 0, 0, 0, 2904, 2905, 1, 0, 0, 0, 2905,
        2916, 1, 0, 0, 0, 2906, 2904, 1, 0, 0, 0, 2907, 2912, 5, 123, 0, 0, 2908, 2909, 5, 83,
        0, 0, 2909, 2911, 5, 123, 0, 0, 2910, 2908, 1, 0, 0, 0, 2911, 2914, 1, 0, 0, 0, 2912,
        2910, 1, 0, 0, 0, 2912, 2913, 1, 0, 0, 0, 2913, 2916, 1, 0, 0, 0, 2914, 2912, 1, 0, 0,
        0, 2915, 2899, 1, 0, 0, 0, 2915, 2907, 1, 0, 0, 0, 2916, 479, 1, 0, 0, 0, 2917, 2919,
        3, 164, 82, 0, 2918, 2917, 1, 0, 0, 0, 2919, 2922, 1, 0, 0, 0, 2920, 2918, 1, 0, 0, 0,
        2920, 2921, 1, 0, 0, 0, 2921, 2923, 1, 0, 0, 0, 2922, 2920, 1, 0, 0, 0, 2923, 2924,
        3, 482, 241, 0, 2924, 2925, 3, 124, 62, 0, 2925, 2928, 1, 0, 0, 0, 2926, 2928, 3, 162,
        81, 0, 2927, 2920, 1, 0, 0, 0, 2927, 2926, 1, 0, 0, 0, 2928, 481, 1, 0, 0, 0, 2929, 2932,
        3, 128, 64, 0, 2930, 2932, 5, 15, 0, 0, 2931, 2929, 1, 0, 0, 0, 2931, 2930, 1, 0, 0,
        0, 2932, 483, 1, 0, 0, 0, 2933, 2936, 3, 388, 194, 0, 2934, 2936, 3, 276, 138, 0, 2935,
        2933, 1, 0, 0, 0, 2935, 2934, 1, 0, 0, 0, 2936, 485, 1, 0, 0, 0, 2937, 2938, 5, 58, 0,
        0, 2938, 2939, 5, 76, 0, 0, 2939, 2940, 3, 388, 194, 0, 2940, 2941, 5, 77, 0, 0, 2941,
        2942, 3, 316, 158, 0, 2942, 487, 1, 0, 0, 0, 2943, 2944, 3, 388, 194, 0, 2944, 489,
        1, 0, 0, 0, 360, 502, 507, 511, 520, 526, 531, 534, 539, 544, 549, 552, 557, 562,
        569, 574, 581, 586, 588, 595, 609, 614, 622, 629, 635, 640, 650, 653, 667, 672,
        677, 682, 688, 693, 698, 703, 708, 713, 722, 726, 729, 734, 740, 746, 754, 763,
        774, 803, 808, 812, 820, 827, 836, 850, 853, 865, 868, 884, 889, 896, 901, 907,
        910, 913, 916, 930, 941, 955, 964, 971, 980, 987, 992, 1007, 1014, 1020, 1024,
        1028, 1032, 1036, 1041, 1048, 1051, 1055, 1058, 1064, 1069, 1072, 1076, 1080,
        1086, 1091, 1093, 1102, 1109, 1125, 1131, 1134, 1139, 1143, 1150, 1153, 1157,
        1162, 1168, 1177, 1183, 1190, 1195, 1202, 1210, 1220, 1225, 1229, 1239, 1244,
        1252, 1255, 1262, 1265, 1273, 1276, 1281, 1286, 1292, 1296, 1301, 1306, 1311,
        1317, 1323, 1326, 1329, 1338, 1344, 1350, 1353, 1356, 1364, 1370, 1376, 1380,
        1386, 1395, 1401, 1408, 1413, 1420, 1432, 1439, 1444, 1452, 1457, 1463, 1466,
        1469, 1482, 1493, 1500, 1510, 1515, 1526, 1531, 1544, 1549, 1561, 1571, 1576,
        1584, 1587, 1594, 1602, 1608, 1617, 1627, 1631, 1634, 1643, 1657, 1660, 1669,
        1674, 1682, 1688, 1692, 1697, 1702, 1706, 1717, 1724, 1739, 1761, 1789, 1804,
        1813, 1821, 1825, 1834, 1843, 1854, 1858, 1884, 1888, 1893, 1897, 1901, 1909,
        1913, 1917, 1924, 1933, 1954, 1960, 1966, 1991, 1996, 2002, 2014, 2025, 2035,
        2038, 2043, 2052, 2057, 2061, 2073, 2077, 2081, 2085, 2089, 2095, 2101, 2105,
        2111, 2117, 2123, 2129, 2137, 2144, 2151, 2156, 2160, 2165, 2170, 2174, 2179,
        2184, 2188, 2193, 2198, 2202, 2207, 2212, 2216, 2223, 2228, 2232, 2237, 2241,
        2246, 2250, 2255, 2259, 2264, 2268, 2275, 2279, 2284, 2288, 2294, 2296, 2301,
        2306, 2312, 2316, 2321, 2325, 2329, 2333, 2335, 2342, 2353, 2364, 2372, 2383,
        2387, 2392, 2396, 2401, 2409, 2415, 2419, 2423, 2427, 2433, 2439, 2441, 2453,
        2459, 2465, 2487, 2502, 2507, 2514, 2519, 2526, 2531, 2538, 2543, 2550, 2555,
        2563, 2568, 2572, 2579, 2585, 2592, 2599, 2606, 2614, 2621, 2629, 2633, 2637,
        2639, 2643, 2647, 2649, 2664, 2679, 2691, 2702, 2708, 2722, 2724, 2736, 2738,
        2757, 2759, 2781, 2783, 2785, 2797, 2799, 2810, 2821, 2832, 2843, 2854, 2870,
        2874, 2883, 2893, 2897, 2904, 2912, 2915, 2920, 2927, 2931, 2935
    ]


class Java20Parser(Parser):
    grammarFileName = "Java20Parser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "'exports'", "'module'", "'non-sealed'",
                    "'<>'", "'open'", "'opens'", "'permits'", "'provides'",
                    "'record'", "'requires'", "'sealed'", "'to'", "'transitive'",
                    "'uses'", "'var'", "'with'", "'yield'", "'abstract'",
                    "'assert'", "'boolean'", "'break'", "'byte'", "'case'",
                    "'catch'", "'char'", "'class'", "'const'", "'continue'",
                    "'default'", "'do'", "'double'", "'else'", "'enum'",
                    "'extends'", "'final'", "'finally'", "'float'", "'for'",
                    "'if'", "'goto'", "'implements'", "'import'", "'instanceof'",
                    "'int'", "'interface'", "'long'", "'native'", "'new'",
                    "'package'", "'private'", "'protected'", "'public'",
                    "'return'", "'short'", "'static'", "'strictfp'", "'super'",
                    "'switch'", "'synchronized'", "'this'", "'throw'",
                    "'throws'", "'transient'", "'try'", "'void'", "'volatile'",
                    "'while'", "'_'", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "'null'", "'('",
                    "')'", "'{'", "'}'", "'['", "']'", "';'", "','", "'.'",
                    "'...'", "'@'", "'::'", "'='", "'>'", "'<'", "'!'",
                    "'~'", "'?'", "':'", "'->'", "'=='", "'<='", "'>='",
                    "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", "'-'",
                    "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", "'-='",
                    "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", "'<<='",
                    "'>>='", "'>>>='"]

    symbolicNames = ["<INVALID>", "EXPORTS", "MODULE", "NONSEALED", "OACA",
                     "OPEN", "OPENS", "PERMITS", "PROVIDES", "RECORD",
                     "REQUIRES", "SEALED", "TO", "TRANSITIVE", "USES",
                     "VAR", "WITH", "YIELD", "ABSTRACT", "ASSERT", "BOOLEAN",
                     "BREAK", "BYTE", "CASE", "CATCH", "CHAR", "CLASS",
                     "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE",
                     "ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR",
                     "IF", "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF",
                     "INT", "INTERFACE", "LONG", "NATIVE", "NEW", "PACKAGE",
                     "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "SHORT",
                     "STATIC", "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED",
                     "THIS", "THROW", "THROWS", "TRANSIENT", "TRY", "VOID",
                     "VOLATILE", "WHILE", "UNDER_SCORE", "IntegerLiteral",
                     "FloatingPointLiteral", "BooleanLiteral", "CharacterLiteral",
                     "StringLiteral", "TextBlock", "NullLiteral", "LPAREN",
                     "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK",
                     "SEMI", "COMMA", "DOT", "ELLIPSIS", "AT", "COLONCOLON",
                     "ASSIGN", "GT", "LT", "BANG", "TILDE", "QUESTION",
                     "COLON", "ARROW", "EQUAL", "LE", "GE", "NOTEQUAL",
                     "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV",
                     "BITAND", "BITOR", "CARET", "MOD", "ADD_ASSIGN", "SUB_ASSIGN",
                     "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN",
                     "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN",
                     "URSHIFT_ASSIGN", "Identifier", "WS", "COMMENT", "LINE_COMMENT"]

    RULE_start_ = 0
    RULE_literal = 1
    RULE_typeIdentifier = 2
    RULE_unqualifiedMethodIdentifier = 3
    RULE_primitiveType = 4
    RULE_numericType = 5
    RULE_integralType = 6
    RULE_floatingPointType = 7
    RULE_referenceType = 8
    RULE_coit = 9
    RULE_classOrInterfaceType = 10
    RULE_classType = 11
    RULE_interfaceType = 12
    RULE_typeVariable = 13
    RULE_arrayType = 14
    RULE_dims = 15
    RULE_typeParameter = 16
    RULE_typeParameterModifier = 17
    RULE_typeBound = 18
    RULE_additionalBound = 19
    RULE_typeArguments = 20
    RULE_typeArgumentList = 21
    RULE_typeArgument = 22
    RULE_wildcard = 23
    RULE_wildcardBounds = 24
    RULE_moduleName = 25
    RULE_packageName = 26
    RULE_typeName = 27
    RULE_packageOrTypeName = 28
    RULE_expressionName = 29
    RULE_methodName = 30
    RULE_ambiguousName = 31
    RULE_compilationUnit = 32
    RULE_ordinaryCompilationUnit = 33
    RULE_modularCompilationUnit = 34
    RULE_packageDeclaration = 35
    RULE_packageModifier = 36
    RULE_importDeclaration = 37
    RULE_singleTypeImportDeclaration = 38
    RULE_typeImportOnDemandDeclaration = 39
    RULE_singleStaticImportDeclaration = 40
    RULE_staticImportOnDemandDeclaration = 41
    RULE_topLevelClassOrInterfaceDeclaration = 42
    RULE_moduleDeclaration = 43
    RULE_moduleDirective = 44
    RULE_requiresModifier = 45
    RULE_classDeclaration = 46
    RULE_normalClassDeclaration = 47
    RULE_classModifier = 48
    RULE_typeParameters = 49
    RULE_typeParameterList = 50
    RULE_classExtends = 51
    RULE_classImplements = 52
    RULE_interfaceTypeList = 53
    RULE_classPermits = 54
    RULE_classBody = 55
    RULE_classBodyDeclaration = 56
    RULE_classMemberDeclaration = 57
    RULE_fieldDeclaration = 58
    RULE_fieldModifier = 59
    RULE_variableDeclaratorList = 60
    RULE_variableDeclarator = 61
    RULE_variableDeclaratorId = 62
    RULE_variableInitializer = 63
    RULE_unannType = 64
    RULE_unannPrimitiveType = 65
    RULE_unannReferenceType = 66
    RULE_unannClassOrInterfaceType = 67
    RULE_uCOIT = 68
    RULE_unannClassType = 69
    RULE_unannInterfaceType = 70
    RULE_unannTypeVariable = 71
    RULE_unannArrayType = 72
    RULE_methodDeclaration = 73
    RULE_methodModifier = 74
    RULE_methodHeader = 75
    RULE_result = 76
    RULE_methodDeclarator = 77
    RULE_receiverParameter = 78
    RULE_formalParameterList = 79
    RULE_formalParameter = 80
    RULE_variableArityParameter = 81
    RULE_variableModifier = 82
    RULE_throwsT = 83
    RULE_exceptionTypeList = 84
    RULE_exceptionType = 85
    RULE_methodBody = 86
    RULE_instanceInitializer = 87
    RULE_staticInitializer = 88
    RULE_constructorDeclaration = 89
    RULE_constructorModifier = 90
    RULE_constructorDeclarator = 91
    RULE_simpleTypeName = 92
    RULE_constructorBody = 93
    RULE_explicitConstructorInvocation = 94
    RULE_enumDeclaration = 95
    RULE_enumBody = 96
    RULE_enumConstantList = 97
    RULE_enumConstant = 98
    RULE_enumConstantModifier = 99
    RULE_enumBodyDeclarations = 100
    RULE_recordDeclaration = 101
    RULE_recordHeader = 102
    RULE_recordComponentList = 103
    RULE_recordComponent = 104
    RULE_variableArityRecordComponent = 105
    RULE_recordComponentModifier = 106
    RULE_recordBody = 107
    RULE_recordBodyDeclaration = 108
    RULE_compactConstructorDeclaration = 109
    RULE_interfaceDeclaration = 110
    RULE_normalInterfaceDeclaration = 111
    RULE_interfaceModifier = 112
    RULE_interfaceExtends = 113
    RULE_interfacePermits = 114
    RULE_interfaceBody = 115
    RULE_interfaceMemberDeclaration = 116
    RULE_constantDeclaration = 117
    RULE_constantModifier = 118
    RULE_interfaceMethodDeclaration = 119
    RULE_interfaceMethodModifier = 120
    RULE_annotationInterfaceDeclaration = 121
    RULE_annotationInterfaceBody = 122
    RULE_annotationInterfaceMemberDeclaration = 123
    RULE_annotationInterfaceElementDeclaration = 124
    RULE_annotationInterfaceElementModifier = 125
    RULE_defaultValue = 126
    RULE_annotation = 127
    RULE_normalAnnotation = 128
    RULE_elementValuePairList = 129
    RULE_elementValuePair = 130
    RULE_elementValue = 131
    RULE_elementValueArrayInitializer = 132
    RULE_elementValueList = 133
    RULE_markerAnnotation = 134
    RULE_singleElementAnnotation = 135
    RULE_arrayInitializer = 136
    RULE_variableInitializerList = 137
    RULE_block = 138
    RULE_blockStatements = 139
    RULE_blockStatement = 140
    RULE_localClassOrInterfaceDeclaration = 141
    RULE_localVariableDeclaration = 142
    RULE_localVariableType = 143
    RULE_localVariableDeclarationStatement = 144
    RULE_statement = 145
    RULE_statementNoShortIf = 146
    RULE_statementWithoutTrailingSubstatement = 147
    RULE_emptyStatement_ = 148
    RULE_labeledStatement = 149
    RULE_labeledStatementNoShortIf = 150
    RULE_expressionStatement = 151
    RULE_statementExpression = 152
    RULE_ifThenStatement = 153
    RULE_ifThenElseStatement = 154
    RULE_ifThenElseStatementNoShortIf = 155
    RULE_assertStatement = 156
    RULE_switchStatement = 157
    RULE_switchBlock = 158
    RULE_switchRule = 159
    RULE_switchBlockStatementGroup = 160
    RULE_switchLabel = 161
    RULE_caseConstant = 162
    RULE_whileStatement = 163
    RULE_whileStatementNoShortIf = 164
    RULE_doStatement = 165
    RULE_forStatement = 166
    RULE_forStatementNoShortIf = 167
    RULE_basicForStatement = 168
    RULE_basicForStatementNoShortIf = 169
    RULE_forInit = 170
    RULE_forUpdate = 171
    RULE_statementExpressionList = 172
    RULE_enhancedForStatement = 173
    RULE_enhancedForStatementNoShortIf = 174
    RULE_breakStatement = 175
    RULE_continueStatement = 176
    RULE_returnStatement = 177
    RULE_throwStatement = 178
    RULE_synchronizedStatement = 179
    RULE_tryStatement = 180
    RULE_catches = 181
    RULE_catchClause = 182
    RULE_catchFormalParameter = 183
    RULE_catchType = 184
    RULE_finallyBlock = 185
    RULE_tryWithResourcesStatement = 186
    RULE_resourceSpecification = 187
    RULE_resourceList = 188
    RULE_resource = 189
    RULE_variableAccess = 190
    RULE_yieldStatement = 191
    RULE_pattern = 192
    RULE_typePattern = 193
    RULE_expression = 194
    RULE_primary = 195
    RULE_primaryNoNewArray = 196
    RULE_pNNA = 197
    RULE_classLiteral = 198
    RULE_classInstanceCreationExpression = 199
    RULE_unqualifiedClassInstanceCreationExpression = 200
    RULE_classOrInterfaceTypeToInstantiate = 201
    RULE_typeArgumentsOrDiamond = 202
    RULE_arrayCreationExpression = 203
    RULE_arrayCreationExpressionWithoutInitializer = 204
    RULE_arrayCreationExpressionWithInitializer = 205
    RULE_dimExprs = 206
    RULE_dimExpr = 207
    RULE_arrayAccess = 208
    RULE_fieldAccess = 209
    RULE_methodInvocation = 210
    RULE_argumentList = 211
    RULE_methodReference = 212
    RULE_postfixExpression = 213
    RULE_pfE = 214
    RULE_postIncrementExpression = 215
    RULE_postDecrementExpression = 216
    RULE_unaryExpression = 217
    RULE_preIncrementExpression = 218
    RULE_preDecrementExpression = 219
    RULE_unaryExpressionNotPlusMinus = 220
    RULE_castExpression = 221
    RULE_multiplicativeExpression = 222
    RULE_additiveExpression = 223
    RULE_shiftExpression = 224
    RULE_relationalExpression = 225
    RULE_equalityExpression = 226
    RULE_andExpression = 227
    RULE_exclusiveOrExpression = 228
    RULE_inclusiveOrExpression = 229
    RULE_conditionalAndExpression = 230
    RULE_conditionalOrExpression = 231
    RULE_conditionalExpression = 232
    RULE_assignmentExpression = 233
    RULE_assignment = 234
    RULE_leftHandSide = 235
    RULE_assignmentOperator = 236
    RULE_lambdaExpression = 237
    RULE_lambdaParameters = 238
    RULE_lambdaParameterList = 239
    RULE_lambdaParameter = 240
    RULE_lambdaParameterType = 241
    RULE_lambdaBody = 242
    RULE_switchExpression = 243
    RULE_constantExpression = 244

    ruleNames = ["start_", "literal", "typeIdentifier", "unqualifiedMethodIdentifier",
                 "primitiveType", "numericType", "integralType", "floatingPointType",
                 "referenceType", "coit", "classOrInterfaceType", "classType",
                 "interfaceType", "typeVariable", "arrayType", "dims",
                 "typeParameter", "typeParameterModifier", "typeBound",
                 "additionalBound", "typeArguments", "typeArgumentList",
                 "typeArgument", "wildcard", "wildcardBounds", "moduleName",
                 "packageName", "typeName", "packageOrTypeName", "expressionName",
                 "methodName", "ambiguousName", "compilationUnit", "ordinaryCompilationUnit",
                 "modularCompilationUnit", "packageDeclaration", "packageModifier",
                 "importDeclaration", "singleTypeImportDeclaration", "typeImportOnDemandDeclaration",
                 "singleStaticImportDeclaration", "staticImportOnDemandDeclaration",
                 "topLevelClassOrInterfaceDeclaration", "moduleDeclaration",
                 "moduleDirective", "requiresModifier", "classDeclaration",
                 "normalClassDeclaration", "classModifier", "typeParameters",
                 "typeParameterList", "classExtends", "classImplements",
                 "interfaceTypeList", "classPermits", "classBody", "classBodyDeclaration",
                 "classMemberDeclaration", "fieldDeclaration", "fieldModifier",
                 "variableDeclaratorList", "variableDeclarator", "variableDeclaratorId",
                 "variableInitializer", "unannType", "unannPrimitiveType",
                 "unannReferenceType", "unannClassOrInterfaceType", "uCOIT",
                 "unannClassType", "unannInterfaceType", "unannTypeVariable",
                 "unannArrayType", "methodDeclaration", "methodModifier",
                 "methodHeader", "result", "methodDeclarator", "receiverParameter",
                 "formalParameterList", "formalParameter", "variableArityParameter",
                 "variableModifier", "throwsT", "exceptionTypeList", "exceptionType",
                 "methodBody", "instanceInitializer", "staticInitializer",
                 "constructorDeclaration", "constructorModifier", "constructorDeclarator",
                 "simpleTypeName", "constructorBody", "explicitConstructorInvocation",
                 "enumDeclaration", "enumBody", "enumConstantList", "enumConstant",
                 "enumConstantModifier", "enumBodyDeclarations", "recordDeclaration",
                 "recordHeader", "recordComponentList", "recordComponent",
                 "variableArityRecordComponent", "recordComponentModifier",
                 "recordBody", "recordBodyDeclaration", "compactConstructorDeclaration",
                 "interfaceDeclaration", "normalInterfaceDeclaration",
                 "interfaceModifier", "interfaceExtends", "interfacePermits",
                 "interfaceBody", "interfaceMemberDeclaration", "constantDeclaration",
                 "constantModifier", "interfaceMethodDeclaration", "interfaceMethodModifier",
                 "annotationInterfaceDeclaration", "annotationInterfaceBody",
                 "annotationInterfaceMemberDeclaration", "annotationInterfaceElementDeclaration",
                 "annotationInterfaceElementModifier", "defaultValue",
                 "annotation", "normalAnnotation", "elementValuePairList",
                 "elementValuePair", "elementValue", "elementValueArrayInitializer",
                 "elementValueList", "markerAnnotation", "singleElementAnnotation",
                 "arrayInitializer", "variableInitializerList", "block",
                 "blockStatements", "blockStatement", "localClassOrInterfaceDeclaration",
                 "localVariableDeclaration", "localVariableType", "localVariableDeclarationStatement",
                 "statement", "statementNoShortIf", "statementWithoutTrailingSubstatement",
                 "emptyStatement_", "labeledStatement", "labeledStatementNoShortIf",
                 "expressionStatement", "statementExpression", "ifThenStatement",
                 "ifThenElseStatement", "ifThenElseStatementNoShortIf",
                 "assertStatement", "switchStatement", "switchBlock",
                 "switchRule", "switchBlockStatementGroup", "switchLabel",
                 "caseConstant", "whileStatement", "whileStatementNoShortIf",
                 "doStatement", "forStatement", "forStatementNoShortIf",
                 "basicForStatement", "basicForStatementNoShortIf", "forInit",
                 "forUpdate", "statementExpressionList", "enhancedForStatement",
                 "enhancedForStatementNoShortIf", "breakStatement", "continueStatement",
                 "returnStatement", "throwStatement", "synchronizedStatement",
                 "tryStatement", "catches", "catchClause", "catchFormalParameter",
                 "catchType", "finallyBlock", "tryWithResourcesStatement",
                 "resourceSpecification", "resourceList", "resource",
                 "variableAccess", "yieldStatement", "pattern", "typePattern",
                 "expression", "primary", "primaryNoNewArray", "pNNA",
                 "classLiteral", "classInstanceCreationExpression", "unqualifiedClassInstanceCreationExpression",
                 "classOrInterfaceTypeToInstantiate", "typeArgumentsOrDiamond",
                 "arrayCreationExpression", "arrayCreationExpressionWithoutInitializer",
                 "arrayCreationExpressionWithInitializer", "dimExprs",
                 "dimExpr", "arrayAccess", "fieldAccess", "methodInvocation",
                 "argumentList", "methodReference", "postfixExpression",
                 "pfE", "postIncrementExpression", "postDecrementExpression",
                 "unaryExpression", "preIncrementExpression", "preDecrementExpression",
                 "unaryExpressionNotPlusMinus", "castExpression", "multiplicativeExpression",
                 "additiveExpression", "shiftExpression", "relationalExpression",
                 "equalityExpression", "andExpression", "exclusiveOrExpression",
                 "inclusiveOrExpression", "conditionalAndExpression",
                 "conditionalOrExpression", "conditionalExpression", "assignmentExpression",
                 "assignment", "leftHandSide", "assignmentOperator", "lambdaExpression",
                 "lambdaParameters", "lambdaParameterList", "lambdaParameter",
                 "lambdaParameterType", "lambdaBody", "switchExpression",
                 "constantExpression"]

    EOF = Token.EOF
    EXPORTS = 1
    MODULE = 2
    NONSEALED = 3
    OACA = 4
    OPEN = 5
    OPENS = 6
    PERMITS = 7
    PROVIDES = 8
    RECORD = 9
    REQUIRES = 10
    SEALED = 11
    TO = 12
    TRANSITIVE = 13
    USES = 14
    VAR = 15
    WITH = 16
    YIELD = 17
    ABSTRACT = 18
    ASSERT = 19
    BOOLEAN = 20
    BREAK = 21
    BYTE = 22
    CASE = 23
    CATCH = 24
    CHAR = 25
    CLASS = 26
    CONST = 27
    CONTINUE = 28
    DEFAULT = 29
    DO = 30
    DOUBLE = 31
    ELSE = 32
    ENUM = 33
    EXTENDS = 34
    FINAL = 35
    FINALLY = 36
    FLOAT = 37
    FOR = 38
    IF = 39
    GOTO = 40
    IMPLEMENTS = 41
    IMPORT = 42
    INSTANCEOF = 43
    INT = 44
    INTERFACE = 45
    LONG = 46
    NATIVE = 47
    NEW = 48
    PACKAGE = 49
    PRIVATE = 50
    PROTECTED = 51
    PUBLIC = 52
    RETURN = 53
    SHORT = 54
    STATIC = 55
    STRICTFP = 56
    SUPER = 57
    SWITCH = 58
    SYNCHRONIZED = 59
    THIS = 60
    THROW = 61
    THROWS = 62
    TRANSIENT = 63
    TRY = 64
    VOID = 65
    VOLATILE = 66
    WHILE = 67
    UNDER_SCORE = 68
    IntegerLiteral = 69
    FloatingPointLiteral = 70
    BooleanLiteral = 71
    CharacterLiteral = 72
    StringLiteral = 73
    TextBlock = 74
    NullLiteral = 75
    LPAREN = 76
    RPAREN = 77
    LBRACE = 78
    RBRACE = 79
    LBRACK = 80
    RBRACK = 81
    SEMI = 82
    COMMA = 83
    DOT = 84
    ELLIPSIS = 85
    AT = 86
    COLONCOLON = 87
    ASSIGN = 88
    GT = 89
    LT = 90
    BANG = 91
    TILDE = 92
    QUESTION = 93
    COLON = 94
    ARROW = 95
    EQUAL = 96
    LE = 97
    GE = 98
    NOTEQUAL = 99
    AND = 100
    OR = 101
    INC = 102
    DEC = 103
    ADD = 104
    SUB = 105
    MUL = 106
    DIV = 107
    BITAND = 108
    BITOR = 109
    CARET = 110
    MOD = 111
    ADD_ASSIGN = 112
    SUB_ASSIGN = 113
    MUL_ASSIGN = 114
    DIV_ASSIGN = 115
    AND_ASSIGN = 116
    OR_ASSIGN = 117
    XOR_ASSIGN = 118
    MOD_ASSIGN = 119
    LSHIFT_ASSIGN = 120
    RSHIFT_ASSIGN = 121
    URSHIFT_ASSIGN = 122
    Identifier = 123
    WS = 124
    COMMENT = 125
    LINE_COMMENT = 126

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class Start_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compilationUnit(self):
            return self.getTypedRuleContext(Java20Parser.CompilationUnitContext, 0)

        def EOF(self):
            return self.getToken(Java20Parser.EOF, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_start_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStart_"):
                listener.enterStart_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStart_"):
                listener.exitStart_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStart_"):
                return visitor.visitStart_(self)
            else:
                return visitor.visitChildren(self)

    def start_(self):

        localctx = Java20Parser.Start_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.compilationUnit()
            self.state = 491
            self.match(Java20Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IntegerLiteral(self):
            return self.getToken(Java20Parser.IntegerLiteral, 0)

        def FloatingPointLiteral(self):
            return self.getToken(Java20Parser.FloatingPointLiteral, 0)

        def BooleanLiteral(self):
            return self.getToken(Java20Parser.BooleanLiteral, 0)

        def CharacterLiteral(self):
            return self.getToken(Java20Parser.CharacterLiteral, 0)

        def StringLiteral(self):
            return self.getToken(Java20Parser.StringLiteral, 0)

        def TextBlock(self):
            return self.getToken(Java20Parser.TextBlock, 0)

        def NullLiteral(self):
            return self.getToken(Java20Parser.NullLiteral, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):

        localctx = Java20Parser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            _la = self._input.LA(1)
            if not (((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeIdentifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeIdentifier"):
                listener.enterTypeIdentifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeIdentifier"):
                listener.exitTypeIdentifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeIdentifier"):
                return visitor.visitTypeIdentifier(self)
            else:
                return visitor.visitChildren(self)

    def typeIdentifier(self):

        localctx = Java20Parser.TypeIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_typeIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 495
            self.match(Java20Parser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnqualifiedMethodIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unqualifiedMethodIdentifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnqualifiedMethodIdentifier"):
                listener.enterUnqualifiedMethodIdentifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnqualifiedMethodIdentifier"):
                listener.exitUnqualifiedMethodIdentifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnqualifiedMethodIdentifier"):
                return visitor.visitUnqualifiedMethodIdentifier(self)
            else:
                return visitor.visitChildren(self)

    def unqualifiedMethodIdentifier(self):

        localctx = Java20Parser.UnqualifiedMethodIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_unqualifiedMethodIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            self.match(Java20Parser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimitiveTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericType(self):
            return self.getTypedRuleContext(Java20Parser.NumericTypeContext, 0)

        def BOOLEAN(self):
            return self.getToken(Java20Parser.BOOLEAN, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_primitiveType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimitiveType"):
                listener.enterPrimitiveType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimitiveType"):
                listener.exitPrimitiveType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimitiveType"):
                return visitor.visitPrimitiveType(self)
            else:
                return visitor.visitChildren(self)

    def primitiveType(self):

        localctx = Java20Parser.PrimitiveTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_primitiveType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 499
                self.annotation()
                self.state = 504
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 507
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22, 25, 31, 37, 44, 46, 54]:
                self.state = 505
                self.numericType()
                pass
            elif token in [20]:
                self.state = 506
                self.match(Java20Parser.BOOLEAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integralType(self):
            return self.getTypedRuleContext(Java20Parser.IntegralTypeContext, 0)

        def floatingPointType(self):
            return self.getTypedRuleContext(Java20Parser.FloatingPointTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_numericType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumericType"):
                listener.enterNumericType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumericType"):
                listener.exitNumericType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumericType"):
                return visitor.visitNumericType(self)
            else:
                return visitor.visitChildren(self)

    def numericType(self):

        localctx = Java20Parser.NumericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_numericType)
        try:
            self.state = 511
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22, 25, 44, 46, 54]:
                self.enterOuterAlt(localctx, 1)
                self.state = 509
                self.integralType()
                pass
            elif token in [31, 37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 510
                self.floatingPointType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegralTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BYTE(self):
            return self.getToken(Java20Parser.BYTE, 0)

        def SHORT(self):
            return self.getToken(Java20Parser.SHORT, 0)

        def INT(self):
            return self.getToken(Java20Parser.INT, 0)

        def LONG(self):
            return self.getToken(Java20Parser.LONG, 0)

        def CHAR(self):
            return self.getToken(Java20Parser.CHAR, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_integralType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIntegralType"):
                listener.enterIntegralType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIntegralType"):
                listener.exitIntegralType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIntegralType"):
                return visitor.visitIntegralType(self)
            else:
                return visitor.visitChildren(self)

    def integralType(self):

        localctx = Java20Parser.IntegralTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_integralType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 513
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 18102359477452800) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FloatingPointTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOAT(self):
            return self.getToken(Java20Parser.FLOAT, 0)

        def DOUBLE(self):
            return self.getToken(Java20Parser.DOUBLE, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_floatingPointType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloatingPointType"):
                listener.enterFloatingPointType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloatingPointType"):
                listener.exitFloatingPointType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFloatingPointType"):
                return visitor.visitFloatingPointType(self)
            else:
                return visitor.visitChildren(self)

    def floatingPointType(self):

        localctx = Java20Parser.FloatingPointTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_floatingPointType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            _la = self._input.LA(1)
            if not (_la == 31 or _la == 37):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReferenceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.ClassOrInterfaceTypeContext, 0)

        def typeVariable(self):
            return self.getTypedRuleContext(Java20Parser.TypeVariableContext, 0)

        def arrayType(self):
            return self.getTypedRuleContext(Java20Parser.ArrayTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_referenceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReferenceType"):
                listener.enterReferenceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReferenceType"):
                listener.exitReferenceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReferenceType"):
                return visitor.visitReferenceType(self)
            else:
                return visitor.visitChildren(self)

    def referenceType(self):

        localctx = Java20Parser.ReferenceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_referenceType)
        try:
            self.state = 520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 3, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 517
                self.classOrInterfaceType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 518
                self.typeVariable()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 519
                self.arrayType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CoitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def coit(self):
            return self.getTypedRuleContext(Java20Parser.CoitContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_coit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCoit"):
                listener.enterCoit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCoit"):
                listener.exitCoit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCoit"):
                return visitor.visitCoit(self)
            else:
                return visitor.visitChildren(self)

    def coit(self):

        localctx = Java20Parser.CoitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_coit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.match(Java20Parser.DOT)
            self.state = 526
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 523
                self.annotation()
                self.state = 528
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 529
            self.typeIdentifier()
            self.state = 531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 5, self._ctx)
            if la_ == 1:
                self.state = 530
                self.typeArguments()

            self.state = 534
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 6, self._ctx)
            if la_ == 1:
                self.state = 533
                self.coit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassOrInterfaceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def coit(self):
            return self.getTypedRuleContext(Java20Parser.CoitContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classOrInterfaceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassOrInterfaceType"):
                listener.enterClassOrInterfaceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassOrInterfaceType"):
                listener.exitClassOrInterfaceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassOrInterfaceType"):
                return visitor.visitClassOrInterfaceType(self)
            else:
                return visitor.visitChildren(self)

    def classOrInterfaceType(self):

        localctx = Java20Parser.ClassOrInterfaceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_classOrInterfaceType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 7, self._ctx)
            if la_ == 1:
                self.state = 536
                self.packageName()
                self.state = 537
                self.match(Java20Parser.DOT)

            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 541
                self.annotation()
                self.state = 546
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 547
            self.typeIdentifier()
            self.state = 549
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 9, self._ctx)
            if la_ == 1:
                self.state = 548
                self.typeArguments()

            self.state = 552
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 10, self._ctx)
            if la_ == 1:
                self.state = 551
                self.coit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def classOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.ClassOrInterfaceTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassType"):
                listener.enterClassType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassType"):
                listener.exitClassType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassType"):
                return visitor.visitClassType(self)
            else:
                return visitor.visitChildren(self)

    def classType(self):

        localctx = Java20Parser.ClassTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_classType)
        self._la = 0  # Token type
        try:
            self.state = 588
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 17, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 554
                    self.annotation()
                    self.state = 559
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 560
                self.typeIdentifier()
                self.state = 562
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 561
                    self.typeArguments()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 564
                self.packageName()
                self.state = 565
                self.match(Java20Parser.DOT)
                self.state = 569
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 566
                    self.annotation()
                    self.state = 571
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 572
                self.typeIdentifier()
                self.state = 574
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 573
                    self.typeArguments()

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 576
                self.classOrInterfaceType()
                self.state = 577
                self.match(Java20Parser.DOT)
                self.state = 581
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 578
                    self.annotation()
                    self.state = 583
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 584
                self.typeIdentifier()
                self.state = 586
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 585
                    self.typeArguments()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceType"):
                listener.enterInterfaceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceType"):
                listener.exitInterfaceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceType"):
                return visitor.visitInterfaceType(self)
            else:
                return visitor.visitChildren(self)

    def interfaceType(self):

        localctx = Java20Parser.InterfaceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_interfaceType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 590
            self.classType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeVariable

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeVariable"):
                listener.enterTypeVariable(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeVariable"):
                listener.exitTypeVariable(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeVariable"):
                return visitor.visitTypeVariable(self)
            else:
                return visitor.visitChildren(self)

    def typeVariable(self):

        localctx = Java20Parser.TypeVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_typeVariable)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 595
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 592
                self.annotation()
                self.state = 597
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 598
            self.typeIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primitiveType(self):
            return self.getTypedRuleContext(Java20Parser.PrimitiveTypeContext, 0)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def typeVariable(self):
            return self.getTypedRuleContext(Java20Parser.TypeVariableContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayType"):
                listener.enterArrayType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayType"):
                listener.exitArrayType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayType"):
                return visitor.visitArrayType(self)
            else:
                return visitor.visitChildren(self)

    def arrayType(self):

        localctx = Java20Parser.ArrayTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_arrayType)
        try:
            self.state = 609
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 19, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 600
                self.primitiveType()
                self.state = 601
                self.dims()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                self.classType()
                self.state = 604
                self.dims()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 606
                self.typeVariable()
                self.state = 607
                self.dims()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.LBRACK)
            else:
                return self.getToken(Java20Parser.LBRACK, i)

        def RBRACK(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.RBRACK)
            else:
                return self.getToken(Java20Parser.RBRACK, i)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_dims

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDims"):
                listener.enterDims(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDims"):
                listener.exitDims(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDims"):
                return visitor.visitDims(self)
            else:
                return visitor.visitChildren(self)

    def dims(self):

        localctx = Java20Parser.DimsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_dims)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 614
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 611
                self.annotation()
                self.state = 616
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 617
            self.match(Java20Parser.LBRACK)
            self.state = 618
            self.match(Java20Parser.RBRACK)
            self.state = 629
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 22, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 622
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == 86:
                        self.state = 619
                        self.annotation()
                        self.state = 624
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 625
                    self.match(Java20Parser.LBRACK)
                    self.state = 626
                    self.match(Java20Parser.RBRACK)
                self.state = 631
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 22, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def typeParameterModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeParameterModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeParameterModifierContext, i)

        def typeBound(self):
            return self.getTypedRuleContext(Java20Parser.TypeBoundContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeParameter"):
                listener.enterTypeParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeParameter"):
                listener.exitTypeParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeParameter"):
                return visitor.visitTypeParameter(self)
            else:
                return visitor.visitChildren(self)

    def typeParameter(self):

        localctx = Java20Parser.TypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_typeParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 632
                self.typeParameterModifier()
                self.state = 637
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 638
            self.typeIdentifier()
            self.state = 640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 34:
                self.state = 639
                self.typeBound()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeParameterModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeParameterModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeParameterModifier"):
                listener.enterTypeParameterModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeParameterModifier"):
                listener.exitTypeParameterModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeParameterModifier"):
                return visitor.visitTypeParameterModifier(self)
            else:
                return visitor.visitChildren(self)

    def typeParameterModifier(self):

        localctx = Java20Parser.TypeParameterModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_typeParameterModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self.annotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeBoundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(Java20Parser.EXTENDS, 0)

        def typeVariable(self):
            return self.getTypedRuleContext(Java20Parser.TypeVariableContext, 0)

        def classOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.ClassOrInterfaceTypeContext, 0)

        def additionalBound(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AdditionalBoundContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AdditionalBoundContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeBound

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeBound"):
                listener.enterTypeBound(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeBound"):
                listener.exitTypeBound(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeBound"):
                return visitor.visitTypeBound(self)
            else:
                return visitor.visitChildren(self)

    def typeBound(self):

        localctx = Java20Parser.TypeBoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_typeBound)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            self.match(Java20Parser.EXTENDS)
            self.state = 653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 26, self._ctx)
            if la_ == 1:
                self.state = 645
                self.typeVariable()
                pass

            elif la_ == 2:
                self.state = 646
                self.classOrInterfaceType()
                self.state = 650
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 108:
                    self.state = 647
                    self.additionalBound()
                    self.state = 652
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AdditionalBoundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BITAND(self):
            return self.getToken(Java20Parser.BITAND, 0)

        def interfaceType(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_additionalBound

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditionalBound"):
                listener.enterAdditionalBound(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditionalBound"):
                listener.exitAdditionalBound(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditionalBound"):
                return visitor.visitAdditionalBound(self)
            else:
                return visitor.visitChildren(self)

    def additionalBound(self):

        localctx = Java20Parser.AdditionalBoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_additionalBound)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.match(Java20Parser.BITAND)
            self.state = 656
            self.interfaceType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(Java20Parser.LT, 0)

        def typeArgumentList(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentListContext, 0)

        def GT(self):
            return self.getToken(Java20Parser.GT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeArguments

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeArguments"):
                listener.enterTypeArguments(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeArguments"):
                listener.exitTypeArguments(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeArguments"):
                return visitor.visitTypeArguments(self)
            else:
                return visitor.visitChildren(self)

    def typeArguments(self):

        localctx = Java20Parser.TypeArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_typeArguments)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self.match(Java20Parser.LT)
            self.state = 659
            self.typeArgumentList()
            self.state = 660
            self.match(Java20Parser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeArgument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeArgumentContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeArgumentContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeArgumentList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeArgumentList"):
                listener.enterTypeArgumentList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeArgumentList"):
                listener.exitTypeArgumentList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeArgumentList"):
                return visitor.visitTypeArgumentList(self)
            else:
                return visitor.visitChildren(self)

    def typeArgumentList(self):

        localctx = Java20Parser.TypeArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_typeArgumentList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self.typeArgument()
            self.state = 667
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 663
                self.match(Java20Parser.COMMA)
                self.state = 664
                self.typeArgument()
                self.state = 669
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def wildcard(self):
            return self.getTypedRuleContext(Java20Parser.WildcardContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeArgument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeArgument"):
                listener.enterTypeArgument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeArgument"):
                listener.exitTypeArgument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeArgument"):
                return visitor.visitTypeArgument(self)
            else:
                return visitor.visitChildren(self)

    def typeArgument(self):

        localctx = Java20Parser.TypeArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_typeArgument)
        try:
            self.state = 672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 28, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 670
                self.referenceType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 671
                self.wildcard()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WildcardContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUESTION(self):
            return self.getToken(Java20Parser.QUESTION, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def wildcardBounds(self):
            return self.getTypedRuleContext(Java20Parser.WildcardBoundsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_wildcard

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWildcard"):
                listener.enterWildcard(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWildcard"):
                listener.exitWildcard(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWildcard"):
                return visitor.visitWildcard(self)
            else:
                return visitor.visitChildren(self)

    def wildcard(self):

        localctx = Java20Parser.WildcardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_wildcard)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 674
                self.annotation()
                self.state = 679
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 680
            self.match(Java20Parser.QUESTION)
            self.state = 682
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 34 or _la == 57:
                self.state = 681
                self.wildcardBounds()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WildcardBoundsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(Java20Parser.EXTENDS, 0)

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_wildcardBounds

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWildcardBounds"):
                listener.enterWildcardBounds(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWildcardBounds"):
                listener.exitWildcardBounds(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWildcardBounds"):
                return visitor.visitWildcardBounds(self)
            else:
                return visitor.visitChildren(self)

    def wildcardBounds(self):

        localctx = Java20Parser.WildcardBoundsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_wildcardBounds)
        try:
            self.state = 688
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 684
                self.match(Java20Parser.EXTENDS)
                self.state = 685
                self.referenceType()
                pass
            elif token in [57]:
                self.enterOuterAlt(localctx, 2)
                self.state = 686
                self.match(Java20Parser.SUPER)
                self.state = 687
                self.referenceType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModuleNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def moduleName(self):
            return self.getTypedRuleContext(Java20Parser.ModuleNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_moduleName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModuleName"):
                listener.enterModuleName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModuleName"):
                listener.exitModuleName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModuleName"):
                return visitor.visitModuleName(self)
            else:
                return visitor.visitChildren(self)

    def moduleName(self):

        localctx = Java20Parser.ModuleNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_moduleName)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 690
            self.match(Java20Parser.Identifier)
            self.state = 693
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 84:
                self.state = 691
                self.match(Java20Parser.DOT)
                self.state = 692
                self.moduleName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PackageNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_packageName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPackageName"):
                listener.enterPackageName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPackageName"):
                listener.exitPackageName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPackageName"):
                return visitor.visitPackageName(self)
            else:
                return visitor.visitChildren(self)

    def packageName(self):

        localctx = Java20Parser.PackageNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_packageName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 695
            self.match(Java20Parser.Identifier)
            self.state = 698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 33, self._ctx)
            if la_ == 1:
                self.state = 696
                self.match(Java20Parser.DOT)
                self.state = 697
                self.packageName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeName"):
                listener.enterTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeName"):
                listener.exitTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeName"):
                return visitor.visitTypeName(self)
            else:
                return visitor.visitChildren(self)

    def typeName(self):

        localctx = Java20Parser.TypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_typeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.packageName()
            self.state = 703
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 34, self._ctx)
            if la_ == 1:
                self.state = 701
                self.match(Java20Parser.DOT)
                self.state = 702
                self.typeIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PackageOrTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def packageOrTypeName(self):
            return self.getTypedRuleContext(Java20Parser.PackageOrTypeNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_packageOrTypeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPackageOrTypeName"):
                listener.enterPackageOrTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPackageOrTypeName"):
                listener.exitPackageOrTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPackageOrTypeName"):
                return visitor.visitPackageOrTypeName(self)
            else:
                return visitor.visitChildren(self)

    def packageOrTypeName(self):

        localctx = Java20Parser.PackageOrTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_packageOrTypeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.match(Java20Parser.Identifier)
            self.state = 708
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 35, self._ctx)
            if la_ == 1:
                self.state = 706
                self.match(Java20Parser.DOT)
                self.state = 707
                self.packageOrTypeName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def ambiguousName(self):
            return self.getTypedRuleContext(Java20Parser.AmbiguousNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_expressionName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpressionName"):
                listener.enterExpressionName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpressionName"):
                listener.exitExpressionName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpressionName"):
                return visitor.visitExpressionName(self)
            else:
                return visitor.visitChildren(self)

    def expressionName(self):

        localctx = Java20Parser.ExpressionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_expressionName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 36, self._ctx)
            if la_ == 1:
                self.state = 710
                self.ambiguousName()
                self.state = 711
                self.match(Java20Parser.DOT)

            self.state = 715
            self.match(Java20Parser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unqualifiedMethodIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.UnqualifiedMethodIdentifierContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodName"):
                listener.enterMethodName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodName"):
                listener.exitMethodName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodName"):
                return visitor.visitMethodName(self)
            else:
                return visitor.visitChildren(self)

    def methodName(self):

        localctx = Java20Parser.MethodNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_methodName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.unqualifiedMethodIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AmbiguousNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def ambiguousName(self):
            return self.getTypedRuleContext(Java20Parser.AmbiguousNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_ambiguousName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAmbiguousName"):
                listener.enterAmbiguousName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAmbiguousName"):
                listener.exitAmbiguousName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAmbiguousName"):
                return visitor.visitAmbiguousName(self)
            else:
                return visitor.visitChildren(self)

    def ambiguousName(self):

        localctx = Java20Parser.AmbiguousNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_ambiguousName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.match(Java20Parser.Identifier)
            self.state = 722
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 37, self._ctx)
            if la_ == 1:
                self.state = 720
                self.match(Java20Parser.DOT)
                self.state = 721
                self.ambiguousName()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompilationUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ordinaryCompilationUnit(self):
            return self.getTypedRuleContext(Java20Parser.OrdinaryCompilationUnitContext, 0)

        def modularCompilationUnit(self):
            return self.getTypedRuleContext(Java20Parser.ModularCompilationUnitContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_compilationUnit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompilationUnit"):
                listener.enterCompilationUnit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompilationUnit"):
                listener.exitCompilationUnit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompilationUnit"):
                return visitor.visitCompilationUnit(self)
            else:
                return visitor.visitChildren(self)

    def compilationUnit(self):

        localctx = Java20Parser.CompilationUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_compilationUnit)
        try:
            self.state = 726
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 38, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 724
                self.ordinaryCompilationUnit()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 725
                self.modularCompilationUnit()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrdinaryCompilationUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def packageDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.PackageDeclarationContext, 0)

        def importDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ImportDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ImportDeclarationContext, i)

        def topLevelClassOrInterfaceDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TopLevelClassOrInterfaceDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TopLevelClassOrInterfaceDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_ordinaryCompilationUnit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrdinaryCompilationUnit"):
                listener.enterOrdinaryCompilationUnit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrdinaryCompilationUnit"):
                listener.exitOrdinaryCompilationUnit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrdinaryCompilationUnit"):
                return visitor.visitOrdinaryCompilationUnit(self)
            else:
                return visitor.visitChildren(self)

    def ordinaryCompilationUnit(self):

        localctx = Java20Parser.OrdinaryCompilationUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_ordinaryCompilationUnit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 729
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 39, self._ctx)
            if la_ == 1:
                self.state = 728
                self.packageDeclaration()

            self.state = 734
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 42:
                self.state = 731
                self.importDeclaration()
                self.state = 736
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 740
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 116002917793925640) != 0) or _la == 82 or _la == 86:
                self.state = 737
                self.topLevelClassOrInterfaceDeclaration()
                self.state = 742
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModularCompilationUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def moduleDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ModuleDeclarationContext, 0)

        def importDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ImportDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ImportDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_modularCompilationUnit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModularCompilationUnit"):
                listener.enterModularCompilationUnit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModularCompilationUnit"):
                listener.exitModularCompilationUnit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModularCompilationUnit"):
                return visitor.visitModularCompilationUnit(self)
            else:
                return visitor.visitChildren(self)

    def modularCompilationUnit(self):

        localctx = Java20Parser.ModularCompilationUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_modularCompilationUnit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 42:
                self.state = 743
                self.importDeclaration()
                self.state = 748
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 749
            self.moduleDeclaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PackageDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PACKAGE(self):
            return self.getToken(Java20Parser.PACKAGE, 0)

        def Identifier(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.Identifier)
            else:
                return self.getToken(Java20Parser.Identifier, i)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def packageModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.PackageModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.PackageModifierContext, i)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_packageDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPackageDeclaration"):
                listener.enterPackageDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPackageDeclaration"):
                listener.exitPackageDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPackageDeclaration"):
                return visitor.visitPackageDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def packageDeclaration(self):

        localctx = Java20Parser.PackageDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_packageDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 751
                self.packageModifier()
                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 757
            self.match(Java20Parser.PACKAGE)
            self.state = 758
            self.match(Java20Parser.Identifier)
            self.state = 763
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 84:
                self.state = 759
                self.match(Java20Parser.DOT)
                self.state = 760
                self.match(Java20Parser.Identifier)
                self.state = 765
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 766
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PackageModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_packageModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPackageModifier"):
                listener.enterPackageModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPackageModifier"):
                listener.exitPackageModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPackageModifier"):
                return visitor.visitPackageModifier(self)
            else:
                return visitor.visitChildren(self)

    def packageModifier(self):

        localctx = Java20Parser.PackageModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_packageModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 768
            self.annotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImportDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleTypeImportDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.SingleTypeImportDeclarationContext, 0)

        def typeImportOnDemandDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.TypeImportOnDemandDeclarationContext, 0)

        def singleStaticImportDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.SingleStaticImportDeclarationContext, 0)

        def staticImportOnDemandDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.StaticImportOnDemandDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_importDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterImportDeclaration"):
                listener.enterImportDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitImportDeclaration"):
                listener.exitImportDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitImportDeclaration"):
                return visitor.visitImportDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def importDeclaration(self):

        localctx = Java20Parser.ImportDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_importDeclaration)
        try:
            self.state = 774
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 45, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 770
                self.singleTypeImportDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 771
                self.typeImportOnDemandDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 772
                self.singleStaticImportDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 773
                self.staticImportOnDemandDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleTypeImportDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(Java20Parser.IMPORT, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_singleTypeImportDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingleTypeImportDeclaration"):
                listener.enterSingleTypeImportDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingleTypeImportDeclaration"):
                listener.exitSingleTypeImportDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingleTypeImportDeclaration"):
                return visitor.visitSingleTypeImportDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def singleTypeImportDeclaration(self):

        localctx = Java20Parser.SingleTypeImportDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_singleTypeImportDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 776
            self.match(Java20Parser.IMPORT)
            self.state = 777
            self.typeName()
            self.state = 778
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeImportOnDemandDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(Java20Parser.IMPORT, 0)

        def packageOrTypeName(self):
            return self.getTypedRuleContext(Java20Parser.PackageOrTypeNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def MUL(self):
            return self.getToken(Java20Parser.MUL, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeImportOnDemandDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeImportOnDemandDeclaration"):
                listener.enterTypeImportOnDemandDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeImportOnDemandDeclaration"):
                listener.exitTypeImportOnDemandDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeImportOnDemandDeclaration"):
                return visitor.visitTypeImportOnDemandDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def typeImportOnDemandDeclaration(self):

        localctx = Java20Parser.TypeImportOnDemandDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_typeImportOnDemandDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(Java20Parser.IMPORT)
            self.state = 781
            self.packageOrTypeName()
            self.state = 782
            self.match(Java20Parser.DOT)
            self.state = 783
            self.match(Java20Parser.MUL)
            self.state = 784
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleStaticImportDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(Java20Parser.IMPORT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_singleStaticImportDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingleStaticImportDeclaration"):
                listener.enterSingleStaticImportDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingleStaticImportDeclaration"):
                listener.exitSingleStaticImportDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingleStaticImportDeclaration"):
                return visitor.visitSingleStaticImportDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def singleStaticImportDeclaration(self):

        localctx = Java20Parser.SingleStaticImportDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_singleStaticImportDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 786
            self.match(Java20Parser.IMPORT)
            self.state = 787
            self.match(Java20Parser.STATIC)
            self.state = 788
            self.typeName()
            self.state = 789
            self.match(Java20Parser.DOT)
            self.state = 790
            self.match(Java20Parser.Identifier)
            self.state = 791
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StaticImportOnDemandDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(Java20Parser.IMPORT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def MUL(self):
            return self.getToken(Java20Parser.MUL, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_staticImportOnDemandDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStaticImportOnDemandDeclaration"):
                listener.enterStaticImportOnDemandDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStaticImportOnDemandDeclaration"):
                listener.exitStaticImportOnDemandDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStaticImportOnDemandDeclaration"):
                return visitor.visitStaticImportOnDemandDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def staticImportOnDemandDeclaration(self):

        localctx = Java20Parser.StaticImportOnDemandDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_staticImportOnDemandDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.match(Java20Parser.IMPORT)
            self.state = 794
            self.match(Java20Parser.STATIC)
            self.state = 795
            self.typeName()
            self.state = 796
            self.match(Java20Parser.DOT)
            self.state = 797
            self.match(Java20Parser.MUL)
            self.state = 798
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TopLevelClassOrInterfaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassDeclarationContext, 0)

        def interfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceDeclarationContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_topLevelClassOrInterfaceDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTopLevelClassOrInterfaceDeclaration"):
                listener.enterTopLevelClassOrInterfaceDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTopLevelClassOrInterfaceDeclaration"):
                listener.exitTopLevelClassOrInterfaceDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTopLevelClassOrInterfaceDeclaration"):
                return visitor.visitTopLevelClassOrInterfaceDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def topLevelClassOrInterfaceDeclaration(self):

        localctx = Java20Parser.TopLevelClassOrInterfaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_topLevelClassOrInterfaceDeclaration)
        try:
            self.state = 803
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 46, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 800
                self.classDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 801
                self.interfaceDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 802
                self.match(Java20Parser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModuleDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODULE(self):
            return self.getToken(Java20Parser.MODULE, 0)

        def Identifier(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.Identifier)
            else:
                return self.getToken(Java20Parser.Identifier, i)

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def OPEN(self):
            return self.getToken(Java20Parser.OPEN, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def moduleDirective(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ModuleDirectiveContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ModuleDirectiveContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_moduleDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModuleDeclaration"):
                listener.enterModuleDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModuleDeclaration"):
                listener.exitModuleDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModuleDeclaration"):
                return visitor.visitModuleDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def moduleDeclaration(self):

        localctx = Java20Parser.ModuleDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_moduleDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 808
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 805
                self.annotation()
                self.state = 810
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 812
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 5:
                self.state = 811
                self.match(Java20Parser.OPEN)

            self.state = 814
            self.match(Java20Parser.MODULE)
            self.state = 815
            self.match(Java20Parser.Identifier)
            self.state = 820
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 84:
                self.state = 816
                self.match(Java20Parser.DOT)
                self.state = 817
                self.match(Java20Parser.Identifier)
                self.state = 822
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 823
            self.match(Java20Parser.LBRACE)
            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 17730) != 0):
                self.state = 824
                self.moduleDirective()
                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 830
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModuleDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRES(self):
            return self.getToken(Java20Parser.REQUIRES, 0)

        def moduleName(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ModuleNameContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ModuleNameContext, i)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def requiresModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.RequiresModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.RequiresModifierContext, i)

        def EXPORTS(self):
            return self.getToken(Java20Parser.EXPORTS, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def TO(self):
            return self.getToken(Java20Parser.TO, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def OPENS(self):
            return self.getToken(Java20Parser.OPENS, 0)

        def USES(self):
            return self.getToken(Java20Parser.USES, 0)

        def typeName(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeNameContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeNameContext, i)

        def PROVIDES(self):
            return self.getToken(Java20Parser.PROVIDES, 0)

        def WITH(self):
            return self.getToken(Java20Parser.WITH, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_moduleDirective

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModuleDirective"):
                listener.enterModuleDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModuleDirective"):
                listener.exitModuleDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModuleDirective"):
                return visitor.visitModuleDirective(self)
            else:
                return visitor.visitChildren(self)

    def moduleDirective(self):

        localctx = Java20Parser.ModuleDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_moduleDirective)
        self._la = 0  # Token type
        try:
            self.state = 889
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [10]:
                self.enterOuterAlt(localctx, 1)
                self.state = 832
                self.match(Java20Parser.REQUIRES)
                self.state = 836
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 13 or _la == 55:
                    self.state = 833
                    self.requiresModifier()
                    self.state = 838
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 839
                self.moduleName()
                self.state = 840
                self.match(Java20Parser.SEMI)
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 2)
                self.state = 842
                self.match(Java20Parser.EXPORTS)
                self.state = 843
                self.packageName()
                self.state = 853
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 12:
                    self.state = 844
                    self.match(Java20Parser.TO)
                    self.state = 845
                    self.moduleName()
                    self.state = 850
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == 83:
                        self.state = 846
                        self.match(Java20Parser.COMMA)
                        self.state = 847
                        self.moduleName()
                        self.state = 852
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                self.state = 855
                self.match(Java20Parser.SEMI)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 857
                self.match(Java20Parser.OPENS)
                self.state = 858
                self.packageName()
                self.state = 868
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 12:
                    self.state = 859
                    self.match(Java20Parser.TO)
                    self.state = 860
                    self.moduleName()
                    self.state = 865
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == 83:
                        self.state = 861
                        self.match(Java20Parser.COMMA)
                        self.state = 862
                        self.moduleName()
                        self.state = 867
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                self.state = 870
                self.match(Java20Parser.SEMI)
                pass
            elif token in [14]:
                self.enterOuterAlt(localctx, 4)
                self.state = 872
                self.match(Java20Parser.USES)
                self.state = 873
                self.typeName()
                self.state = 874
                self.match(Java20Parser.SEMI)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 876
                self.match(Java20Parser.PROVIDES)
                self.state = 877
                self.typeName()
                self.state = 878
                self.match(Java20Parser.WITH)
                self.state = 879
                self.typeName()
                self.state = 884
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 83:
                    self.state = 880
                    self.match(Java20Parser.COMMA)
                    self.state = 881
                    self.typeName()
                    self.state = 886
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 887
                self.match(Java20Parser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RequiresModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRANSITIVE(self):
            return self.getToken(Java20Parser.TRANSITIVE, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_requiresModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRequiresModifier"):
                listener.enterRequiresModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRequiresModifier"):
                listener.exitRequiresModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRequiresModifier"):
                return visitor.visitRequiresModifier(self)
            else:
                return visitor.visitChildren(self)

    def requiresModifier(self):

        localctx = Java20Parser.RequiresModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_requiresModifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 891
            _la = self._input.LA(1)
            if not (_la == 13 or _la == 55):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def normalClassDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.NormalClassDeclarationContext, 0)

        def enumDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.EnumDeclarationContext, 0)

        def recordDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.RecordDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassDeclaration"):
                listener.enterClassDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassDeclaration"):
                listener.exitClassDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassDeclaration"):
                return visitor.visitClassDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def classDeclaration(self):

        localctx = Java20Parser.ClassDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_classDeclaration)
        try:
            self.state = 896
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 58, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 893
                self.normalClassDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 894
                self.enumDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 895
                self.recordDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NormalClassDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(Java20Parser.CLASS, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def classBody(self):
            return self.getTypedRuleContext(Java20Parser.ClassBodyContext, 0)

        def classModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassModifierContext, i)

        def typeParameters(self):
            return self.getTypedRuleContext(Java20Parser.TypeParametersContext, 0)

        def classExtends(self):
            return self.getTypedRuleContext(Java20Parser.ClassExtendsContext, 0)

        def classImplements(self):
            return self.getTypedRuleContext(Java20Parser.ClassImplementsContext, 0)

        def classPermits(self):
            return self.getTypedRuleContext(Java20Parser.ClassPermitsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_normalClassDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNormalClassDeclaration"):
                listener.enterNormalClassDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNormalClassDeclaration"):
                listener.exitNormalClassDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNormalClassDeclaration"):
                return visitor.visitNormalClassDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def normalClassDeclaration(self):

        localctx = Java20Parser.NormalClassDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_normalClassDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 901
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 115967724764792840) != 0) or _la == 86:
                self.state = 898
                self.classModifier()
                self.state = 903
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 904
            self.match(Java20Parser.CLASS)
            self.state = 905
            self.typeIdentifier()
            self.state = 907
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 906
                self.typeParameters()

            self.state = 910
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 34:
                self.state = 909
                self.classExtends()

            self.state = 913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 41:
                self.state = 912
                self.classImplements()

            self.state = 916
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 7:
                self.state = 915
                self.classPermits()

            self.state = 918
            self.classBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(Java20Parser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def ABSTRACT(self):
            return self.getToken(Java20Parser.ABSTRACT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def FINAL(self):
            return self.getToken(Java20Parser.FINAL, 0)

        def SEALED(self):
            return self.getToken(Java20Parser.SEALED, 0)

        def NONSEALED(self):
            return self.getToken(Java20Parser.NONSEALED, 0)

        def STRICTFP(self):
            return self.getToken(Java20Parser.STRICTFP, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassModifier"):
                listener.enterClassModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassModifier"):
                listener.exitClassModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassModifier"):
                return visitor.visitClassModifier(self)
            else:
                return visitor.visitChildren(self)

    def classModifier(self):

        localctx = Java20Parser.ClassModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_classModifier)
        try:
            self.state = 930
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 920
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 921
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 922
                self.match(Java20Parser.PROTECTED)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 4)
                self.state = 923
                self.match(Java20Parser.PRIVATE)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 5)
                self.state = 924
                self.match(Java20Parser.ABSTRACT)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 6)
                self.state = 925
                self.match(Java20Parser.STATIC)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 7)
                self.state = 926
                self.match(Java20Parser.FINAL)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 8)
                self.state = 927
                self.match(Java20Parser.SEALED)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 9)
                self.state = 928
                self.match(Java20Parser.NONSEALED)
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 10)
                self.state = 929
                self.match(Java20Parser.STRICTFP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(Java20Parser.LT, 0)

        def typeParameterList(self):
            return self.getTypedRuleContext(Java20Parser.TypeParameterListContext, 0)

        def GT(self):
            return self.getToken(Java20Parser.GT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeParameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeParameters"):
                listener.enterTypeParameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeParameters"):
                listener.exitTypeParameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeParameters"):
                return visitor.visitTypeParameters(self)
            else:
                return visitor.visitChildren(self)

    def typeParameters(self):

        localctx = Java20Parser.TypeParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_typeParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932
            self.match(Java20Parser.LT)
            self.state = 933
            self.typeParameterList()
            self.state = 934
            self.match(Java20Parser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeParameterContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeParameterContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeParameterList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeParameterList"):
                listener.enterTypeParameterList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeParameterList"):
                listener.exitTypeParameterList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeParameterList"):
                return visitor.visitTypeParameterList(self)
            else:
                return visitor.visitChildren(self)

    def typeParameterList(self):

        localctx = Java20Parser.TypeParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_typeParameterList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 936
            self.typeParameter()
            self.state = 941
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 937
                self.match(Java20Parser.COMMA)
                self.state = 938
                self.typeParameter()
                self.state = 943
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassExtendsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(Java20Parser.EXTENDS, 0)

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classExtends

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassExtends"):
                listener.enterClassExtends(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassExtends"):
                listener.exitClassExtends(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassExtends"):
                return visitor.visitClassExtends(self)
            else:
                return visitor.visitChildren(self)

    def classExtends(self):

        localctx = Java20Parser.ClassExtendsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_classExtends)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self.match(Java20Parser.EXTENDS)
            self.state = 945
            self.classType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassImplementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLEMENTS(self):
            return self.getToken(Java20Parser.IMPLEMENTS, 0)

        def interfaceTypeList(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceTypeListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classImplements

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassImplements"):
                listener.enterClassImplements(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassImplements"):
                listener.exitClassImplements(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassImplements"):
                return visitor.visitClassImplements(self)
            else:
                return visitor.visitChildren(self)

    def classImplements(self):

        localctx = Java20Parser.ClassImplementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_classImplements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.match(Java20Parser.IMPLEMENTS)
            self.state = 948
            self.interfaceTypeList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceTypeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interfaceType(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.InterfaceTypeContext)
            else:
                return self.getTypedRuleContext(Java20Parser.InterfaceTypeContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceTypeList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceTypeList"):
                listener.enterInterfaceTypeList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceTypeList"):
                listener.exitInterfaceTypeList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceTypeList"):
                return visitor.visitInterfaceTypeList(self)
            else:
                return visitor.visitChildren(self)

    def interfaceTypeList(self):

        localctx = Java20Parser.InterfaceTypeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_interfaceTypeList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self.interfaceType()
            self.state = 955
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 951
                self.match(Java20Parser.COMMA)
                self.state = 952
                self.interfaceType()
                self.state = 957
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassPermitsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERMITS(self):
            return self.getToken(Java20Parser.PERMITS, 0)

        def typeName(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeNameContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeNameContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_classPermits

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassPermits"):
                listener.enterClassPermits(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassPermits"):
                listener.exitClassPermits(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassPermits"):
                return visitor.visitClassPermits(self)
            else:
                return visitor.visitChildren(self)

    def classPermits(self):

        localctx = Java20Parser.ClassPermitsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_classPermits)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 958
            self.match(Java20Parser.PERMITS)
            self.state = 959
            self.typeName()
            self.state = 964
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 960
                self.match(Java20Parser.COMMA)
                self.state = 961
                self.typeName()
                self.state = 966
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def classBodyDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassBodyDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassBodyDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_classBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassBody"):
                listener.enterClassBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassBody"):
                listener.exitClassBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassBody"):
                return visitor.visitClassBody(self)
            else:
                return visitor.visitChildren(self)

    def classBody(self):

        localctx = Java20Parser.ClassBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_classBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 967
            self.match(Java20Parser.LBRACE)
            self.state = 971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -8512665130204132856) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230376187502595) != 0):
                self.state = 968
                self.classBodyDeclaration()
                self.state = 973
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 974
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassBodyDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classMemberDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassMemberDeclarationContext, 0)

        def instanceInitializer(self):
            return self.getTypedRuleContext(Java20Parser.InstanceInitializerContext, 0)

        def staticInitializer(self):
            return self.getTypedRuleContext(Java20Parser.StaticInitializerContext, 0)

        def constructorDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ConstructorDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classBodyDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassBodyDeclaration"):
                listener.enterClassBodyDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassBodyDeclaration"):
                listener.exitClassBodyDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassBodyDeclaration"):
                return visitor.visitClassBodyDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def classBodyDeclaration(self):

        localctx = Java20Parser.ClassBodyDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_classBodyDeclaration)
        try:
            self.state = 980
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 69, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 976
                self.classMemberDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 977
                self.instanceInitializer()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 978
                self.staticInitializer()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 979
                self.constructorDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassMemberDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.FieldDeclarationContext, 0)

        def methodDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.MethodDeclarationContext, 0)

        def classDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassDeclarationContext, 0)

        def interfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceDeclarationContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classMemberDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassMemberDeclaration"):
                listener.enterClassMemberDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassMemberDeclaration"):
                listener.exitClassMemberDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassMemberDeclaration"):
                return visitor.visitClassMemberDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def classMemberDeclaration(self):

        localctx = Java20Parser.ClassMemberDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_classMemberDeclaration)
        try:
            self.state = 987
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 70, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 982
                self.fieldDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 983
                self.methodDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 984
                self.classDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 985
                self.interfaceDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 986
                self.match(Java20Parser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FieldDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def variableDeclaratorList(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorListContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def fieldModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.FieldModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.FieldModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_fieldDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFieldDeclaration"):
                listener.enterFieldDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFieldDeclaration"):
                listener.exitFieldDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFieldDeclaration"):
                return visitor.visitFieldDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def fieldDeclaration(self):

        localctx = Java20Parser.FieldDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_fieldDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 992
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 35)) & ~0x3f) == 0 and ((1 << (_la - 35)) & 2251802230882305) != 0):
                self.state = 989
                self.fieldModifier()
                self.state = 994
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 995
            self.unannType()
            self.state = 996
            self.variableDeclaratorList()
            self.state = 997
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FieldModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(Java20Parser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def FINAL(self):
            return self.getToken(Java20Parser.FINAL, 0)

        def TRANSIENT(self):
            return self.getToken(Java20Parser.TRANSIENT, 0)

        def VOLATILE(self):
            return self.getToken(Java20Parser.VOLATILE, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_fieldModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFieldModifier"):
                listener.enterFieldModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFieldModifier"):
                listener.exitFieldModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFieldModifier"):
                return visitor.visitFieldModifier(self)
            else:
                return visitor.visitChildren(self)

    def fieldModifier(self):

        localctx = Java20Parser.FieldModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_fieldModifier)
        try:
            self.state = 1007
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 999
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1000
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1001
                self.match(Java20Parser.PROTECTED)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1002
                self.match(Java20Parser.PRIVATE)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1003
                self.match(Java20Parser.STATIC)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1004
                self.match(Java20Parser.FINAL)
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1005
                self.match(Java20Parser.TRANSIENT)
                pass
            elif token in [66]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1006
                self.match(Java20Parser.VOLATILE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclaratorListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableDeclaratorContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableDeclaratorContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableDeclaratorList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclaratorList"):
                listener.enterVariableDeclaratorList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclaratorList"):
                listener.exitVariableDeclaratorList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclaratorList"):
                return visitor.visitVariableDeclaratorList(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclaratorList(self):

        localctx = Java20Parser.VariableDeclaratorListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_variableDeclaratorList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1009
            self.variableDeclarator()
            self.state = 1014
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 73, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1010
                    self.match(Java20Parser.COMMA)
                    self.state = 1011
                    self.variableDeclarator()
                self.state = 1016
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 73, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaratorId(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorIdContext, 0)

        def ASSIGN(self):
            return self.getToken(Java20Parser.ASSIGN, 0)

        def variableInitializer(self):
            return self.getTypedRuleContext(Java20Parser.VariableInitializerContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableDeclarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclarator"):
                listener.enterVariableDeclarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclarator"):
                listener.exitVariableDeclarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclarator"):
                return visitor.visitVariableDeclarator(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclarator(self):

        localctx = Java20Parser.VariableDeclaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_variableDeclarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1017
            self.variableDeclaratorId()
            self.state = 1020
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 74, self._ctx)
            if la_ == 1:
                self.state = 1018
                self.match(Java20Parser.ASSIGN)
                self.state = 1019
                self.variableInitializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclaratorIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableDeclaratorId

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclaratorId"):
                listener.enterVariableDeclaratorId(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclaratorId"):
                listener.exitVariableDeclaratorId(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclaratorId"):
                return visitor.visitVariableDeclaratorId(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclaratorId(self):

        localctx = Java20Parser.VariableDeclaratorIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_variableDeclaratorId)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1022
            self.match(Java20Parser.Identifier)
            self.state = 1024
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 75, self._ctx)
            if la_ == 1:
                self.state = 1023
                self.dims()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def arrayInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayInitializerContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableInitializer"):
                listener.enterVariableInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableInitializer"):
                listener.exitVariableInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableInitializer"):
                return visitor.visitVariableInitializer(self)
            else:
                return visitor.visitChildren(self)

    def variableInitializer(self):

        localctx = Java20Parser.VariableInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_variableInitializer)
        try:
            self.state = 1028
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 48, 54, 57, 58, 60, 65, 69, 70, 71, 72, 73, 74, 75, 76, 86, 91, 92,
                         102, 103, 104, 105, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1026
                self.expression()
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1027
                self.arrayInitializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannPrimitiveType(self):
            return self.getTypedRuleContext(Java20Parser.UnannPrimitiveTypeContext, 0)

        def unannReferenceType(self):
            return self.getTypedRuleContext(Java20Parser.UnannReferenceTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannType"):
                listener.enterUnannType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannType"):
                listener.exitUnannType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannType"):
                return visitor.visitUnannType(self)
            else:
                return visitor.visitChildren(self)

    def unannType(self):

        localctx = Java20Parser.UnannTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_unannType)
        try:
            self.state = 1032
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 77, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1030
                self.unannPrimitiveType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1031
                self.unannReferenceType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannPrimitiveTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericType(self):
            return self.getTypedRuleContext(Java20Parser.NumericTypeContext, 0)

        def BOOLEAN(self):
            return self.getToken(Java20Parser.BOOLEAN, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannPrimitiveType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannPrimitiveType"):
                listener.enterUnannPrimitiveType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannPrimitiveType"):
                listener.exitUnannPrimitiveType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannPrimitiveType"):
                return visitor.visitUnannPrimitiveType(self)
            else:
                return visitor.visitChildren(self)

    def unannPrimitiveType(self):

        localctx = Java20Parser.UnannPrimitiveTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_unannPrimitiveType)
        try:
            self.state = 1036
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22, 25, 31, 37, 44, 46, 54]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1034
                self.numericType()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1035
                self.match(Java20Parser.BOOLEAN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannReferenceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannClassOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.UnannClassOrInterfaceTypeContext, 0)

        def unannTypeVariable(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeVariableContext, 0)

        def unannArrayType(self):
            return self.getTypedRuleContext(Java20Parser.UnannArrayTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannReferenceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannReferenceType"):
                listener.enterUnannReferenceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannReferenceType"):
                listener.exitUnannReferenceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannReferenceType"):
                return visitor.visitUnannReferenceType(self)
            else:
                return visitor.visitChildren(self)

    def unannReferenceType(self):

        localctx = Java20Parser.UnannReferenceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_unannReferenceType)
        try:
            self.state = 1041
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 79, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1038
                self.unannClassOrInterfaceType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1039
                self.unannTypeVariable()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1040
                self.unannArrayType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannClassOrInterfaceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def uCOIT(self):
            return self.getTypedRuleContext(Java20Parser.UCOITContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannClassOrInterfaceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannClassOrInterfaceType"):
                listener.enterUnannClassOrInterfaceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannClassOrInterfaceType"):
                listener.exitUnannClassOrInterfaceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannClassOrInterfaceType"):
                return visitor.visitUnannClassOrInterfaceType(self)
            else:
                return visitor.visitChildren(self)

    def unannClassOrInterfaceType(self):

        localctx = Java20Parser.UnannClassOrInterfaceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_unannClassOrInterfaceType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1051
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 81, self._ctx)
            if la_ == 1:
                self.state = 1043
                self.packageName()
                self.state = 1044
                self.match(Java20Parser.DOT)
                self.state = 1048
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 1045
                    self.annotation()
                    self.state = 1050
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1053
            self.typeIdentifier()
            self.state = 1055
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 82, self._ctx)
            if la_ == 1:
                self.state = 1054
                self.typeArguments()

            self.state = 1058
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 83, self._ctx)
            if la_ == 1:
                self.state = 1057
                self.uCOIT()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UCOITContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def uCOIT(self):
            return self.getTypedRuleContext(Java20Parser.UCOITContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_uCOIT

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUCOIT"):
                listener.enterUCOIT(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUCOIT"):
                listener.exitUCOIT(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUCOIT"):
                return visitor.visitUCOIT(self)
            else:
                return visitor.visitChildren(self)

    def uCOIT(self):

        localctx = Java20Parser.UCOITContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_uCOIT)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1060
            self.match(Java20Parser.DOT)
            self.state = 1064
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1061
                self.annotation()
                self.state = 1066
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1067
            self.typeIdentifier()
            self.state = 1069
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 85, self._ctx)
            if la_ == 1:
                self.state = 1068
                self.typeArguments()

            self.state = 1072
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 86, self._ctx)
            if la_ == 1:
                self.state = 1071
                self.uCOIT()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannClassTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def packageName(self):
            return self.getTypedRuleContext(Java20Parser.PackageNameContext, 0)

        def unannClassOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.UnannClassOrInterfaceTypeContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannClassType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannClassType"):
                listener.enterUnannClassType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannClassType"):
                listener.exitUnannClassType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannClassType"):
                return visitor.visitUnannClassType(self)
            else:
                return visitor.visitChildren(self)

    def unannClassType(self):

        localctx = Java20Parser.UnannClassTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_unannClassType)
        self._la = 0  # Token type
        try:
            self.state = 1093
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 91, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1074
                self.typeIdentifier()
                self.state = 1076
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 1075
                    self.typeArguments()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1080
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 88, self._ctx)
                if la_ == 1:
                    self.state = 1078
                    self.packageName()
                    pass

                elif la_ == 2:
                    self.state = 1079
                    self.unannClassOrInterfaceType()
                    pass

                self.state = 1082
                self.match(Java20Parser.DOT)
                self.state = 1086
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 1083
                    self.annotation()
                    self.state = 1088
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1089
                self.typeIdentifier()
                self.state = 1091
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 1090
                    self.typeArguments()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannInterfaceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannClassType(self):
            return self.getTypedRuleContext(Java20Parser.UnannClassTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannInterfaceType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannInterfaceType"):
                listener.enterUnannInterfaceType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannInterfaceType"):
                listener.exitUnannInterfaceType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannInterfaceType"):
                return visitor.visitUnannInterfaceType(self)
            else:
                return visitor.visitChildren(self)

    def unannInterfaceType(self):

        localctx = Java20Parser.UnannInterfaceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_unannInterfaceType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self.unannClassType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannTypeVariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannTypeVariable

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannTypeVariable"):
                listener.enterUnannTypeVariable(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannTypeVariable"):
                listener.exitUnannTypeVariable(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannTypeVariable"):
                return visitor.visitUnannTypeVariable(self)
            else:
                return visitor.visitChildren(self)

    def unannTypeVariable(self):

        localctx = Java20Parser.UnannTypeVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_unannTypeVariable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            self.typeIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnannArrayTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def unannPrimitiveType(self):
            return self.getTypedRuleContext(Java20Parser.UnannPrimitiveTypeContext, 0)

        def unannClassOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.UnannClassOrInterfaceTypeContext, 0)

        def unannTypeVariable(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeVariableContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unannArrayType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnannArrayType"):
                listener.enterUnannArrayType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnannArrayType"):
                listener.exitUnannArrayType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnannArrayType"):
                return visitor.visitUnannArrayType(self)
            else:
                return visitor.visitChildren(self)

    def unannArrayType(self):

        localctx = Java20Parser.UnannArrayTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_unannArrayType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 92, self._ctx)
            if la_ == 1:
                self.state = 1099
                self.unannPrimitiveType()
                pass

            elif la_ == 2:
                self.state = 1100
                self.unannClassOrInterfaceType()
                pass

            elif la_ == 3:
                self.state = 1101
                self.unannTypeVariable()
                pass

            self.state = 1104
            self.dims()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodHeader(self):
            return self.getTypedRuleContext(Java20Parser.MethodHeaderContext, 0)

        def methodBody(self):
            return self.getTypedRuleContext(Java20Parser.MethodBodyContext, 0)

        def methodModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.MethodModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.MethodModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodDeclaration"):
                listener.enterMethodDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodDeclaration"):
                listener.exitMethodDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodDeclaration"):
                return visitor.visitMethodDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def methodDeclaration(self):

        localctx = Java20Parser.MethodDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_methodDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 692569214556569600) != 0) or _la == 86:
                self.state = 1106
                self.methodModifier()
                self.state = 1111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1112
            self.methodHeader()
            self.state = 1113
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(Java20Parser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def ABSTRACT(self):
            return self.getToken(Java20Parser.ABSTRACT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def FINAL(self):
            return self.getToken(Java20Parser.FINAL, 0)

        def SYNCHRONIZED(self):
            return self.getToken(Java20Parser.SYNCHRONIZED, 0)

        def NATIVE(self):
            return self.getToken(Java20Parser.NATIVE, 0)

        def STRICTFP(self):
            return self.getToken(Java20Parser.STRICTFP, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodModifier"):
                listener.enterMethodModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodModifier"):
                listener.exitMethodModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodModifier"):
                return visitor.visitMethodModifier(self)
            else:
                return visitor.visitChildren(self)

    def methodModifier(self):

        localctx = Java20Parser.MethodModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_methodModifier)
        try:
            self.state = 1125
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1115
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1116
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1117
                self.match(Java20Parser.PROTECTED)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1118
                self.match(Java20Parser.PRIVATE)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1119
                self.match(Java20Parser.ABSTRACT)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1120
                self.match(Java20Parser.STATIC)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1121
                self.match(Java20Parser.FINAL)
                pass
            elif token in [59]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1122
                self.match(Java20Parser.SYNCHRONIZED)
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1123
                self.match(Java20Parser.NATIVE)
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1124
                self.match(Java20Parser.STRICTFP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def result(self):
            return self.getTypedRuleContext(Java20Parser.ResultContext, 0)

        def methodDeclarator(self):
            return self.getTypedRuleContext(Java20Parser.MethodDeclaratorContext, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(Java20Parser.TypeParametersContext, 0)

        def throwsT(self):
            return self.getTypedRuleContext(Java20Parser.ThrowsTContext, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodHeader

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodHeader"):
                listener.enterMethodHeader(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodHeader"):
                listener.exitMethodHeader(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodHeader"):
                return visitor.visitMethodHeader(self)
            else:
                return visitor.visitChildren(self)

    def methodHeader(self):

        localctx = Java20Parser.MethodHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_methodHeader)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 1127
                self.typeParameters()
                self.state = 1131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 1128
                    self.annotation()
                    self.state = 1133
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1136
            self.result()
            self.state = 1137
            self.methodDeclarator()
            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 62:
                self.state = 1138
                self.throwsT()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def VOID(self):
            return self.getToken(Java20Parser.VOID, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_result

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterResult"):
                listener.enterResult(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitResult"):
                listener.exitResult(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResult"):
                return visitor.visitResult(self)
            else:
                return visitor.visitChildren(self)

    def result(self):

        localctx = Java20Parser.ResultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_result)
        try:
            self.state = 1143
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 54, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1141
                self.unannType()
                pass
            elif token in [65]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1142
                self.match(Java20Parser.VOID)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodDeclaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def receiverParameter(self):
            return self.getTypedRuleContext(Java20Parser.ReceiverParameterContext, 0)

        def COMMA(self):
            return self.getToken(Java20Parser.COMMA, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(Java20Parser.FormalParameterListContext, 0)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodDeclarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodDeclarator"):
                listener.enterMethodDeclarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodDeclarator"):
                listener.exitMethodDeclarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodDeclarator"):
                return visitor.visitMethodDeclarator(self)
            else:
                return visitor.visitChildren(self)

    def methodDeclarator(self):

        localctx = Java20Parser.MethodDeclaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_methodDeclarator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.match(Java20Parser.Identifier)
            self.state = 1146
            self.match(Java20Parser.LPAREN)
            self.state = 1150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 99, self._ctx)
            if la_ == 1:
                self.state = 1147
                self.receiverParameter()
                self.state = 1148
                self.match(Java20Parser.COMMA)

            self.state = 1153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18102533424676864) != 0) or _la == 86 or _la == 123:
                self.state = 1152
                self.formalParameterList()

            self.state = 1155
            self.match(Java20Parser.RPAREN)
            self.state = 1157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 80 or _la == 86:
                self.state = 1156
                self.dims()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReceiverParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def THIS(self):
            return self.getToken(Java20Parser.THIS, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_receiverParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReceiverParameter"):
                listener.enterReceiverParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReceiverParameter"):
                listener.exitReceiverParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReceiverParameter"):
                return visitor.visitReceiverParameter(self)
            else:
                return visitor.visitChildren(self)

    def receiverParameter(self):

        localctx = Java20Parser.ReceiverParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_receiverParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1159
                self.annotation()
                self.state = 1164
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1165
            self.unannType()
            self.state = 1168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 123:
                self.state = 1166
                self.match(Java20Parser.Identifier)
                self.state = 1167
                self.match(Java20Parser.DOT)

            self.state = 1170
            self.match(Java20Parser.THIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FormalParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formalParameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.FormalParameterContext)
            else:
                return self.getTypedRuleContext(Java20Parser.FormalParameterContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_formalParameterList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormalParameterList"):
                listener.enterFormalParameterList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormalParameterList"):
                listener.exitFormalParameterList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormalParameterList"):
                return visitor.visitFormalParameterList(self)
            else:
                return visitor.visitChildren(self)

    def formalParameterList(self):

        localctx = Java20Parser.FormalParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_formalParameterList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1172
            self.formalParameter()
            self.state = 1177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1173
                self.match(Java20Parser.COMMA)
                self.state = 1174
                self.formalParameter()
                self.state = 1179
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def variableDeclaratorId(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorIdContext, 0)

        def variableModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableModifierContext, i)

        def variableArityParameter(self):
            return self.getTypedRuleContext(Java20Parser.VariableArityParameterContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_formalParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormalParameter"):
                listener.enterFormalParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormalParameter"):
                listener.exitFormalParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormalParameter"):
                return visitor.visitFormalParameter(self)
            else:
                return visitor.visitChildren(self)

    def formalParameter(self):

        localctx = Java20Parser.FormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_formalParameter)
        self._la = 0  # Token type
        try:
            self.state = 1190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 106, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1183
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 35 or _la == 86:
                    self.state = 1180
                    self.variableModifier()
                    self.state = 1185
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1186
                self.unannType()
                self.state = 1187
                self.variableDeclaratorId()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1189
                self.variableArityParameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableArityParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def ELLIPSIS(self):
            return self.getToken(Java20Parser.ELLIPSIS, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def variableModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableModifierContext, i)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableArityParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableArityParameter"):
                listener.enterVariableArityParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableArityParameter"):
                listener.exitVariableArityParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableArityParameter"):
                return visitor.visitVariableArityParameter(self)
            else:
                return visitor.visitChildren(self)

    def variableArityParameter(self):

        localctx = Java20Parser.VariableArityParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_variableArityParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 35 or _la == 86:
                self.state = 1192
                self.variableModifier()
                self.state = 1197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1198
            self.unannType()
            self.state = 1202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1199
                self.annotation()
                self.state = 1204
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1205
            self.match(Java20Parser.ELLIPSIS)
            self.state = 1206
            self.match(Java20Parser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def FINAL(self):
            return self.getToken(Java20Parser.FINAL, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableModifier"):
                listener.enterVariableModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableModifier"):
                listener.exitVariableModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableModifier"):
                return visitor.visitVariableModifier(self)
            else:
                return visitor.visitChildren(self)

    def variableModifier(self):

        localctx = Java20Parser.VariableModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_variableModifier)
        try:
            self.state = 1210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1208
                self.annotation()
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1209
                self.match(Java20Parser.FINAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ThrowsTContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THROWS(self):
            return self.getToken(Java20Parser.THROWS, 0)

        def exceptionTypeList(self):
            return self.getTypedRuleContext(Java20Parser.ExceptionTypeListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_throwsT

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThrowsT"):
                listener.enterThrowsT(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThrowsT"):
                listener.exitThrowsT(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThrowsT"):
                return visitor.visitThrowsT(self)
            else:
                return visitor.visitChildren(self)

    def throwsT(self):

        localctx = Java20Parser.ThrowsTContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_throwsT)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1212
            self.match(Java20Parser.THROWS)
            self.state = 1213
            self.exceptionTypeList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExceptionTypeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exceptionType(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ExceptionTypeContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ExceptionTypeContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_exceptionTypeList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExceptionTypeList"):
                listener.enterExceptionTypeList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExceptionTypeList"):
                listener.exitExceptionTypeList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExceptionTypeList"):
                return visitor.visitExceptionTypeList(self)
            else:
                return visitor.visitChildren(self)

    def exceptionTypeList(self):

        localctx = Java20Parser.ExceptionTypeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_exceptionTypeList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1215
            self.exceptionType()
            self.state = 1220
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1216
                self.match(Java20Parser.COMMA)
                self.state = 1217
                self.exceptionType()
                self.state = 1222
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExceptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def typeVariable(self):
            return self.getTypedRuleContext(Java20Parser.TypeVariableContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_exceptionType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExceptionType"):
                listener.enterExceptionType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExceptionType"):
                listener.exitExceptionType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExceptionType"):
                return visitor.visitExceptionType(self)
            else:
                return visitor.visitChildren(self)

    def exceptionType(self):

        localctx = Java20Parser.ExceptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_exceptionType)
        try:
            self.state = 1225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 111, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1223
                self.classType()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1224
                self.typeVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodBody"):
                listener.enterMethodBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodBody"):
                listener.exitMethodBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodBody"):
                return visitor.visitMethodBody(self)
            else:
                return visitor.visitChildren(self)

    def methodBody(self):

        localctx = Java20Parser.MethodBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_methodBody)
        try:
            self.state = 1229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1227
                self.block()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1228
                self.match(Java20Parser.SEMI)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InstanceInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_instanceInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInstanceInitializer"):
                listener.enterInstanceInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInstanceInitializer"):
                listener.exitInstanceInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInstanceInitializer"):
                return visitor.visitInstanceInitializer(self)
            else:
                return visitor.visitChildren(self)

    def instanceInitializer(self):

        localctx = Java20Parser.InstanceInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_instanceInitializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1231
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StaticInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_staticInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStaticInitializer"):
                listener.enterStaticInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStaticInitializer"):
                listener.exitStaticInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStaticInitializer"):
                return visitor.visitStaticInitializer(self)
            else:
                return visitor.visitChildren(self)

    def staticInitializer(self):

        localctx = Java20Parser.StaticInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_staticInitializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1233
            self.match(Java20Parser.STATIC)
            self.state = 1234
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructorDeclarator(self):
            return self.getTypedRuleContext(Java20Parser.ConstructorDeclaratorContext, 0)

        def constructorBody(self):
            return self.getTypedRuleContext(Java20Parser.ConstructorBodyContext, 0)

        def constructorModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ConstructorModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ConstructorModifierContext, i)

        def throwsT(self):
            return self.getTypedRuleContext(Java20Parser.ThrowsTContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constructorDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorDeclaration"):
                listener.enterConstructorDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorDeclaration"):
                listener.exitConstructorDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorDeclaration"):
                return visitor.visitConstructorDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def constructorDeclaration(self):

        localctx = Java20Parser.ConstructorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_constructorDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1239
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & 68719476743) != 0):
                self.state = 1236
                self.constructorModifier()
                self.state = 1241
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1242
            self.constructorDeclarator()
            self.state = 1244
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 62:
                self.state = 1243
                self.throwsT()

            self.state = 1246
            self.constructorBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(Java20Parser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constructorModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorModifier"):
                listener.enterConstructorModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorModifier"):
                listener.exitConstructorModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorModifier"):
                return visitor.visitConstructorModifier(self)
            else:
                return visitor.visitChildren(self)

    def constructorModifier(self):

        localctx = Java20Parser.ConstructorModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_constructorModifier)
        try:
            self.state = 1252
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1248
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1249
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1250
                self.match(Java20Parser.PROTECTED)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1251
                self.match(Java20Parser.PRIVATE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorDeclaratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleTypeName(self):
            return self.getTypedRuleContext(Java20Parser.SimpleTypeNameContext, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(Java20Parser.TypeParametersContext, 0)

        def receiverParameter(self):
            return self.getTypedRuleContext(Java20Parser.ReceiverParameterContext, 0)

        def COMMA(self):
            return self.getToken(Java20Parser.COMMA, 0)

        def formalParameterList(self):
            return self.getTypedRuleContext(Java20Parser.FormalParameterListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constructorDeclarator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorDeclarator"):
                listener.enterConstructorDeclarator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorDeclarator"):
                listener.exitConstructorDeclarator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorDeclarator"):
                return visitor.visitConstructorDeclarator(self)
            else:
                return visitor.visitChildren(self)

    def constructorDeclarator(self):

        localctx = Java20Parser.ConstructorDeclaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_constructorDeclarator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 1254
                self.typeParameters()

            self.state = 1257
            self.simpleTypeName()
            self.state = 1258
            self.match(Java20Parser.LPAREN)
            self.state = 1262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 117, self._ctx)
            if la_ == 1:
                self.state = 1259
                self.receiverParameter()
                self.state = 1260
                self.match(Java20Parser.COMMA)

            self.state = 1265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18102533424676864) != 0) or _la == 86 or _la == 123:
                self.state = 1264
                self.formalParameterList()

            self.state = 1267
            self.match(Java20Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_simpleTypeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimpleTypeName"):
                listener.enterSimpleTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimpleTypeName"):
                listener.exitSimpleTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSimpleTypeName"):
                return visitor.visitSimpleTypeName(self)
            else:
                return visitor.visitChildren(self)

    def simpleTypeName(self):

        localctx = Java20Parser.SimpleTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_simpleTypeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1269
            self.typeIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def explicitConstructorInvocation(self):
            return self.getTypedRuleContext(Java20Parser.ExplicitConstructorInvocationContext, 0)

        def blockStatements(self):
            return self.getTypedRuleContext(Java20Parser.BlockStatementsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constructorBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorBody"):
                listener.enterConstructorBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorBody"):
                listener.exitConstructorBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorBody"):
                return visitor.visitConstructorBody(self)
            else:
                return visitor.visitChildren(self)

    def constructorBody(self):

        localctx = Java20Parser.ConstructorBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_constructorBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1271
            self.match(Java20Parser.LBRACE)
            self.state = 1273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 119, self._ctx)
            if la_ == 1:
                self.state = 1272
                self.explicitConstructorInvocation()

            self.state = 1276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4610965747420531208) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 576461576941625323) != 0):
                self.state = 1275
                self.blockStatements()

            self.state = 1278
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExplicitConstructorInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def THIS(self):
            return self.getToken(Java20Parser.THIS, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_explicitConstructorInvocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExplicitConstructorInvocation"):
                listener.enterExplicitConstructorInvocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExplicitConstructorInvocation"):
                listener.exitExplicitConstructorInvocation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExplicitConstructorInvocation"):
                return visitor.visitExplicitConstructorInvocation(self)
            else:
                return visitor.visitChildren(self)

    def explicitConstructorInvocation(self):

        localctx = Java20Parser.ExplicitConstructorInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_explicitConstructorInvocation)
        self._la = 0  # Token type
        try:
            self.state = 1306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 126, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1281
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 1280
                    self.typeArguments()

                self.state = 1283
                _la = self._input.LA(1)
                if not (_la == 57 or _la == 60):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1284
                self.match(Java20Parser.LPAREN)
                self.state = 1286
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 1285
                    self.argumentList()

                self.state = 1288
                self.match(Java20Parser.RPAREN)
                self.state = 1289
                self.match(Java20Parser.SEMI)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1292
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 123, self._ctx)
                if la_ == 1:
                    self.state = 1290
                    self.expressionName()
                    pass

                elif la_ == 2:
                    self.state = 1291
                    self.primary()
                    pass

                self.state = 1294
                self.match(Java20Parser.DOT)
                self.state = 1296
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 1295
                    self.typeArguments()

                self.state = 1298
                self.match(Java20Parser.SUPER)
                self.state = 1299
                self.match(Java20Parser.LPAREN)
                self.state = 1301
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 1300
                    self.argumentList()

                self.state = 1303
                self.match(Java20Parser.RPAREN)
                self.state = 1304
                self.match(Java20Parser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(Java20Parser.ENUM, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def enumBody(self):
            return self.getTypedRuleContext(Java20Parser.EnumBodyContext, 0)

        def classModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassModifierContext, i)

        def classImplements(self):
            return self.getTypedRuleContext(Java20Parser.ClassImplementsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumDeclaration"):
                listener.enterEnumDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumDeclaration"):
                listener.exitEnumDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumDeclaration"):
                return visitor.visitEnumDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def enumDeclaration(self):

        localctx = Java20Parser.EnumDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_enumDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 115967724764792840) != 0) or _la == 86:
                self.state = 1308
                self.classModifier()
                self.state = 1313
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1314
            self.match(Java20Parser.ENUM)
            self.state = 1315
            self.typeIdentifier()
            self.state = 1317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 41:
                self.state = 1316
                self.classImplements()

            self.state = 1319
            self.enumBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def enumConstantList(self):
            return self.getTypedRuleContext(Java20Parser.EnumConstantListContext, 0)

        def COMMA(self):
            return self.getToken(Java20Parser.COMMA, 0)

        def enumBodyDeclarations(self):
            return self.getTypedRuleContext(Java20Parser.EnumBodyDeclarationsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumBody"):
                listener.enterEnumBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumBody"):
                listener.exitEnumBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumBody"):
                return visitor.visitEnumBody(self)
            else:
                return visitor.visitChildren(self)

    def enumBody(self):

        localctx = Java20Parser.EnumBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_enumBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1321
            self.match(Java20Parser.LBRACE)
            self.state = 1323
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 86 or _la == 123:
                self.state = 1322
                self.enumConstantList()

            self.state = 1326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 83:
                self.state = 1325
                self.match(Java20Parser.COMMA)

            self.state = 1329
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 82:
                self.state = 1328
                self.enumBodyDeclarations()

            self.state = 1331
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumConstantListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumConstant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.EnumConstantContext)
            else:
                return self.getTypedRuleContext(Java20Parser.EnumConstantContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumConstantList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumConstantList"):
                listener.enterEnumConstantList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumConstantList"):
                listener.exitEnumConstantList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumConstantList"):
                return visitor.visitEnumConstantList(self)
            else:
                return visitor.visitChildren(self)

    def enumConstantList(self):

        localctx = Java20Parser.EnumConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_enumConstantList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1333
            self.enumConstant()
            self.state = 1338
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 132, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1334
                    self.match(Java20Parser.COMMA)
                    self.state = 1335
                    self.enumConstant()
                self.state = 1340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 132, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def enumConstantModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.EnumConstantModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.EnumConstantModifierContext, i)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def classBody(self):
            return self.getTypedRuleContext(Java20Parser.ClassBodyContext, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumConstant

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumConstant"):
                listener.enterEnumConstant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumConstant"):
                listener.exitEnumConstant(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumConstant"):
                return visitor.visitEnumConstant(self)
            else:
                return visitor.visitChildren(self)

    def enumConstant(self):

        localctx = Java20Parser.EnumConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_enumConstant)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1341
                self.enumConstantModifier()
                self.state = 1346
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1347
            self.match(Java20Parser.Identifier)
            self.state = 1353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 76:
                self.state = 1348
                self.match(Java20Parser.LPAREN)
                self.state = 1350
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 1349
                    self.argumentList()

                self.state = 1352
                self.match(Java20Parser.RPAREN)

            self.state = 1356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 78:
                self.state = 1355
                self.classBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumConstantModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumConstantModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumConstantModifier"):
                listener.enterEnumConstantModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumConstantModifier"):
                listener.exitEnumConstantModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumConstantModifier"):
                return visitor.visitEnumConstantModifier(self)
            else:
                return visitor.visitChildren(self)

    def enumConstantModifier(self):

        localctx = Java20Parser.EnumConstantModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_enumConstantModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1358
            self.annotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumBodyDeclarationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def classBodyDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassBodyDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassBodyDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_enumBodyDeclarations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumBodyDeclarations"):
                listener.enterEnumBodyDeclarations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumBodyDeclarations"):
                listener.exitEnumBodyDeclarations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumBodyDeclarations"):
                return visitor.visitEnumBodyDeclarations(self)
            else:
                return visitor.visitChildren(self)

    def enumBodyDeclarations(self):

        localctx = Java20Parser.EnumBodyDeclarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_enumBodyDeclarations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1360
            self.match(Java20Parser.SEMI)
            self.state = 1364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -8512665130204132856) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230376187502595) != 0):
                self.state = 1361
                self.classBodyDeclaration()
                self.state = 1366
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self):
            return self.getToken(Java20Parser.RECORD, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def recordHeader(self):
            return self.getTypedRuleContext(Java20Parser.RecordHeaderContext, 0)

        def recordBody(self):
            return self.getTypedRuleContext(Java20Parser.RecordBodyContext, 0)

        def classModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassModifierContext, i)

        def typeParameters(self):
            return self.getTypedRuleContext(Java20Parser.TypeParametersContext, 0)

        def classImplements(self):
            return self.getTypedRuleContext(Java20Parser.ClassImplementsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordDeclaration"):
                listener.enterRecordDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordDeclaration"):
                listener.exitRecordDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordDeclaration"):
                return visitor.visitRecordDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def recordDeclaration(self):

        localctx = Java20Parser.RecordDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_recordDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 115967724764792840) != 0) or _la == 86:
                self.state = 1367
                self.classModifier()
                self.state = 1372
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1373
            self.match(Java20Parser.RECORD)
            self.state = 1374
            self.typeIdentifier()
            self.state = 1376
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 1375
                self.typeParameters()

            self.state = 1378
            self.recordHeader()
            self.state = 1380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 41:
                self.state = 1379
                self.classImplements()

            self.state = 1382
            self.recordBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def recordComponentList(self):
            return self.getTypedRuleContext(Java20Parser.RecordComponentListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordHeader

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordHeader"):
                listener.enterRecordHeader(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordHeader"):
                listener.exitRecordHeader(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordHeader"):
                return visitor.visitRecordHeader(self)
            else:
                return visitor.visitChildren(self)

    def recordHeader(self):

        localctx = Java20Parser.RecordHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_recordHeader)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1384
            self.match(Java20Parser.LPAREN)
            self.state = 1386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18102499064938496) != 0) or _la == 86 or _la == 123:
                self.state = 1385
                self.recordComponentList()

            self.state = 1388
            self.match(Java20Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordComponentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def recordComponent(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.RecordComponentContext)
            else:
                return self.getTypedRuleContext(Java20Parser.RecordComponentContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordComponentList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordComponentList"):
                listener.enterRecordComponentList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordComponentList"):
                listener.exitRecordComponentList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordComponentList"):
                return visitor.visitRecordComponentList(self)
            else:
                return visitor.visitChildren(self)

    def recordComponentList(self):

        localctx = Java20Parser.RecordComponentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_recordComponentList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1390
            self.recordComponent()
            self.state = 1395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1391
                self.match(Java20Parser.COMMA)
                self.state = 1392
                self.recordComponent()
                self.state = 1397
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def recordComponentModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.RecordComponentModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.RecordComponentModifierContext, i)

        def variableArityRecordComponent(self):
            return self.getTypedRuleContext(Java20Parser.VariableArityRecordComponentContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordComponent

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordComponent"):
                listener.enterRecordComponent(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordComponent"):
                listener.exitRecordComponent(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordComponent"):
                return visitor.visitRecordComponent(self)
            else:
                return visitor.visitChildren(self)

    def recordComponent(self):

        localctx = Java20Parser.RecordComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_recordComponent)
        self._la = 0  # Token type
        try:
            self.state = 1408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 144, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1401
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 1398
                    self.recordComponentModifier()
                    self.state = 1403
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1404
                self.unannType()
                self.state = 1405
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1407
                self.variableArityRecordComponent()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableArityRecordComponentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def ELLIPSIS(self):
            return self.getToken(Java20Parser.ELLIPSIS, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def recordComponentModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.RecordComponentModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.RecordComponentModifierContext, i)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableArityRecordComponent

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableArityRecordComponent"):
                listener.enterVariableArityRecordComponent(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableArityRecordComponent"):
                listener.exitVariableArityRecordComponent(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableArityRecordComponent"):
                return visitor.visitVariableArityRecordComponent(self)
            else:
                return visitor.visitChildren(self)

    def variableArityRecordComponent(self):

        localctx = Java20Parser.VariableArityRecordComponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_variableArityRecordComponent)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1410
                self.recordComponentModifier()
                self.state = 1415
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1416
            self.unannType()
            self.state = 1420
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 1417
                self.annotation()
                self.state = 1422
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1423
            self.match(Java20Parser.ELLIPSIS)
            self.state = 1424
            self.match(Java20Parser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordComponentModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordComponentModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordComponentModifier"):
                listener.enterRecordComponentModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordComponentModifier"):
                listener.exitRecordComponentModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordComponentModifier"):
                return visitor.visitRecordComponentModifier(self)
            else:
                return visitor.visitChildren(self)

    def recordComponentModifier(self):

        localctx = Java20Parser.RecordComponentModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_recordComponentModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1426
            self.annotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def recordBodyDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.RecordBodyDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.RecordBodyDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordBody"):
                listener.enterRecordBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordBody"):
                listener.exitRecordBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordBody"):
                return visitor.visitRecordBody(self)
            else:
                return visitor.visitChildren(self)

    def recordBody(self):

        localctx = Java20Parser.RecordBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_recordBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1428
            self.match(Java20Parser.LBRACE)
            self.state = 1432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -8512665130204132856) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230376187502595) != 0):
                self.state = 1429
                self.recordBodyDeclaration()
                self.state = 1434
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1435
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RecordBodyDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classBodyDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassBodyDeclarationContext, 0)

        def compactConstructorDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.CompactConstructorDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_recordBodyDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRecordBodyDeclaration"):
                listener.enterRecordBodyDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRecordBodyDeclaration"):
                listener.exitRecordBodyDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRecordBodyDeclaration"):
                return visitor.visitRecordBodyDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def recordBodyDeclaration(self):

        localctx = Java20Parser.RecordBodyDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_recordBodyDeclaration)
        try:
            self.state = 1439
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 148, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1437
                self.classBodyDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1438
                self.compactConstructorDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompactConstructorDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleTypeName(self):
            return self.getTypedRuleContext(Java20Parser.SimpleTypeNameContext, 0)

        def constructorBody(self):
            return self.getTypedRuleContext(Java20Parser.ConstructorBodyContext, 0)

        def constructorModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ConstructorModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ConstructorModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_compactConstructorDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompactConstructorDeclaration"):
                listener.enterCompactConstructorDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompactConstructorDeclaration"):
                listener.exitCompactConstructorDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompactConstructorDeclaration"):
                return visitor.visitCompactConstructorDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def compactConstructorDeclaration(self):

        localctx = Java20Parser.CompactConstructorDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_compactConstructorDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1444
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & 68719476743) != 0):
                self.state = 1441
                self.constructorModifier()
                self.state = 1446
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1447
            self.simpleTypeName()
            self.state = 1448
            self.constructorBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def normalInterfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.NormalInterfaceDeclarationContext, 0)

        def annotationInterfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationInterfaceDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceDeclaration"):
                listener.enterInterfaceDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceDeclaration"):
                listener.exitInterfaceDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceDeclaration"):
                return visitor.visitInterfaceDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def interfaceDeclaration(self):

        localctx = Java20Parser.InterfaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_interfaceDeclaration)
        try:
            self.state = 1452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 150, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1450
                self.normalInterfaceDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1451
                self.annotationInterfaceDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NormalInterfaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACE(self):
            return self.getToken(Java20Parser.INTERFACE, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def interfaceBody(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceBodyContext, 0)

        def interfaceModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.InterfaceModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.InterfaceModifierContext, i)

        def typeParameters(self):
            return self.getTypedRuleContext(Java20Parser.TypeParametersContext, 0)

        def interfaceExtends(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceExtendsContext, 0)

        def interfacePermits(self):
            return self.getTypedRuleContext(Java20Parser.InterfacePermitsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_normalInterfaceDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNormalInterfaceDeclaration"):
                listener.enterNormalInterfaceDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNormalInterfaceDeclaration"):
                listener.exitNormalInterfaceDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNormalInterfaceDeclaration"):
                return visitor.visitNormalInterfaceDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def normalInterfaceDeclaration(self):

        localctx = Java20Parser.NormalInterfaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_normalInterfaceDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1457
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 115967690405054472) != 0) or _la == 86:
                self.state = 1454
                self.interfaceModifier()
                self.state = 1459
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1460
            self.match(Java20Parser.INTERFACE)
            self.state = 1461
            self.typeIdentifier()
            self.state = 1463
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 1462
                self.typeParameters()

            self.state = 1466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 34:
                self.state = 1465
                self.interfaceExtends()

            self.state = 1469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 7:
                self.state = 1468
                self.interfacePermits()

            self.state = 1471
            self.interfaceBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(Java20Parser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def ABSTRACT(self):
            return self.getToken(Java20Parser.ABSTRACT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def SEALED(self):
            return self.getToken(Java20Parser.SEALED, 0)

        def NONSEALED(self):
            return self.getToken(Java20Parser.NONSEALED, 0)

        def STRICTFP(self):
            return self.getToken(Java20Parser.STRICTFP, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceModifier"):
                listener.enterInterfaceModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceModifier"):
                listener.exitInterfaceModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceModifier"):
                return visitor.visitInterfaceModifier(self)
            else:
                return visitor.visitChildren(self)

    def interfaceModifier(self):

        localctx = Java20Parser.InterfaceModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_interfaceModifier)
        try:
            self.state = 1482
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1473
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1474
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1475
                self.match(Java20Parser.PROTECTED)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1476
                self.match(Java20Parser.PRIVATE)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1477
                self.match(Java20Parser.ABSTRACT)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1478
                self.match(Java20Parser.STATIC)
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1479
                self.match(Java20Parser.SEALED)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1480
                self.match(Java20Parser.NONSEALED)
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1481
                self.match(Java20Parser.STRICTFP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceExtendsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(Java20Parser.EXTENDS, 0)

        def interfaceTypeList(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceTypeListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceExtends

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceExtends"):
                listener.enterInterfaceExtends(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceExtends"):
                listener.exitInterfaceExtends(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceExtends"):
                return visitor.visitInterfaceExtends(self)
            else:
                return visitor.visitChildren(self)

    def interfaceExtends(self):

        localctx = Java20Parser.InterfaceExtendsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_interfaceExtends)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1484
            self.match(Java20Parser.EXTENDS)
            self.state = 1485
            self.interfaceTypeList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfacePermitsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PERMITS(self):
            return self.getToken(Java20Parser.PERMITS, 0)

        def typeName(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.TypeNameContext)
            else:
                return self.getTypedRuleContext(Java20Parser.TypeNameContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfacePermits

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfacePermits"):
                listener.enterInterfacePermits(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfacePermits"):
                listener.exitInterfacePermits(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfacePermits"):
                return visitor.visitInterfacePermits(self)
            else:
                return visitor.visitChildren(self)

    def interfacePermits(self):

        localctx = Java20Parser.InterfacePermitsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_interfacePermits)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1487
            self.match(Java20Parser.PERMITS)
            self.state = 1488
            self.typeName()
            self.state = 1493
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1489
                self.match(Java20Parser.COMMA)
                self.state = 1490
                self.typeName()
                self.state = 1495
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def interfaceMemberDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.InterfaceMemberDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.InterfaceMemberDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceBody"):
                listener.enterInterfaceBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceBody"):
                listener.exitInterfaceBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceBody"):
                return visitor.visitInterfaceBody(self)
            else:
                return visitor.visitChildren(self)

    def interfaceBody(self):

        localctx = Java20Parser.InterfaceBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_interfaceBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1496
            self.match(Java20Parser.LBRACE)
            self.state = 1500
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 134105417395735048) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230376187494401) != 0):
                self.state = 1497
                self.interfaceMemberDeclaration()
                self.state = 1502
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1503
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceMemberDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ConstantDeclarationContext, 0)

        def interfaceMethodDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceMethodDeclarationContext, 0)

        def classDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassDeclarationContext, 0)

        def interfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceDeclarationContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceMemberDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceMemberDeclaration"):
                listener.enterInterfaceMemberDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceMemberDeclaration"):
                listener.exitInterfaceMemberDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceMemberDeclaration"):
                return visitor.visitInterfaceMemberDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def interfaceMemberDeclaration(self):

        localctx = Java20Parser.InterfaceMemberDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_interfaceMemberDeclaration)
        try:
            self.state = 1510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 158, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1505
                self.constantDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1506
                self.interfaceMethodDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1507
                self.classDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1508
                self.interfaceDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1509
                self.match(Java20Parser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def variableDeclaratorList(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorListContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def constantModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ConstantModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ConstantModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_constantDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstantDeclaration"):
                listener.enterConstantDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstantDeclaration"):
                listener.exitConstantDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstantDeclaration"):
                return visitor.visitConstantDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def constantDeclaration(self):

        localctx = Java20Parser.ConstantDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_constantDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1515
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 35)) & ~0x3f) == 0 and ((1 << (_la - 35)) & 2251799814864897) != 0):
                self.state = 1512
                self.constantModifier()
                self.state = 1517
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1518
            self.unannType()
            self.state = 1519
            self.variableDeclaratorList()
            self.state = 1520
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def FINAL(self):
            return self.getToken(Java20Parser.FINAL, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constantModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstantModifier"):
                listener.enterConstantModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstantModifier"):
                listener.exitConstantModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstantModifier"):
                return visitor.visitConstantModifier(self)
            else:
                return visitor.visitChildren(self)

    def constantModifier(self):

        localctx = Java20Parser.ConstantModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_constantModifier)
        try:
            self.state = 1526
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1522
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1523
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1524
                self.match(Java20Parser.STATIC)
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1525
                self.match(Java20Parser.FINAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceMethodDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodHeader(self):
            return self.getTypedRuleContext(Java20Parser.MethodHeaderContext, 0)

        def methodBody(self):
            return self.getTypedRuleContext(Java20Parser.MethodBodyContext, 0)

        def interfaceMethodModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.InterfaceMethodModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.InterfaceMethodModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceMethodDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceMethodDeclaration"):
                listener.enterInterfaceMethodDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceMethodDeclaration"):
                listener.exitInterfaceMethodDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceMethodDeclaration"):
                return visitor.visitInterfaceMethodDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def interfaceMethodDeclaration(self):

        localctx = Java20Parser.InterfaceMethodDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_interfaceMethodDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 113715891128238080) != 0) or _la == 86:
                self.state = 1528
                self.interfaceMethodModifier()
                self.state = 1533
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1534
            self.methodHeader()
            self.state = 1535
            self.methodBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceMethodModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def PRIVATE(self):
            return self.getToken(Java20Parser.PRIVATE, 0)

        def ABSTRACT(self):
            return self.getToken(Java20Parser.ABSTRACT, 0)

        def DEFAULT(self):
            return self.getToken(Java20Parser.DEFAULT, 0)

        def STATIC(self):
            return self.getToken(Java20Parser.STATIC, 0)

        def STRICTFP(self):
            return self.getToken(Java20Parser.STRICTFP, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_interfaceMethodModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceMethodModifier"):
                listener.enterInterfaceMethodModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceMethodModifier"):
                listener.exitInterfaceMethodModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceMethodModifier"):
                return visitor.visitInterfaceMethodModifier(self)
            else:
                return visitor.visitChildren(self)

    def interfaceMethodModifier(self):

        localctx = Java20Parser.InterfaceMethodModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_interfaceMethodModifier)
        try:
            self.state = 1544
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1537
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1538
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1539
                self.match(Java20Parser.PRIVATE)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1540
                self.match(Java20Parser.ABSTRACT)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1541
                self.match(Java20Parser.DEFAULT)
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1542
                self.match(Java20Parser.STATIC)
                pass
            elif token in [56]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1543
                self.match(Java20Parser.STRICTFP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationInterfaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(Java20Parser.AT, 0)

        def INTERFACE(self):
            return self.getToken(Java20Parser.INTERFACE, 0)

        def typeIdentifier(self):
            return self.getTypedRuleContext(Java20Parser.TypeIdentifierContext, 0)

        def annotationInterfaceBody(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationInterfaceBodyContext, 0)

        def interfaceModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.InterfaceModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.InterfaceModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotationInterfaceDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotationInterfaceDeclaration"):
                listener.enterAnnotationInterfaceDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotationInterfaceDeclaration"):
                listener.exitAnnotationInterfaceDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotationInterfaceDeclaration"):
                return visitor.visitAnnotationInterfaceDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def annotationInterfaceDeclaration(self):

        localctx = Java20Parser.AnnotationInterfaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_annotationInterfaceDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1549
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 163, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1546
                    self.interfaceModifier()
                self.state = 1551
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 163, self._ctx)

            self.state = 1552
            self.match(Java20Parser.AT)
            self.state = 1553
            self.match(Java20Parser.INTERFACE)
            self.state = 1554
            self.typeIdentifier()
            self.state = 1555
            self.annotationInterfaceBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationInterfaceBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def annotationInterfaceMemberDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationInterfaceMemberDeclarationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationInterfaceMemberDeclarationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotationInterfaceBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotationInterfaceBody"):
                listener.enterAnnotationInterfaceBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotationInterfaceBody"):
                listener.exitAnnotationInterfaceBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotationInterfaceBody"):
                return visitor.visitAnnotationInterfaceBody(self)
            else:
                return visitor.visitChildren(self)

    def annotationInterfaceBody(self):

        localctx = Java20Parser.AnnotationInterfaceBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_annotationInterfaceBody)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1557
            self.match(Java20Parser.LBRACE)
            self.state = 1561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 134105416858864136) != 0) or (
                    (((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & 2199023255569) != 0):
                self.state = 1558
                self.annotationInterfaceMemberDeclaration()
                self.state = 1563
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1564
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationInterfaceMemberDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotationInterfaceElementDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationInterfaceElementDeclarationContext, 0)

        def constantDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ConstantDeclarationContext, 0)

        def classDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassDeclarationContext, 0)

        def interfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.InterfaceDeclarationContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotationInterfaceMemberDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotationInterfaceMemberDeclaration"):
                listener.enterAnnotationInterfaceMemberDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotationInterfaceMemberDeclaration"):
                listener.exitAnnotationInterfaceMemberDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotationInterfaceMemberDeclaration"):
                return visitor.visitAnnotationInterfaceMemberDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def annotationInterfaceMemberDeclaration(self):

        localctx = Java20Parser.AnnotationInterfaceMemberDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_annotationInterfaceMemberDeclaration)
        try:
            self.state = 1571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 165, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1566
                self.annotationInterfaceElementDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1567
                self.constantDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1568
                self.classDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1569
                self.interfaceDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1570
                self.match(Java20Parser.SEMI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationInterfaceElementDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def annotationInterfaceElementModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationInterfaceElementModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationInterfaceElementModifierContext, i)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def defaultValue(self):
            return self.getTypedRuleContext(Java20Parser.DefaultValueContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotationInterfaceElementDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotationInterfaceElementDeclaration"):
                listener.enterAnnotationInterfaceElementDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotationInterfaceElementDeclaration"):
                listener.exitAnnotationInterfaceElementDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotationInterfaceElementDeclaration"):
                return visitor.visitAnnotationInterfaceElementDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def annotationInterfaceElementDeclaration(self):

        localctx = Java20Parser.AnnotationInterfaceElementDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_annotationInterfaceElementDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1576
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 18 or _la == 52 or _la == 86:
                self.state = 1573
                self.annotationInterfaceElementModifier()
                self.state = 1578
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1579
            self.unannType()
            self.state = 1580
            self.match(Java20Parser.Identifier)
            self.state = 1581
            self.match(Java20Parser.LPAREN)
            self.state = 1582
            self.match(Java20Parser.RPAREN)
            self.state = 1584
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 80 or _la == 86:
                self.state = 1583
                self.dims()

            self.state = 1587
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 29:
                self.state = 1586
                self.defaultValue()

            self.state = 1589
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationInterfaceElementModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def PUBLIC(self):
            return self.getToken(Java20Parser.PUBLIC, 0)

        def ABSTRACT(self):
            return self.getToken(Java20Parser.ABSTRACT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotationInterfaceElementModifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotationInterfaceElementModifier"):
                listener.enterAnnotationInterfaceElementModifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotationInterfaceElementModifier"):
                listener.exitAnnotationInterfaceElementModifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotationInterfaceElementModifier"):
                return visitor.visitAnnotationInterfaceElementModifier(self)
            else:
                return visitor.visitChildren(self)

    def annotationInterfaceElementModifier(self):

        localctx = Java20Parser.AnnotationInterfaceElementModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_annotationInterfaceElementModifier)
        try:
            self.state = 1594
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1591
                self.annotation()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1592
                self.match(Java20Parser.PUBLIC)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1593
                self.match(Java20Parser.ABSTRACT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefaultValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT(self):
            return self.getToken(Java20Parser.DEFAULT, 0)

        def elementValue(self):
            return self.getTypedRuleContext(Java20Parser.ElementValueContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_defaultValue

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefaultValue"):
                listener.enterDefaultValue(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefaultValue"):
                listener.exitDefaultValue(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefaultValue"):
                return visitor.visitDefaultValue(self)
            else:
                return visitor.visitChildren(self)

    def defaultValue(self):

        localctx = Java20Parser.DefaultValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_defaultValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1596
            self.match(Java20Parser.DEFAULT)
            self.state = 1597
            self.elementValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def normalAnnotation(self):
            return self.getTypedRuleContext(Java20Parser.NormalAnnotationContext, 0)

        def markerAnnotation(self):
            return self.getTypedRuleContext(Java20Parser.MarkerAnnotationContext, 0)

        def singleElementAnnotation(self):
            return self.getTypedRuleContext(Java20Parser.SingleElementAnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_annotation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnnotation"):
                listener.enterAnnotation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnnotation"):
                listener.exitAnnotation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAnnotation"):
                return visitor.visitAnnotation(self)
            else:
                return visitor.visitChildren(self)

    def annotation(self):

        localctx = Java20Parser.AnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_annotation)
        try:
            self.state = 1602
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 170, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1599
                self.normalAnnotation()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1600
                self.markerAnnotation()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1601
                self.singleElementAnnotation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NormalAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(Java20Parser.AT, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def elementValuePairList(self):
            return self.getTypedRuleContext(Java20Parser.ElementValuePairListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_normalAnnotation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNormalAnnotation"):
                listener.enterNormalAnnotation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNormalAnnotation"):
                listener.exitNormalAnnotation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNormalAnnotation"):
                return visitor.visitNormalAnnotation(self)
            else:
                return visitor.visitChildren(self)

    def normalAnnotation(self):

        localctx = Java20Parser.NormalAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_normalAnnotation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1604
            self.match(Java20Parser.AT)
            self.state = 1605
            self.typeName()
            self.state = 1606
            self.match(Java20Parser.LPAREN)
            self.state = 1608
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 123:
                self.state = 1607
                self.elementValuePairList()

            self.state = 1610
            self.match(Java20Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementValuePairListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementValuePair(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ElementValuePairContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ElementValuePairContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_elementValuePairList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementValuePairList"):
                listener.enterElementValuePairList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementValuePairList"):
                listener.exitElementValuePairList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementValuePairList"):
                return visitor.visitElementValuePairList(self)
            else:
                return visitor.visitChildren(self)

    def elementValuePairList(self):

        localctx = Java20Parser.ElementValuePairListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_elementValuePairList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1612
            self.elementValuePair()
            self.state = 1617
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1613
                self.match(Java20Parser.COMMA)
                self.state = 1614
                self.elementValuePair()
                self.state = 1619
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementValuePairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def ASSIGN(self):
            return self.getToken(Java20Parser.ASSIGN, 0)

        def elementValue(self):
            return self.getTypedRuleContext(Java20Parser.ElementValueContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_elementValuePair

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementValuePair"):
                listener.enterElementValuePair(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementValuePair"):
                listener.exitElementValuePair(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementValuePair"):
                return visitor.visitElementValuePair(self)
            else:
                return visitor.visitChildren(self)

    def elementValuePair(self):

        localctx = Java20Parser.ElementValuePairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_elementValuePair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1620
            self.match(Java20Parser.Identifier)
            self.state = 1621
            self.match(Java20Parser.ASSIGN)
            self.state = 1622
            self.elementValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalExpressionContext, 0)

        def elementValueArrayInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ElementValueArrayInitializerContext, 0)

        def annotation(self):
            return self.getTypedRuleContext(Java20Parser.AnnotationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_elementValue

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementValue"):
                listener.enterElementValue(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementValue"):
                listener.exitElementValue(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementValue"):
                return visitor.visitElementValue(self)
            else:
                return visitor.visitChildren(self)

    def elementValue(self):

        localctx = Java20Parser.ElementValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_elementValue)
        try:
            self.state = 1627
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 173, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1624
                self.conditionalExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1625
                self.elementValueArrayInitializer()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1626
                self.annotation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementValueArrayInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def elementValueList(self):
            return self.getTypedRuleContext(Java20Parser.ElementValueListContext, 0)

        def COMMA(self):
            return self.getToken(Java20Parser.COMMA, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_elementValueArrayInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementValueArrayInitializer"):
                listener.enterElementValueArrayInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementValueArrayInitializer"):
                listener.exitElementValueArrayInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementValueArrayInitializer"):
                return visitor.visitElementValueArrayInitializer(self)
            else:
                return visitor.visitChildren(self)

    def elementValueArrayInitializer(self):

        localctx = Java20Parser.ElementValueArrayInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_elementValueArrayInitializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1629
            self.match(Java20Parser.LBRACE)
            self.state = 1631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939449841) != 0):
                self.state = 1630
                self.elementValueList()

            self.state = 1634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 83:
                self.state = 1633
                self.match(Java20Parser.COMMA)

            self.state = 1636
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElementValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementValue(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ElementValueContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ElementValueContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_elementValueList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementValueList"):
                listener.enterElementValueList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementValueList"):
                listener.exitElementValueList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementValueList"):
                return visitor.visitElementValueList(self)
            else:
                return visitor.visitChildren(self)

    def elementValueList(self):

        localctx = Java20Parser.ElementValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_elementValueList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1638
            self.elementValue()
            self.state = 1643
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 176, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1639
                    self.match(Java20Parser.COMMA)
                    self.state = 1640
                    self.elementValue()
                self.state = 1645
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 176, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MarkerAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(Java20Parser.AT, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_markerAnnotation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMarkerAnnotation"):
                listener.enterMarkerAnnotation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMarkerAnnotation"):
                listener.exitMarkerAnnotation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMarkerAnnotation"):
                return visitor.visitMarkerAnnotation(self)
            else:
                return visitor.visitChildren(self)

    def markerAnnotation(self):

        localctx = Java20Parser.MarkerAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_markerAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1646
            self.match(Java20Parser.AT)
            self.state = 1647
            self.typeName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleElementAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(Java20Parser.AT, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def elementValue(self):
            return self.getTypedRuleContext(Java20Parser.ElementValueContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_singleElementAnnotation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSingleElementAnnotation"):
                listener.enterSingleElementAnnotation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSingleElementAnnotation"):
                listener.exitSingleElementAnnotation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSingleElementAnnotation"):
                return visitor.visitSingleElementAnnotation(self)
            else:
                return visitor.visitChildren(self)

    def singleElementAnnotation(self):

        localctx = Java20Parser.SingleElementAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_singleElementAnnotation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1649
            self.match(Java20Parser.AT)
            self.state = 1650
            self.typeName()
            self.state = 1651
            self.match(Java20Parser.LPAREN)
            self.state = 1652
            self.elementValue()
            self.state = 1653
            self.match(Java20Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def variableInitializerList(self):
            return self.getTypedRuleContext(Java20Parser.VariableInitializerListContext, 0)

        def COMMA(self):
            return self.getToken(Java20Parser.COMMA, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayInitializer"):
                listener.enterArrayInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayInitializer"):
                listener.exitArrayInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayInitializer"):
                return visitor.visitArrayInitializer(self)
            else:
                return visitor.visitChildren(self)

    def arrayInitializer(self):

        localctx = Java20Parser.ArrayInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_arrayInitializer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1655
            self.match(Java20Parser.LBRACE)
            self.state = 1657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939449841) != 0):
                self.state = 1656
                self.variableInitializerList()

            self.state = 1660
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 83:
                self.state = 1659
                self.match(Java20Parser.COMMA)

            self.state = 1662
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableInitializerListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableInitializer(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableInitializerContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableInitializerContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableInitializerList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableInitializerList"):
                listener.enterVariableInitializerList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableInitializerList"):
                listener.exitVariableInitializerList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableInitializerList"):
                return visitor.visitVariableInitializerList(self)
            else:
                return visitor.visitChildren(self)

    def variableInitializerList(self):

        localctx = Java20Parser.VariableInitializerListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_variableInitializerList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1664
            self.variableInitializer()
            self.state = 1669
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 179, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1665
                    self.match(Java20Parser.COMMA)
                    self.state = 1666
                    self.variableInitializer()
                self.state = 1671
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 179, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def blockStatements(self):
            return self.getTypedRuleContext(Java20Parser.BlockStatementsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_block

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBlock"):
                listener.enterBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBlock"):
                listener.exitBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlock"):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)

    def block(self):

        localctx = Java20Parser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_block)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1672
            self.match(Java20Parser.LBRACE)
            self.state = 1674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4610965747420531208) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 576461576941625323) != 0):
                self.state = 1673
                self.blockStatements()

            self.state = 1676
            self.match(Java20Parser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockStatement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.BlockStatementContext)
            else:
                return self.getTypedRuleContext(Java20Parser.BlockStatementContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_blockStatements

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBlockStatements"):
                listener.enterBlockStatements(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBlockStatements"):
                listener.exitBlockStatements(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlockStatements"):
                return visitor.visitBlockStatements(self)
            else:
                return visitor.visitChildren(self)

    def blockStatements(self):

        localctx = Java20Parser.BlockStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_blockStatements)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1678
            self.blockStatement()
            self.state = 1682
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4610965747420531208) != 0) or (
                    (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 576461576941625323) != 0):
                self.state = 1679
                self.blockStatement()
                self.state = 1684
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localClassOrInterfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalClassOrInterfaceDeclarationContext, 0)

        def localVariableDeclarationStatement(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationStatementContext, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_blockStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBlockStatement"):
                listener.enterBlockStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBlockStatement"):
                listener.exitBlockStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlockStatement"):
                return visitor.visitBlockStatement(self)
            else:
                return visitor.visitChildren(self)

    def blockStatement(self):

        localctx = Java20Parser.BlockStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_blockStatement)
        try:
            self.state = 1688
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 182, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1685
                self.localClassOrInterfaceDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1686
                self.localVariableDeclarationStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1687
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalClassOrInterfaceDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.ClassDeclarationContext, 0)

        def normalInterfaceDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.NormalInterfaceDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_localClassOrInterfaceDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocalClassOrInterfaceDeclaration"):
                listener.enterLocalClassOrInterfaceDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocalClassOrInterfaceDeclaration"):
                listener.exitLocalClassOrInterfaceDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocalClassOrInterfaceDeclaration"):
                return visitor.visitLocalClassOrInterfaceDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def localClassOrInterfaceDeclaration(self):

        localctx = Java20Parser.LocalClassOrInterfaceDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_localClassOrInterfaceDeclaration)
        try:
            self.state = 1692
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 183, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1690
                self.classDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1691
                self.normalInterfaceDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableType(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableTypeContext, 0)

        def variableModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableModifierContext, i)

        def variableDeclaratorList(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_localVariableDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocalVariableDeclaration"):
                listener.enterLocalVariableDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocalVariableDeclaration"):
                listener.exitLocalVariableDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocalVariableDeclaration"):
                return visitor.visitLocalVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def localVariableDeclaration(self):

        localctx = Java20Parser.LocalVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_localVariableDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 35 or _la == 86:
                self.state = 1694
                self.variableModifier()
                self.state = 1699
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1700
            self.localVariableType()
            self.state = 1702
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 185, self._ctx)
            if la_ == 1:
                self.state = 1701
                self.variableDeclaratorList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalVariableTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def VAR(self):
            return self.getToken(Java20Parser.VAR, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_localVariableType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocalVariableType"):
                listener.enterLocalVariableType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocalVariableType"):
                listener.exitLocalVariableType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocalVariableType"):
                return visitor.visitLocalVariableType(self)
            else:
                return visitor.visitChildren(self)

    def localVariableType(self):

        localctx = Java20Parser.LocalVariableTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_localVariableType)
        try:
            self.state = 1706
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 54, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1704
                self.unannType()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1705
                self.match(Java20Parser.VAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalVariableDeclarationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_localVariableDeclarationStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLocalVariableDeclarationStatement"):
                listener.enterLocalVariableDeclarationStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLocalVariableDeclarationStatement"):
                listener.exitLocalVariableDeclarationStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLocalVariableDeclarationStatement"):
                return visitor.visitLocalVariableDeclarationStatement(self)
            else:
                return visitor.visitChildren(self)

    def localVariableDeclarationStatement(self):

        localctx = Java20Parser.LocalVariableDeclarationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_localVariableDeclarationStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1708
            self.localVariableDeclaration()
            self.state = 1709
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementWithoutTrailingSubstatement(self):
            return self.getTypedRuleContext(Java20Parser.StatementWithoutTrailingSubstatementContext, 0)

        def labeledStatement(self):
            return self.getTypedRuleContext(Java20Parser.LabeledStatementContext, 0)

        def ifThenStatement(self):
            return self.getTypedRuleContext(Java20Parser.IfThenStatementContext, 0)

        def ifThenElseStatement(self):
            return self.getTypedRuleContext(Java20Parser.IfThenElseStatementContext, 0)

        def whileStatement(self):
            return self.getTypedRuleContext(Java20Parser.WhileStatementContext, 0)

        def forStatement(self):
            return self.getTypedRuleContext(Java20Parser.ForStatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):

        localctx = Java20Parser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_statement)
        try:
            self.state = 1717
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 187, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1711
                self.statementWithoutTrailingSubstatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1712
                self.labeledStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1713
                self.ifThenStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1714
                self.ifThenElseStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1715
                self.whileStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1716
                self.forStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementWithoutTrailingSubstatement(self):
            return self.getTypedRuleContext(Java20Parser.StatementWithoutTrailingSubstatementContext, 0)

        def labeledStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.LabeledStatementNoShortIfContext, 0)

        def ifThenElseStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.IfThenElseStatementNoShortIfContext, 0)

        def whileStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.WhileStatementNoShortIfContext, 0)

        def forStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.ForStatementNoShortIfContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_statementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatementNoShortIf"):
                listener.enterStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatementNoShortIf"):
                listener.exitStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatementNoShortIf"):
                return visitor.visitStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def statementNoShortIf(self):

        localctx = Java20Parser.StatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_statementNoShortIf)
        try:
            self.state = 1724
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 188, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1719
                self.statementWithoutTrailingSubstatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1720
                self.labeledStatementNoShortIf()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1721
                self.ifThenElseStatementNoShortIf()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1722
                self.whileStatementNoShortIf()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1723
                self.forStatementNoShortIf()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementWithoutTrailingSubstatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def emptyStatement_(self):
            return self.getTypedRuleContext(Java20Parser.EmptyStatement_Context, 0)

        def expressionStatement(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionStatementContext, 0)

        def assertStatement(self):
            return self.getTypedRuleContext(Java20Parser.AssertStatementContext, 0)

        def switchStatement(self):
            return self.getTypedRuleContext(Java20Parser.SwitchStatementContext, 0)

        def doStatement(self):
            return self.getTypedRuleContext(Java20Parser.DoStatementContext, 0)

        def breakStatement(self):
            return self.getTypedRuleContext(Java20Parser.BreakStatementContext, 0)

        def continueStatement(self):
            return self.getTypedRuleContext(Java20Parser.ContinueStatementContext, 0)

        def returnStatement(self):
            return self.getTypedRuleContext(Java20Parser.ReturnStatementContext, 0)

        def synchronizedStatement(self):
            return self.getTypedRuleContext(Java20Parser.SynchronizedStatementContext, 0)

        def throwStatement(self):
            return self.getTypedRuleContext(Java20Parser.ThrowStatementContext, 0)

        def tryStatement(self):
            return self.getTypedRuleContext(Java20Parser.TryStatementContext, 0)

        def yieldStatement(self):
            return self.getTypedRuleContext(Java20Parser.YieldStatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_statementWithoutTrailingSubstatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatementWithoutTrailingSubstatement"):
                listener.enterStatementWithoutTrailingSubstatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatementWithoutTrailingSubstatement"):
                listener.exitStatementWithoutTrailingSubstatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatementWithoutTrailingSubstatement"):
                return visitor.visitStatementWithoutTrailingSubstatement(self)
            else:
                return visitor.visitChildren(self)

    def statementWithoutTrailingSubstatement(self):

        localctx = Java20Parser.StatementWithoutTrailingSubstatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_statementWithoutTrailingSubstatement)
        try:
            self.state = 1739
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1726
                self.block()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1727
                self.emptyStatement_()
                pass
            elif token in [20, 22, 25, 31, 37, 44, 46, 48, 54, 57, 60, 65, 69, 70, 71, 72, 73, 74, 75, 76, 86, 102, 103,
                           123]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1728
                self.expressionStatement()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1729
                self.assertStatement()
                pass
            elif token in [58]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1730
                self.switchStatement()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1731
                self.doStatement()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1732
                self.breakStatement()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1733
                self.continueStatement()
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1734
                self.returnStatement()
                pass
            elif token in [59]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1735
                self.synchronizedStatement()
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1736
                self.throwStatement()
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1737
                self.tryStatement()
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1738
                self.yieldStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EmptyStatement_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_emptyStatement_

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEmptyStatement_"):
                listener.enterEmptyStatement_(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEmptyStatement_"):
                listener.exitEmptyStatement_(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEmptyStatement_"):
                return visitor.visitEmptyStatement_(self)
            else:
                return visitor.visitChildren(self)

    def emptyStatement_(self):

        localctx = Java20Parser.EmptyStatement_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_emptyStatement_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1741
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabeledStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_labeledStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLabeledStatement"):
                listener.enterLabeledStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLabeledStatement"):
                listener.exitLabeledStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLabeledStatement"):
                return visitor.visitLabeledStatement(self)
            else:
                return visitor.visitChildren(self)

    def labeledStatement(self):

        localctx = Java20Parser.LabeledStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_labeledStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1743
            self.match(Java20Parser.Identifier)
            self.state = 1744
            self.match(Java20Parser.COLON)
            self.state = 1745
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabeledStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def statementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_labeledStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLabeledStatementNoShortIf"):
                listener.enterLabeledStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLabeledStatementNoShortIf"):
                listener.exitLabeledStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLabeledStatementNoShortIf"):
                return visitor.visitLabeledStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def labeledStatementNoShortIf(self):

        localctx = Java20Parser.LabeledStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_labeledStatementNoShortIf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1747
            self.match(Java20Parser.Identifier)
            self.state = 1748
            self.match(Java20Parser.COLON)
            self.state = 1749
            self.statementNoShortIf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementExpression(self):
            return self.getTypedRuleContext(Java20Parser.StatementExpressionContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_expressionStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpressionStatement"):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpressionStatement"):
                listener.exitExpressionStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpressionStatement"):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)

    def expressionStatement(self):

        localctx = Java20Parser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1751
            self.statementExpression()
            self.state = 1752
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(Java20Parser.AssignmentContext, 0)

        def preIncrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PreIncrementExpressionContext, 0)

        def preDecrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PreDecrementExpressionContext, 0)

        def postIncrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PostIncrementExpressionContext, 0)

        def postDecrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PostDecrementExpressionContext, 0)

        def methodInvocation(self):
            return self.getTypedRuleContext(Java20Parser.MethodInvocationContext, 0)

        def classInstanceCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.ClassInstanceCreationExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_statementExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatementExpression"):
                listener.enterStatementExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatementExpression"):
                listener.exitStatementExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatementExpression"):
                return visitor.visitStatementExpression(self)
            else:
                return visitor.visitChildren(self)

    def statementExpression(self):

        localctx = Java20Parser.StatementExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_statementExpression)
        try:
            self.state = 1761
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 190, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1754
                self.assignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1755
                self.preIncrementExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1756
                self.preDecrementExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1757
                self.postIncrementExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1758
                self.postDecrementExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1759
                self.methodInvocation()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1760
                self.classInstanceCreationExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfThenStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(Java20Parser.IF, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_ifThenStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIfThenStatement"):
                listener.enterIfThenStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIfThenStatement"):
                listener.exitIfThenStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIfThenStatement"):
                return visitor.visitIfThenStatement(self)
            else:
                return visitor.visitChildren(self)

    def ifThenStatement(self):

        localctx = Java20Parser.IfThenStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_ifThenStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1763
            self.match(Java20Parser.IF)
            self.state = 1764
            self.match(Java20Parser.LPAREN)
            self.state = 1765
            self.expression()
            self.state = 1766
            self.match(Java20Parser.RPAREN)
            self.state = 1767
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfThenElseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(Java20Parser.IF, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, 0)

        def ELSE(self):
            return self.getToken(Java20Parser.ELSE, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_ifThenElseStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIfThenElseStatement"):
                listener.enterIfThenElseStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIfThenElseStatement"):
                listener.exitIfThenElseStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIfThenElseStatement"):
                return visitor.visitIfThenElseStatement(self)
            else:
                return visitor.visitChildren(self)

    def ifThenElseStatement(self):

        localctx = Java20Parser.IfThenElseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_ifThenElseStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1769
            self.match(Java20Parser.IF)
            self.state = 1770
            self.match(Java20Parser.LPAREN)
            self.state = 1771
            self.expression()
            self.state = 1772
            self.match(Java20Parser.RPAREN)
            self.state = 1773
            self.statementNoShortIf()
            self.state = 1774
            self.match(Java20Parser.ELSE)
            self.state = 1775
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfThenElseStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(Java20Parser.IF, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statementNoShortIf(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.StatementNoShortIfContext)
            else:
                return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, i)

        def ELSE(self):
            return self.getToken(Java20Parser.ELSE, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_ifThenElseStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIfThenElseStatementNoShortIf"):
                listener.enterIfThenElseStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIfThenElseStatementNoShortIf"):
                listener.exitIfThenElseStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIfThenElseStatementNoShortIf"):
                return visitor.visitIfThenElseStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def ifThenElseStatementNoShortIf(self):

        localctx = Java20Parser.IfThenElseStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_ifThenElseStatementNoShortIf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1777
            self.match(Java20Parser.IF)
            self.state = 1778
            self.match(Java20Parser.LPAREN)
            self.state = 1779
            self.expression()
            self.state = 1780
            self.match(Java20Parser.RPAREN)
            self.state = 1781
            self.statementNoShortIf()
            self.state = 1782
            self.match(Java20Parser.ELSE)
            self.state = 1783
            self.statementNoShortIf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(Java20Parser.ASSERT, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ExpressionContext, i)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_assertStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssertStatement"):
                listener.enterAssertStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssertStatement"):
                listener.exitAssertStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssertStatement"):
                return visitor.visitAssertStatement(self)
            else:
                return visitor.visitChildren(self)

    def assertStatement(self):

        localctx = Java20Parser.AssertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_assertStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1785
            self.match(Java20Parser.ASSERT)
            self.state = 1786
            self.expression()
            self.state = 1789
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 94:
                self.state = 1787
                self.match(Java20Parser.COLON)
                self.state = 1788
                self.expression()

            self.state = 1791
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(Java20Parser.SWITCH, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def switchBlock(self):
            return self.getTypedRuleContext(Java20Parser.SwitchBlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchStatement"):
                listener.enterSwitchStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchStatement"):
                listener.exitSwitchStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchStatement"):
                return visitor.visitSwitchStatement(self)
            else:
                return visitor.visitChildren(self)

    def switchStatement(self):

        localctx = Java20Parser.SwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_switchStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1793
            self.match(Java20Parser.SWITCH)
            self.state = 1794
            self.match(Java20Parser.LPAREN)
            self.state = 1795
            self.expression()
            self.state = 1796
            self.match(Java20Parser.RPAREN)
            self.state = 1797
            self.switchBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(Java20Parser.LBRACE, 0)

        def switchRule(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.SwitchRuleContext)
            else:
                return self.getTypedRuleContext(Java20Parser.SwitchRuleContext, i)

        def RBRACE(self):
            return self.getToken(Java20Parser.RBRACE, 0)

        def switchBlockStatementGroup(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.SwitchBlockStatementGroupContext)
            else:
                return self.getTypedRuleContext(Java20Parser.SwitchBlockStatementGroupContext, i)

        def switchLabel(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.SwitchLabelContext)
            else:
                return self.getTypedRuleContext(Java20Parser.SwitchLabelContext, i)

        def COLON(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COLON)
            else:
                return self.getToken(Java20Parser.COLON, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchBlock

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchBlock"):
                listener.enterSwitchBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchBlock"):
                listener.exitSwitchBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchBlock"):
                return visitor.visitSwitchBlock(self)
            else:
                return visitor.visitChildren(self)

    def switchBlock(self):

        localctx = Java20Parser.SwitchBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_switchBlock)
        self._la = 0  # Token type
        try:
            self.state = 1825
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 195, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1799
                self.match(Java20Parser.LBRACE)
                self.state = 1800
                self.switchRule()
                self.state = 1804
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 23 or _la == 29:
                    self.state = 1801
                    self.switchRule()
                    self.state = 1806
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1807
                self.match(Java20Parser.RBRACE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1809
                self.match(Java20Parser.LBRACE)
                self.state = 1813
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 193, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1810
                        self.switchBlockStatementGroup()
                    self.state = 1815
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input, 193, self._ctx)

                self.state = 1821
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 23 or _la == 29:
                    self.state = 1816
                    self.switchLabel()
                    self.state = 1817
                    self.match(Java20Parser.COLON)
                    self.state = 1823
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1824
                self.match(Java20Parser.RBRACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switchLabel(self):
            return self.getTypedRuleContext(Java20Parser.SwitchLabelContext, 0)

        def ARROW(self):
            return self.getToken(Java20Parser.ARROW, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def throwStatement(self):
            return self.getTypedRuleContext(Java20Parser.ThrowStatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchRule

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchRule"):
                listener.enterSwitchRule(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchRule"):
                listener.exitSwitchRule(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchRule"):
                return visitor.visitSwitchRule(self)
            else:
                return visitor.visitChildren(self)

    def switchRule(self):

        localctx = Java20Parser.SwitchRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_switchRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1827
            self.switchLabel()
            self.state = 1828
            self.match(Java20Parser.ARROW)
            self.state = 1834
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 48, 54, 57, 58, 60, 65, 69, 70, 71, 72, 73, 74, 75, 76, 86, 91, 92,
                         102, 103, 104, 105, 123]:
                self.state = 1829
                self.expression()
                self.state = 1830
                self.match(Java20Parser.SEMI)
                pass
            elif token in [78]:
                self.state = 1832
                self.block()
                pass
            elif token in [61]:
                self.state = 1833
                self.throwStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchBlockStatementGroupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switchLabel(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.SwitchLabelContext)
            else:
                return self.getTypedRuleContext(Java20Parser.SwitchLabelContext, i)

        def COLON(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COLON)
            else:
                return self.getToken(Java20Parser.COLON, i)

        def blockStatements(self):
            return self.getTypedRuleContext(Java20Parser.BlockStatementsContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchBlockStatementGroup

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchBlockStatementGroup"):
                listener.enterSwitchBlockStatementGroup(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchBlockStatementGroup"):
                listener.exitSwitchBlockStatementGroup(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchBlockStatementGroup"):
                return visitor.visitSwitchBlockStatementGroup(self)
            else:
                return visitor.visitChildren(self)

    def switchBlockStatementGroup(self):

        localctx = Java20Parser.SwitchBlockStatementGroupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_switchBlockStatementGroup)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1836
            self.switchLabel()
            self.state = 1837
            self.match(Java20Parser.COLON)
            self.state = 1843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 23 or _la == 29:
                self.state = 1838
                self.switchLabel()
                self.state = 1839
                self.match(Java20Parser.COLON)
                self.state = 1845
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1846
            self.blockStatements()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchLabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(Java20Parser.CASE, 0)

        def caseConstant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.CaseConstantContext)
            else:
                return self.getTypedRuleContext(Java20Parser.CaseConstantContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def DEFAULT(self):
            return self.getToken(Java20Parser.DEFAULT, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchLabel

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchLabel"):
                listener.enterSwitchLabel(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchLabel"):
                listener.exitSwitchLabel(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchLabel"):
                return visitor.visitSwitchLabel(self)
            else:
                return visitor.visitChildren(self)

    def switchLabel(self):

        localctx = Java20Parser.SwitchLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_switchLabel)
        self._la = 0  # Token type
        try:
            self.state = 1858
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1848
                self.match(Java20Parser.CASE)
                self.state = 1849
                self.caseConstant()
                self.state = 1854
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 83:
                    self.state = 1850
                    self.match(Java20Parser.COMMA)
                    self.state = 1851
                    self.caseConstant()
                    self.state = 1856
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1857
                self.match(Java20Parser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_caseConstant

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCaseConstant"):
                listener.enterCaseConstant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCaseConstant"):
                listener.exitCaseConstant(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCaseConstant"):
                return visitor.visitCaseConstant(self)
            else:
                return visitor.visitChildren(self)

    def caseConstant(self):

        localctx = Java20Parser.CaseConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_caseConstant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1860
            self.conditionalExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(Java20Parser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_whileStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhileStatement"):
                listener.enterWhileStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhileStatement"):
                listener.exitWhileStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhileStatement"):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)

    def whileStatement(self):

        localctx = Java20Parser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_whileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1862
            self.match(Java20Parser.WHILE)
            self.state = 1863
            self.match(Java20Parser.LPAREN)
            self.state = 1864
            self.expression()
            self.state = 1865
            self.match(Java20Parser.RPAREN)
            self.state = 1866
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhileStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(Java20Parser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_whileStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhileStatementNoShortIf"):
                listener.enterWhileStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhileStatementNoShortIf"):
                listener.exitWhileStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhileStatementNoShortIf"):
                return visitor.visitWhileStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def whileStatementNoShortIf(self):

        localctx = Java20Parser.WhileStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_whileStatementNoShortIf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1868
            self.match(Java20Parser.WHILE)
            self.state = 1869
            self.match(Java20Parser.LPAREN)
            self.state = 1870
            self.expression()
            self.state = 1871
            self.match(Java20Parser.RPAREN)
            self.state = 1872
            self.statementNoShortIf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(Java20Parser.DO, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def WHILE(self):
            return self.getToken(Java20Parser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_doStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDoStatement"):
                listener.enterDoStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDoStatement"):
                listener.exitDoStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDoStatement"):
                return visitor.visitDoStatement(self)
            else:
                return visitor.visitChildren(self)

    def doStatement(self):

        localctx = Java20Parser.DoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_doStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1874
            self.match(Java20Parser.DO)
            self.state = 1875
            self.statement()
            self.state = 1876
            self.match(Java20Parser.WHILE)
            self.state = 1877
            self.match(Java20Parser.LPAREN)
            self.state = 1878
            self.expression()
            self.state = 1879
            self.match(Java20Parser.RPAREN)
            self.state = 1880
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicForStatement(self):
            return self.getTypedRuleContext(Java20Parser.BasicForStatementContext, 0)

        def enhancedForStatement(self):
            return self.getTypedRuleContext(Java20Parser.EnhancedForStatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_forStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForStatement"):
                listener.enterForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForStatement"):
                listener.exitForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForStatement"):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)

    def forStatement(self):

        localctx = Java20Parser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_forStatement)
        try:
            self.state = 1884
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 200, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1882
                self.basicForStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1883
                self.enhancedForStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basicForStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.BasicForStatementNoShortIfContext, 0)

        def enhancedForStatementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.EnhancedForStatementNoShortIfContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_forStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForStatementNoShortIf"):
                listener.enterForStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForStatementNoShortIf"):
                listener.exitForStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForStatementNoShortIf"):
                return visitor.visitForStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def forStatementNoShortIf(self):

        localctx = Java20Parser.ForStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_forStatementNoShortIf)
        try:
            self.state = 1888
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 201, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1886
                self.basicForStatementNoShortIf()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1887
                self.enhancedForStatementNoShortIf()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(Java20Parser.FOR, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def SEMI(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.SEMI)
            else:
                return self.getToken(Java20Parser.SEMI, i)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def forInit(self):
            return self.getTypedRuleContext(Java20Parser.ForInitContext, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def forUpdate(self):
            return self.getTypedRuleContext(Java20Parser.ForUpdateContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_basicForStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBasicForStatement"):
                listener.enterBasicForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBasicForStatement"):
                listener.exitBasicForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBasicForStatement"):
                return visitor.visitBasicForStatement(self)
            else:
                return visitor.visitChildren(self)

    def basicForStatement(self):

        localctx = Java20Parser.BasicForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_basicForStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1890
            self.match(Java20Parser.FOR)
            self.state = 1891
            self.match(Java20Parser.LPAREN)
            self.state = 1893
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1315420701084123136) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230788470673393) != 0):
                self.state = 1892
                self.forInit()

            self.state = 1895
            self.match(Java20Parser.SEMI)
            self.state = 1897
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                self.state = 1896
                self.expression()

            self.state = 1899
            self.match(Java20Parser.SEMI)
            self.state = 1901
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1315420666724352000) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230788470673393) != 0):
                self.state = 1900
                self.forUpdate()

            self.state = 1903
            self.match(Java20Parser.RPAREN)
            self.state = 1904
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicForStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(Java20Parser.FOR, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def SEMI(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.SEMI)
            else:
                return self.getToken(Java20Parser.SEMI, i)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, 0)

        def forInit(self):
            return self.getTypedRuleContext(Java20Parser.ForInitContext, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def forUpdate(self):
            return self.getTypedRuleContext(Java20Parser.ForUpdateContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_basicForStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBasicForStatementNoShortIf"):
                listener.enterBasicForStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBasicForStatementNoShortIf"):
                listener.exitBasicForStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBasicForStatementNoShortIf"):
                return visitor.visitBasicForStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def basicForStatementNoShortIf(self):

        localctx = Java20Parser.BasicForStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_basicForStatementNoShortIf)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1906
            self.match(Java20Parser.FOR)
            self.state = 1907
            self.match(Java20Parser.LPAREN)
            self.state = 1909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1315420701084123136) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230788470673393) != 0):
                self.state = 1908
                self.forInit()

            self.state = 1911
            self.match(Java20Parser.SEMI)
            self.state = 1913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                self.state = 1912
                self.expression()

            self.state = 1915
            self.match(Java20Parser.SEMI)
            self.state = 1917
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1315420666724352000) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288230788470673393) != 0):
                self.state = 1916
                self.forUpdate()

            self.state = 1919
            self.match(Java20Parser.RPAREN)
            self.state = 1920
            self.statementNoShortIf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementExpressionList(self):
            return self.getTypedRuleContext(Java20Parser.StatementExpressionListContext, 0)

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_forInit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForInit"):
                listener.enterForInit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForInit"):
                listener.exitForInit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForInit"):
                return visitor.visitForInit(self)
            else:
                return visitor.visitChildren(self)

    def forInit(self):

        localctx = Java20Parser.ForInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_forInit)
        try:
            self.state = 1924
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 208, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1922
                self.statementExpressionList()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1923
                self.localVariableDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementExpressionList(self):
            return self.getTypedRuleContext(Java20Parser.StatementExpressionListContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_forUpdate

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForUpdate"):
                listener.enterForUpdate(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForUpdate"):
                listener.exitForUpdate(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForUpdate"):
                return visitor.visitForUpdate(self)
            else:
                return visitor.visitChildren(self)

    def forUpdate(self):

        localctx = Java20Parser.ForUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_forUpdate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1926
            self.statementExpressionList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementExpressionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementExpression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.StatementExpressionContext)
            else:
                return self.getTypedRuleContext(Java20Parser.StatementExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_statementExpressionList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatementExpressionList"):
                listener.enterStatementExpressionList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatementExpressionList"):
                listener.exitStatementExpressionList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatementExpressionList"):
                return visitor.visitStatementExpressionList(self)
            else:
                return visitor.visitChildren(self)

    def statementExpressionList(self):

        localctx = Java20Parser.StatementExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_statementExpressionList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1928
            self.statementExpression()
            self.state = 1933
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 1929
                self.match(Java20Parser.COMMA)
                self.state = 1930
                self.statementExpression()
                self.state = 1935
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnhancedForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(Java20Parser.FOR, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(Java20Parser.StatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enhancedForStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnhancedForStatement"):
                listener.enterEnhancedForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnhancedForStatement"):
                listener.exitEnhancedForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnhancedForStatement"):
                return visitor.visitEnhancedForStatement(self)
            else:
                return visitor.visitChildren(self)

    def enhancedForStatement(self):

        localctx = Java20Parser.EnhancedForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_enhancedForStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1936
            self.match(Java20Parser.FOR)
            self.state = 1937
            self.match(Java20Parser.LPAREN)
            self.state = 1938
            self.localVariableDeclaration()
            self.state = 1939
            self.match(Java20Parser.COLON)
            self.state = 1940
            self.expression()
            self.state = 1941
            self.match(Java20Parser.RPAREN)
            self.state = 1942
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnhancedForStatementNoShortIfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(Java20Parser.FOR, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def statementNoShortIf(self):
            return self.getTypedRuleContext(Java20Parser.StatementNoShortIfContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_enhancedForStatementNoShortIf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnhancedForStatementNoShortIf"):
                listener.enterEnhancedForStatementNoShortIf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnhancedForStatementNoShortIf"):
                listener.exitEnhancedForStatementNoShortIf(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnhancedForStatementNoShortIf"):
                return visitor.visitEnhancedForStatementNoShortIf(self)
            else:
                return visitor.visitChildren(self)

    def enhancedForStatementNoShortIf(self):

        localctx = Java20Parser.EnhancedForStatementNoShortIfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_enhancedForStatementNoShortIf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1944
            self.match(Java20Parser.FOR)
            self.state = 1945
            self.match(Java20Parser.LPAREN)
            self.state = 1946
            self.localVariableDeclaration()
            self.state = 1947
            self.match(Java20Parser.COLON)
            self.state = 1948
            self.expression()
            self.state = 1949
            self.match(Java20Parser.RPAREN)
            self.state = 1950
            self.statementNoShortIf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(Java20Parser.BREAK, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_breakStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBreakStatement"):
                listener.enterBreakStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBreakStatement"):
                listener.exitBreakStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBreakStatement"):
                return visitor.visitBreakStatement(self)
            else:
                return visitor.visitChildren(self)

    def breakStatement(self):

        localctx = Java20Parser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_breakStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1952
            self.match(Java20Parser.BREAK)
            self.state = 1954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 123:
                self.state = 1953
                self.match(Java20Parser.Identifier)

            self.state = 1956
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(Java20Parser.CONTINUE, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_continueStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContinueStatement"):
                listener.enterContinueStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContinueStatement"):
                listener.exitContinueStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContinueStatement"):
                return visitor.visitContinueStatement(self)
            else:
                return visitor.visitChildren(self)

    def continueStatement(self):

        localctx = Java20Parser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_continueStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1958
            self.match(Java20Parser.CONTINUE)
            self.state = 1960
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 123:
                self.state = 1959
                self.match(Java20Parser.Identifier)

            self.state = 1962
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(Java20Parser.RETURN, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_returnStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturnStatement"):
                listener.enterReturnStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturnStatement"):
                listener.exitReturnStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReturnStatement"):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)

    def returnStatement(self):

        localctx = Java20Parser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_returnStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1964
            self.match(Java20Parser.RETURN)
            self.state = 1966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                self.state = 1965
                self.expression()

            self.state = 1968
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ThrowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THROW(self):
            return self.getToken(Java20Parser.THROW, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_throwStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterThrowStatement"):
                listener.enterThrowStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitThrowStatement"):
                listener.exitThrowStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitThrowStatement"):
                return visitor.visitThrowStatement(self)
            else:
                return visitor.visitChildren(self)

    def throwStatement(self):

        localctx = Java20Parser.ThrowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_throwStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1970
            self.match(Java20Parser.THROW)
            self.state = 1971
            self.expression()
            self.state = 1972
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SynchronizedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SYNCHRONIZED(self):
            return self.getToken(Java20Parser.SYNCHRONIZED, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_synchronizedStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSynchronizedStatement"):
                listener.enterSynchronizedStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSynchronizedStatement"):
                listener.exitSynchronizedStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSynchronizedStatement"):
                return visitor.visitSynchronizedStatement(self)
            else:
                return visitor.visitChildren(self)

    def synchronizedStatement(self):

        localctx = Java20Parser.SynchronizedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_synchronizedStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1974
            self.match(Java20Parser.SYNCHRONIZED)
            self.state = 1975
            self.match(Java20Parser.LPAREN)
            self.state = 1976
            self.expression()
            self.state = 1977
            self.match(Java20Parser.RPAREN)
            self.state = 1978
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRY(self):
            return self.getToken(Java20Parser.TRY, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def catches(self):
            return self.getTypedRuleContext(Java20Parser.CatchesContext, 0)

        def finallyBlock(self):
            return self.getTypedRuleContext(Java20Parser.FinallyBlockContext, 0)

        def tryWithResourcesStatement(self):
            return self.getTypedRuleContext(Java20Parser.TryWithResourcesStatementContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_tryStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTryStatement"):
                listener.enterTryStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTryStatement"):
                listener.exitTryStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTryStatement"):
                return visitor.visitTryStatement(self)
            else:
                return visitor.visitChildren(self)

    def tryStatement(self):

        localctx = Java20Parser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_tryStatement)
        self._la = 0  # Token type
        try:
            self.state = 1996
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 214, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1980
                self.match(Java20Parser.TRY)
                self.state = 1981
                self.block()
                self.state = 1982
                self.catches()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1984
                self.match(Java20Parser.TRY)
                self.state = 1985
                self.block()
                self.state = 1986
                self.finallyBlock()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1988
                self.match(Java20Parser.TRY)
                self.state = 1989
                self.block()
                self.state = 1991
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 24:
                    self.state = 1990
                    self.catches()

                self.state = 1993
                self.finallyBlock()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1995
                self.tryWithResourcesStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CatchesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def catchClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(Java20Parser.CatchClauseContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_catches

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatches"):
                listener.enterCatches(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatches"):
                listener.exitCatches(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatches"):
                return visitor.visitCatches(self)
            else:
                return visitor.visitChildren(self)

    def catches(self):

        localctx = Java20Parser.CatchesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_catches)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1998
            self.catchClause()
            self.state = 2002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 24:
                self.state = 1999
                self.catchClause()
                self.state = 2004
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CATCH(self):
            return self.getToken(Java20Parser.CATCH, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def catchFormalParameter(self):
            return self.getTypedRuleContext(Java20Parser.CatchFormalParameterContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_catchClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatchClause"):
                listener.enterCatchClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatchClause"):
                listener.exitCatchClause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatchClause"):
                return visitor.visitCatchClause(self)
            else:
                return visitor.visitChildren(self)

    def catchClause(self):

        localctx = Java20Parser.CatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_catchClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2005
            self.match(Java20Parser.CATCH)
            self.state = 2006
            self.match(Java20Parser.LPAREN)
            self.state = 2007
            self.catchFormalParameter()
            self.state = 2008
            self.match(Java20Parser.RPAREN)
            self.state = 2009
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CatchFormalParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def catchType(self):
            return self.getTypedRuleContext(Java20Parser.CatchTypeContext, 0)

        def variableDeclaratorId(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorIdContext, 0)

        def variableModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableModifierContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_catchFormalParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatchFormalParameter"):
                listener.enterCatchFormalParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatchFormalParameter"):
                listener.exitCatchFormalParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatchFormalParameter"):
                return visitor.visitCatchFormalParameter(self)
            else:
                return visitor.visitChildren(self)

    def catchFormalParameter(self):

        localctx = Java20Parser.CatchFormalParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_catchFormalParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2014
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 35 or _la == 86:
                self.state = 2011
                self.variableModifier()
                self.state = 2016
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2017
            self.catchType()
            self.state = 2018
            self.variableDeclaratorId()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CatchTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannClassType(self):
            return self.getTypedRuleContext(Java20Parser.UnannClassTypeContext, 0)

        def BITOR(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.BITOR)
            else:
                return self.getToken(Java20Parser.BITOR, i)

        def classType(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ClassTypeContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ClassTypeContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_catchType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatchType"):
                listener.enterCatchType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatchType"):
                listener.exitCatchType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatchType"):
                return visitor.visitCatchType(self)
            else:
                return visitor.visitChildren(self)

    def catchType(self):

        localctx = Java20Parser.CatchTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_catchType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2020
            self.unannClassType()
            self.state = 2025
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 109:
                self.state = 2021
                self.match(Java20Parser.BITOR)
                self.state = 2022
                self.classType()
                self.state = 2027
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FinallyBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FINALLY(self):
            return self.getToken(Java20Parser.FINALLY, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_finallyBlock

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFinallyBlock"):
                listener.enterFinallyBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFinallyBlock"):
                listener.exitFinallyBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFinallyBlock"):
                return visitor.visitFinallyBlock(self)
            else:
                return visitor.visitChildren(self)

    def finallyBlock(self):

        localctx = Java20Parser.FinallyBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_finallyBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2028
            self.match(Java20Parser.FINALLY)
            self.state = 2029
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TryWithResourcesStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRY(self):
            return self.getToken(Java20Parser.TRY, 0)

        def resourceSpecification(self):
            return self.getTypedRuleContext(Java20Parser.ResourceSpecificationContext, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def catches(self):
            return self.getTypedRuleContext(Java20Parser.CatchesContext, 0)

        def finallyBlock(self):
            return self.getTypedRuleContext(Java20Parser.FinallyBlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_tryWithResourcesStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTryWithResourcesStatement"):
                listener.enterTryWithResourcesStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTryWithResourcesStatement"):
                listener.exitTryWithResourcesStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTryWithResourcesStatement"):
                return visitor.visitTryWithResourcesStatement(self)
            else:
                return visitor.visitChildren(self)

    def tryWithResourcesStatement(self):

        localctx = Java20Parser.TryWithResourcesStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_tryWithResourcesStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2031
            self.match(Java20Parser.TRY)
            self.state = 2032
            self.resourceSpecification()
            self.state = 2033
            self.block()
            self.state = 2035
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 24:
                self.state = 2034
                self.catches()

            self.state = 2038
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 36:
                self.state = 2037
                self.finallyBlock()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResourceSpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def resourceList(self):
            return self.getTypedRuleContext(Java20Parser.ResourceListContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_resourceSpecification

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterResourceSpecification"):
                listener.enterResourceSpecification(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitResourceSpecification"):
                listener.exitResourceSpecification(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResourceSpecification"):
                return visitor.visitResourceSpecification(self)
            else:
                return visitor.visitChildren(self)

    def resourceSpecification(self):

        localctx = Java20Parser.ResourceSpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_resourceSpecification)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2040
            self.match(Java20Parser.LPAREN)
            self.state = 2041
            self.resourceList()
            self.state = 2043
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 82:
                self.state = 2042
                self.match(Java20Parser.SEMI)

            self.state = 2045
            self.match(Java20Parser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResourceListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resource(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ResourceContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ResourceContext, i)

        def SEMI(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.SEMI)
            else:
                return self.getToken(Java20Parser.SEMI, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_resourceList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterResourceList"):
                listener.enterResourceList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitResourceList"):
                listener.exitResourceList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResourceList"):
                return visitor.visitResourceList(self)
            else:
                return visitor.visitChildren(self)

    def resourceList(self):

        localctx = Java20Parser.ResourceListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_resourceList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2047
            self.resource()
            self.state = 2052
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 221, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2048
                    self.match(Java20Parser.SEMI)
                    self.state = 2049
                    self.resource()
                self.state = 2054
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 221, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ResourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def variableAccess(self):
            return self.getTypedRuleContext(Java20Parser.VariableAccessContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_resource

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterResource"):
                listener.enterResource(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitResource"):
                listener.exitResource(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitResource"):
                return visitor.visitResource(self)
            else:
                return visitor.visitChildren(self)

    def resource(self):

        localctx = Java20Parser.ResourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_resource)
        try:
            self.state = 2057
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 222, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2055
                self.localVariableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2056
                self.variableAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def fieldAccess(self):
            return self.getTypedRuleContext(Java20Parser.FieldAccessContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_variableAccess

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableAccess"):
                listener.enterVariableAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableAccess"):
                listener.exitVariableAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableAccess"):
                return visitor.visitVariableAccess(self)
            else:
                return visitor.visitChildren(self)

    def variableAccess(self):

        localctx = Java20Parser.VariableAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_variableAccess)
        try:
            self.state = 2061
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 223, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2059
                self.expressionName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2060
                self.fieldAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YieldStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YIELD(self):
            return self.getToken(Java20Parser.YIELD, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def SEMI(self):
            return self.getToken(Java20Parser.SEMI, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_yieldStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYieldStatement"):
                listener.enterYieldStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYieldStatement"):
                listener.exitYieldStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYieldStatement"):
                return visitor.visitYieldStatement(self)
            else:
                return visitor.visitChildren(self)

    def yieldStatement(self):

        localctx = Java20Parser.YieldStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_yieldStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2063
            self.match(Java20Parser.YIELD)
            self.state = 2064
            self.expression()
            self.state = 2065
            self.match(Java20Parser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typePattern(self):
            return self.getTypedRuleContext(Java20Parser.TypePatternContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_pattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPattern"):
                listener.enterPattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPattern"):
                listener.exitPattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPattern"):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)

    def pattern(self):

        localctx = Java20Parser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_pattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2067
            self.typePattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypePatternContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def localVariableDeclaration(self):
            return self.getTypedRuleContext(Java20Parser.LocalVariableDeclarationContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typePattern

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypePattern"):
                listener.enterTypePattern(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypePattern"):
                listener.exitTypePattern(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypePattern"):
                return visitor.visitTypePattern(self)
            else:
                return visitor.visitChildren(self)

    def typePattern(self):

        localctx = Java20Parser.TypePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_typePattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2069
            self.localVariableDeclaration()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaExpression(self):
            return self.getTypedRuleContext(Java20Parser.LambdaExpressionContext, 0)

        def assignmentExpression(self):
            return self.getTypedRuleContext(Java20Parser.AssignmentExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self):

        localctx = Java20Parser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_expression)
        try:
            self.state = 2073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 224, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2071
                self.lambdaExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2072
                self.assignmentExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryNoNewArray(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryNoNewArrayContext, 0)

        def arrayCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_primary

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimary"):
                listener.enterPrimary(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimary"):
                listener.exitPrimary(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimary"):
                return visitor.visitPrimary(self)
            else:
                return visitor.visitChildren(self)

    def primary(self):

        localctx = Java20Parser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_primary)
        try:
            self.state = 2077
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 225, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2075
                self.primaryNoNewArray()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2076
                self.arrayCreationExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryNoNewArrayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(Java20Parser.LiteralContext, 0)

        def pNNA(self):
            return self.getTypedRuleContext(Java20Parser.PNNAContext, 0)

        def classLiteral(self):
            return self.getTypedRuleContext(Java20Parser.ClassLiteralContext, 0)

        def THIS(self):
            return self.getToken(Java20Parser.THIS, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def unqualifiedClassInstanceCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnqualifiedClassInstanceCreationExpressionContext, 0)

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def arrayCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionContext, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def LBRACK(self):
            return self.getToken(Java20Parser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(Java20Parser.RBRACK, 0)

        def arrayCreationExpressionWithInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionWithInitializerContext, 0)

        def methodName(self):
            return self.getTypedRuleContext(Java20Parser.MethodNameContext, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def COLONCOLON(self):
            return self.getToken(Java20Parser.COLONCOLON, 0)

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def NEW(self):
            return self.getToken(Java20Parser.NEW, 0)

        def arrayType(self):
            return self.getTypedRuleContext(Java20Parser.ArrayTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_primaryNoNewArray

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimaryNoNewArray"):
                listener.enterPrimaryNoNewArray(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimaryNoNewArray"):
                listener.exitPrimaryNoNewArray(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimaryNoNewArray"):
                return visitor.visitPrimaryNoNewArray(self)
            else:
                return visitor.visitChildren(self)

    def primaryNoNewArray(self):

        localctx = Java20Parser.PrimaryNoNewArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_primaryNoNewArray)
        self._la = 0  # Token type
        try:
            self.state = 2296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 269, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2079
                self.literal()
                self.state = 2081
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 226, self._ctx)
                if la_ == 1:
                    self.state = 2080
                    self.pNNA()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2083
                self.classLiteral()
                self.state = 2085
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 227, self._ctx)
                if la_ == 1:
                    self.state = 2084
                    self.pNNA()

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2087
                self.match(Java20Parser.THIS)
                self.state = 2089
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 228, self._ctx)
                if la_ == 1:
                    self.state = 2088
                    self.pNNA()

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2091
                self.typeName()
                self.state = 2092
                self.match(Java20Parser.DOT)
                self.state = 2093
                self.match(Java20Parser.THIS)
                self.state = 2095
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 229, self._ctx)
                if la_ == 1:
                    self.state = 2094
                    self.pNNA()

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2097
                self.match(Java20Parser.LPAREN)
                self.state = 2098
                self.expression()
                self.state = 2099
                self.match(Java20Parser.RPAREN)
                self.state = 2101
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 230, self._ctx)
                if la_ == 1:
                    self.state = 2100
                    self.pNNA()

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2103
                self.unqualifiedClassInstanceCreationExpression()
                self.state = 2105
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 231, self._ctx)
                if la_ == 1:
                    self.state = 2104
                    self.pNNA()

                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2107
                self.expressionName()
                self.state = 2108
                self.match(Java20Parser.DOT)
                self.state = 2109
                self.unqualifiedClassInstanceCreationExpression()
                self.state = 2111
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 232, self._ctx)
                if la_ == 1:
                    self.state = 2110
                    self.pNNA()

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2113
                self.arrayCreationExpression()
                self.state = 2114
                self.match(Java20Parser.DOT)
                self.state = 2115
                self.unqualifiedClassInstanceCreationExpression()
                self.state = 2117
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 233, self._ctx)
                if la_ == 1:
                    self.state = 2116
                    self.pNNA()

                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2119
                self.arrayCreationExpression()
                self.state = 2120
                self.match(Java20Parser.DOT)
                self.state = 2121
                self.match(Java20Parser.Identifier)
                self.state = 2123
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 234, self._ctx)
                if la_ == 1:
                    self.state = 2122
                    self.pNNA()

                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2125
                self.match(Java20Parser.SUPER)
                self.state = 2126
                self.match(Java20Parser.DOT)
                self.state = 2127
                self.match(Java20Parser.Identifier)
                self.state = 2129
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 235, self._ctx)
                if la_ == 1:
                    self.state = 2128
                    self.pNNA()

                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2131
                self.typeName()
                self.state = 2132
                self.match(Java20Parser.DOT)
                self.state = 2133
                self.match(Java20Parser.SUPER)
                self.state = 2134
                self.match(Java20Parser.DOT)
                self.state = 2135
                self.match(Java20Parser.Identifier)
                self.state = 2137
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 236, self._ctx)
                if la_ == 1:
                    self.state = 2136
                    self.pNNA()

                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2139
                self.expressionName()
                self.state = 2140
                self.match(Java20Parser.LBRACK)
                self.state = 2141
                self.expression()
                self.state = 2142
                self.match(Java20Parser.RBRACK)
                self.state = 2144
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 237, self._ctx)
                if la_ == 1:
                    self.state = 2143
                    self.pNNA()

                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2146
                self.arrayCreationExpressionWithInitializer()
                self.state = 2147
                self.match(Java20Parser.LBRACK)
                self.state = 2148
                self.expression()
                self.state = 2149
                self.match(Java20Parser.RBRACK)
                self.state = 2151
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 238, self._ctx)
                if la_ == 1:
                    self.state = 2150
                    self.pNNA()

                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2153
                self.methodName()
                self.state = 2154
                self.match(Java20Parser.LPAREN)
                self.state = 2156
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2155
                    self.argumentList()

                self.state = 2158
                self.match(Java20Parser.RPAREN)
                self.state = 2160
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 240, self._ctx)
                if la_ == 1:
                    self.state = 2159
                    self.pNNA()

                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 2162
                self.typeName()
                self.state = 2163
                self.match(Java20Parser.DOT)
                self.state = 2165
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2164
                    self.typeArguments()

                self.state = 2167
                self.match(Java20Parser.Identifier)
                self.state = 2168
                self.match(Java20Parser.LPAREN)
                self.state = 2170
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2169
                    self.argumentList()

                self.state = 2172
                self.match(Java20Parser.RPAREN)
                self.state = 2174
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 243, self._ctx)
                if la_ == 1:
                    self.state = 2173
                    self.pNNA()

                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 2176
                self.expressionName()
                self.state = 2177
                self.match(Java20Parser.DOT)
                self.state = 2179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2178
                    self.typeArguments()

                self.state = 2181
                self.match(Java20Parser.Identifier)
                self.state = 2182
                self.match(Java20Parser.LPAREN)
                self.state = 2184
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2183
                    self.argumentList()

                self.state = 2186
                self.match(Java20Parser.RPAREN)
                self.state = 2188
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 246, self._ctx)
                if la_ == 1:
                    self.state = 2187
                    self.pNNA()

                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 2190
                self.arrayCreationExpression()
                self.state = 2191
                self.match(Java20Parser.DOT)
                self.state = 2193
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2192
                    self.typeArguments()

                self.state = 2195
                self.match(Java20Parser.Identifier)
                self.state = 2196
                self.match(Java20Parser.LPAREN)
                self.state = 2198
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2197
                    self.argumentList()

                self.state = 2200
                self.match(Java20Parser.RPAREN)
                self.state = 2202
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 249, self._ctx)
                if la_ == 1:
                    self.state = 2201
                    self.pNNA()

                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 2204
                self.match(Java20Parser.SUPER)
                self.state = 2205
                self.match(Java20Parser.DOT)
                self.state = 2207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2206
                    self.typeArguments()

                self.state = 2209
                self.match(Java20Parser.Identifier)
                self.state = 2210
                self.match(Java20Parser.LPAREN)
                self.state = 2212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2211
                    self.argumentList()

                self.state = 2214
                self.match(Java20Parser.RPAREN)
                self.state = 2216
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 252, self._ctx)
                if la_ == 1:
                    self.state = 2215
                    self.pNNA()

                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 2218
                self.typeName()
                self.state = 2219
                self.match(Java20Parser.DOT)
                self.state = 2220
                self.match(Java20Parser.SUPER)
                self.state = 2221
                self.match(Java20Parser.DOT)
                self.state = 2223
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2222
                    self.typeArguments()

                self.state = 2225
                self.match(Java20Parser.Identifier)
                self.state = 2226
                self.match(Java20Parser.LPAREN)
                self.state = 2228
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2227
                    self.argumentList()

                self.state = 2230
                self.match(Java20Parser.RPAREN)
                self.state = 2232
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 255, self._ctx)
                if la_ == 1:
                    self.state = 2231
                    self.pNNA()

                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 2234
                self.expressionName()
                self.state = 2235
                self.match(Java20Parser.COLONCOLON)
                self.state = 2237
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2236
                    self.typeArguments()

                self.state = 2239
                self.match(Java20Parser.Identifier)
                self.state = 2241
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 257, self._ctx)
                if la_ == 1:
                    self.state = 2240
                    self.pNNA()

                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 2243
                self.arrayCreationExpression()
                self.state = 2244
                self.match(Java20Parser.COLONCOLON)
                self.state = 2246
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2245
                    self.typeArguments()

                self.state = 2248
                self.match(Java20Parser.Identifier)
                self.state = 2250
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 259, self._ctx)
                if la_ == 1:
                    self.state = 2249
                    self.pNNA()

                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 2252
                self.referenceType()
                self.state = 2253
                self.match(Java20Parser.COLONCOLON)
                self.state = 2255
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2254
                    self.typeArguments()

                self.state = 2257
                self.match(Java20Parser.Identifier)
                self.state = 2259
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 261, self._ctx)
                if la_ == 1:
                    self.state = 2258
                    self.pNNA()

                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 2261
                self.match(Java20Parser.SUPER)
                self.state = 2262
                self.match(Java20Parser.COLONCOLON)
                self.state = 2264
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2263
                    self.typeArguments()

                self.state = 2266
                self.match(Java20Parser.Identifier)
                self.state = 2268
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 263, self._ctx)
                if la_ == 1:
                    self.state = 2267
                    self.pNNA()

                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 2270
                self.typeName()
                self.state = 2271
                self.match(Java20Parser.DOT)
                self.state = 2272
                self.match(Java20Parser.SUPER)
                self.state = 2273
                self.match(Java20Parser.COLONCOLON)
                self.state = 2275
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2274
                    self.typeArguments()

                self.state = 2277
                self.match(Java20Parser.Identifier)
                self.state = 2279
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 265, self._ctx)
                if la_ == 1:
                    self.state = 2278
                    self.pNNA()

                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 2281
                self.classType()
                self.state = 2282
                self.match(Java20Parser.COLONCOLON)
                self.state = 2284
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2283
                    self.typeArguments()

                self.state = 2286
                self.match(Java20Parser.NEW)
                self.state = 2288
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 267, self._ctx)
                if la_ == 1:
                    self.state = 2287
                    self.pNNA()

                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 2290
                self.arrayType()
                self.state = 2291
                self.match(Java20Parser.COLONCOLON)
                self.state = 2292
                self.match(Java20Parser.NEW)
                self.state = 2294
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 268, self._ctx)
                if la_ == 1:
                    self.state = 2293
                    self.pNNA()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PNNAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def unqualifiedClassInstanceCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnqualifiedClassInstanceCreationExpressionContext, 0)

        def pNNA(self):
            return self.getTypedRuleContext(Java20Parser.PNNAContext, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def LBRACK(self):
            return self.getToken(Java20Parser.LBRACK, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RBRACK(self):
            return self.getToken(Java20Parser.RBRACK, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def COLONCOLON(self):
            return self.getToken(Java20Parser.COLONCOLON, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_pNNA

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPNNA"):
                listener.enterPNNA(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPNNA"):
                listener.exitPNNA(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPNNA"):
                return visitor.visitPNNA(self)
            else:
                return visitor.visitChildren(self)

    def pNNA(self):

        localctx = Java20Parser.PNNAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_pNNA)
        self._la = 0  # Token type
        try:
            self.state = 2335
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 278, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2298
                self.match(Java20Parser.DOT)
                self.state = 2299
                self.unqualifiedClassInstanceCreationExpression()
                self.state = 2301
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 270, self._ctx)
                if la_ == 1:
                    self.state = 2300
                    self.pNNA()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2303
                self.match(Java20Parser.DOT)
                self.state = 2304
                self.match(Java20Parser.Identifier)
                self.state = 2306
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 271, self._ctx)
                if la_ == 1:
                    self.state = 2305
                    self.pNNA()

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2308
                self.match(Java20Parser.LBRACK)
                self.state = 2309
                self.expression()
                self.state = 2310
                self.match(Java20Parser.RBRACK)
                self.state = 2312
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 272, self._ctx)
                if la_ == 1:
                    self.state = 2311
                    self.pNNA()

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2314
                self.match(Java20Parser.DOT)
                self.state = 2316
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2315
                    self.typeArguments()

                self.state = 2318
                self.match(Java20Parser.Identifier)
                self.state = 2319
                self.match(Java20Parser.LPAREN)
                self.state = 2321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2320
                    self.argumentList()

                self.state = 2323
                self.match(Java20Parser.RPAREN)
                self.state = 2325
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 275, self._ctx)
                if la_ == 1:
                    self.state = 2324
                    self.pNNA()

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2327
                self.match(Java20Parser.COLONCOLON)
                self.state = 2329
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2328
                    self.typeArguments()

                self.state = 2331
                self.match(Java20Parser.Identifier)
                self.state = 2333
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 277, self._ctx)
                if la_ == 1:
                    self.state = 2332
                    self.pNNA()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def CLASS(self):
            return self.getToken(Java20Parser.CLASS, 0)

        def LBRACK(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.LBRACK)
            else:
                return self.getToken(Java20Parser.LBRACK, i)

        def RBRACK(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.RBRACK)
            else:
                return self.getToken(Java20Parser.RBRACK, i)

        def numericType(self):
            return self.getTypedRuleContext(Java20Parser.NumericTypeContext, 0)

        def BOOLEAN(self):
            return self.getToken(Java20Parser.BOOLEAN, 0)

        def VOID(self):
            return self.getToken(Java20Parser.VOID, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassLiteral"):
                listener.enterClassLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassLiteral"):
                listener.exitClassLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassLiteral"):
                return visitor.visitClassLiteral(self)
            else:
                return visitor.visitChildren(self)

    def classLiteral(self):

        localctx = Java20Parser.ClassLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_classLiteral)
        self._la = 0  # Token type
        try:
            self.state = 2372
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2337
                self.typeName()
                self.state = 2342
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 80:
                    self.state = 2338
                    self.match(Java20Parser.LBRACK)
                    self.state = 2339
                    self.match(Java20Parser.RBRACK)
                    self.state = 2344
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2345
                self.match(Java20Parser.DOT)
                self.state = 2346
                self.match(Java20Parser.CLASS)
                pass
            elif token in [22, 25, 31, 37, 44, 46, 54]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2348
                self.numericType()
                self.state = 2353
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 80:
                    self.state = 2349
                    self.match(Java20Parser.LBRACK)
                    self.state = 2350
                    self.match(Java20Parser.RBRACK)
                    self.state = 2355
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2356
                self.match(Java20Parser.DOT)
                self.state = 2357
                self.match(Java20Parser.CLASS)
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2359
                self.match(Java20Parser.BOOLEAN)
                self.state = 2364
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 80:
                    self.state = 2360
                    self.match(Java20Parser.LBRACK)
                    self.state = 2361
                    self.match(Java20Parser.RBRACK)
                    self.state = 2366
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2367
                self.match(Java20Parser.DOT)
                self.state = 2368
                self.match(Java20Parser.CLASS)
                pass
            elif token in [65]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2369
                self.match(Java20Parser.VOID)
                self.state = 2370
                self.match(Java20Parser.DOT)
                self.state = 2371
                self.match(Java20Parser.CLASS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassInstanceCreationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unqualifiedClassInstanceCreationExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnqualifiedClassInstanceCreationExpressionContext, 0)

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classInstanceCreationExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassInstanceCreationExpression"):
                listener.enterClassInstanceCreationExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassInstanceCreationExpression"):
                listener.exitClassInstanceCreationExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassInstanceCreationExpression"):
                return visitor.visitClassInstanceCreationExpression(self)
            else:
                return visitor.visitChildren(self)

    def classInstanceCreationExpression(self):

        localctx = Java20Parser.ClassInstanceCreationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_classInstanceCreationExpression)
        try:
            self.state = 2383
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 283, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2374
                self.unqualifiedClassInstanceCreationExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2375
                self.expressionName()
                self.state = 2376
                self.match(Java20Parser.DOT)
                self.state = 2377
                self.unqualifiedClassInstanceCreationExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2379
                self.primary()
                self.state = 2380
                self.match(Java20Parser.DOT)
                self.state = 2381
                self.unqualifiedClassInstanceCreationExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnqualifiedClassInstanceCreationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(Java20Parser.NEW, 0)

        def classOrInterfaceTypeToInstantiate(self):
            return self.getTypedRuleContext(Java20Parser.ClassOrInterfaceTypeToInstantiateContext, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def classBody(self):
            return self.getTypedRuleContext(Java20Parser.ClassBodyContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unqualifiedClassInstanceCreationExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnqualifiedClassInstanceCreationExpression"):
                listener.enterUnqualifiedClassInstanceCreationExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnqualifiedClassInstanceCreationExpression"):
                listener.exitUnqualifiedClassInstanceCreationExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnqualifiedClassInstanceCreationExpression"):
                return visitor.visitUnqualifiedClassInstanceCreationExpression(self)
            else:
                return visitor.visitChildren(self)

    def unqualifiedClassInstanceCreationExpression(self):

        localctx = Java20Parser.UnqualifiedClassInstanceCreationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_unqualifiedClassInstanceCreationExpression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2385
            self.match(Java20Parser.NEW)
            self.state = 2387
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 90:
                self.state = 2386
                self.typeArguments()

            self.state = 2389
            self.classOrInterfaceTypeToInstantiate()
            self.state = 2390
            self.match(Java20Parser.LPAREN)
            self.state = 2392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                    (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                self.state = 2391
                self.argumentList()

            self.state = 2394
            self.match(Java20Parser.RPAREN)
            self.state = 2396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 286, self._ctx)
            if la_ == 1:
                self.state = 2395
                self.classBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClassOrInterfaceTypeToInstantiateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.Identifier)
            else:
                return self.getToken(Java20Parser.Identifier, i)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def typeArgumentsOrDiamond(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsOrDiamondContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_classOrInterfaceTypeToInstantiate

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClassOrInterfaceTypeToInstantiate"):
                listener.enterClassOrInterfaceTypeToInstantiate(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClassOrInterfaceTypeToInstantiate"):
                listener.exitClassOrInterfaceTypeToInstantiate(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassOrInterfaceTypeToInstantiate"):
                return visitor.visitClassOrInterfaceTypeToInstantiate(self)
            else:
                return visitor.visitChildren(self)

    def classOrInterfaceTypeToInstantiate(self):

        localctx = Java20Parser.ClassOrInterfaceTypeToInstantiateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_classOrInterfaceTypeToInstantiate)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 2398
                self.annotation()
                self.state = 2403
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2404
            self.match(Java20Parser.Identifier)
            self.state = 2415
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 84:
                self.state = 2405
                self.match(Java20Parser.DOT)
                self.state = 2409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 86:
                    self.state = 2406
                    self.annotation()
                    self.state = 2411
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2412
                self.match(Java20Parser.Identifier)
                self.state = 2417
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2419
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 4 or _la == 90:
                self.state = 2418
                self.typeArgumentsOrDiamond()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeArgumentsOrDiamondContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def OACA(self):
            return self.getToken(Java20Parser.OACA, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_typeArgumentsOrDiamond

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeArgumentsOrDiamond"):
                listener.enterTypeArgumentsOrDiamond(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeArgumentsOrDiamond"):
                listener.exitTypeArgumentsOrDiamond(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeArgumentsOrDiamond"):
                return visitor.visitTypeArgumentsOrDiamond(self)
            else:
                return visitor.visitChildren(self)

    def typeArgumentsOrDiamond(self):

        localctx = Java20Parser.TypeArgumentsOrDiamondContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_typeArgumentsOrDiamond)
        try:
            self.state = 2423
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [90]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2421
                self.typeArguments()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2422
                self.match(Java20Parser.OACA)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayCreationExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arrayCreationExpressionWithoutInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionWithoutInitializerContext, 0)

        def arrayCreationExpressionWithInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionWithInitializerContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayCreationExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayCreationExpression"):
                listener.enterArrayCreationExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayCreationExpression"):
                listener.exitArrayCreationExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayCreationExpression"):
                return visitor.visitArrayCreationExpression(self)
            else:
                return visitor.visitChildren(self)

    def arrayCreationExpression(self):

        localctx = Java20Parser.ArrayCreationExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_arrayCreationExpression)
        try:
            self.state = 2427
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 292, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2425
                self.arrayCreationExpressionWithoutInitializer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2426
                self.arrayCreationExpressionWithInitializer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayCreationExpressionWithoutInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(Java20Parser.NEW, 0)

        def primitiveType(self):
            return self.getTypedRuleContext(Java20Parser.PrimitiveTypeContext, 0)

        def dimExprs(self):
            return self.getTypedRuleContext(Java20Parser.DimExprsContext, 0)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayCreationExpressionWithoutInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayCreationExpressionWithoutInitializer"):
                listener.enterArrayCreationExpressionWithoutInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayCreationExpressionWithoutInitializer"):
                listener.exitArrayCreationExpressionWithoutInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayCreationExpressionWithoutInitializer"):
                return visitor.visitArrayCreationExpressionWithoutInitializer(self)
            else:
                return visitor.visitChildren(self)

    def arrayCreationExpressionWithoutInitializer(self):

        localctx = Java20Parser.ArrayCreationExpressionWithoutInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_arrayCreationExpressionWithoutInitializer)
        try:
            self.state = 2441
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 295, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2429
                self.match(Java20Parser.NEW)
                self.state = 2430
                self.primitiveType()
                self.state = 2431
                self.dimExprs()
                self.state = 2433
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 293, self._ctx)
                if la_ == 1:
                    self.state = 2432
                    self.dims()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2435
                self.match(Java20Parser.NEW)
                self.state = 2436
                self.classType()
                self.state = 2437
                self.dimExprs()
                self.state = 2439
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 294, self._ctx)
                if la_ == 1:
                    self.state = 2438
                    self.dims()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayCreationExpressionWithInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(Java20Parser.NEW, 0)

        def primitiveType(self):
            return self.getTypedRuleContext(Java20Parser.PrimitiveTypeContext, 0)

        def dims(self):
            return self.getTypedRuleContext(Java20Parser.DimsContext, 0)

        def arrayInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayInitializerContext, 0)

        def classOrInterfaceType(self):
            return self.getTypedRuleContext(Java20Parser.ClassOrInterfaceTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayCreationExpressionWithInitializer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayCreationExpressionWithInitializer"):
                listener.enterArrayCreationExpressionWithInitializer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayCreationExpressionWithInitializer"):
                listener.exitArrayCreationExpressionWithInitializer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayCreationExpressionWithInitializer"):
                return visitor.visitArrayCreationExpressionWithInitializer(self)
            else:
                return visitor.visitChildren(self)

    def arrayCreationExpressionWithInitializer(self):

        localctx = Java20Parser.ArrayCreationExpressionWithInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_arrayCreationExpressionWithInitializer)
        try:
            self.state = 2453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 296, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2443
                self.match(Java20Parser.NEW)
                self.state = 2444
                self.primitiveType()
                self.state = 2445
                self.dims()
                self.state = 2446
                self.arrayInitializer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2448
                self.match(Java20Parser.NEW)
                self.state = 2449
                self.classOrInterfaceType()
                self.state = 2450
                self.dims()
                self.state = 2451
                self.arrayInitializer()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimExprsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dimExpr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.DimExprContext)
            else:
                return self.getTypedRuleContext(Java20Parser.DimExprContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_dimExprs

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDimExprs"):
                listener.enterDimExprs(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDimExprs"):
                listener.exitDimExprs(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDimExprs"):
                return visitor.visitDimExprs(self)
            else:
                return visitor.visitChildren(self)

    def dimExprs(self):

        localctx = Java20Parser.DimExprsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_dimExprs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2455
            self.dimExpr()
            self.state = 2459
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 297, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2456
                    self.dimExpr()
                self.state = 2461
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 297, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DimExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(Java20Parser.LBRACK, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RBRACK(self):
            return self.getToken(Java20Parser.RBRACK, 0)

        def annotation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AnnotationContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AnnotationContext, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_dimExpr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDimExpr"):
                listener.enterDimExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDimExpr"):
                listener.exitDimExpr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDimExpr"):
                return visitor.visitDimExpr(self)
            else:
                return visitor.visitChildren(self)

    def dimExpr(self):

        localctx = Java20Parser.DimExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_dimExpr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2465
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 86:
                self.state = 2462
                self.annotation()
                self.state = 2467
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2468
            self.match(Java20Parser.LBRACK)
            self.state = 2469
            self.expression()
            self.state = 2470
            self.match(Java20Parser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def LBRACK(self):
            return self.getToken(Java20Parser.LBRACK, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RBRACK(self):
            return self.getToken(Java20Parser.RBRACK, 0)

        def primaryNoNewArray(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryNoNewArrayContext, 0)

        def arrayCreationExpressionWithInitializer(self):
            return self.getTypedRuleContext(Java20Parser.ArrayCreationExpressionWithInitializerContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_arrayAccess

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArrayAccess"):
                listener.enterArrayAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArrayAccess"):
                listener.exitArrayAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArrayAccess"):
                return visitor.visitArrayAccess(self)
            else:
                return visitor.visitChildren(self)

    def arrayAccess(self):

        localctx = Java20Parser.ArrayAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_arrayAccess)
        try:
            self.state = 2487
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 299, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2472
                self.expressionName()
                self.state = 2473
                self.match(Java20Parser.LBRACK)
                self.state = 2474
                self.expression()
                self.state = 2475
                self.match(Java20Parser.RBRACK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2477
                self.primaryNoNewArray()
                self.state = 2478
                self.match(Java20Parser.LBRACK)
                self.state = 2479
                self.expression()
                self.state = 2480
                self.match(Java20Parser.RBRACK)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2482
                self.arrayCreationExpressionWithInitializer()
                self.state = 2483
                self.match(Java20Parser.LBRACK)
                self.state = 2484
                self.expression()
                self.state = 2485
                self.match(Java20Parser.RBRACK)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FieldAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_fieldAccess

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFieldAccess"):
                listener.enterFieldAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFieldAccess"):
                listener.exitFieldAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFieldAccess"):
                return visitor.visitFieldAccess(self)
            else:
                return visitor.visitChildren(self)

    def fieldAccess(self):

        localctx = Java20Parser.FieldAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_fieldAccess)
        try:
            self.state = 2502
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 300, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2489
                self.primary()
                self.state = 2490
                self.match(Java20Parser.DOT)
                self.state = 2491
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2493
                self.match(Java20Parser.SUPER)
                self.state = 2494
                self.match(Java20Parser.DOT)
                self.state = 2495
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2496
                self.typeName()
                self.state = 2497
                self.match(Java20Parser.DOT)
                self.state = 2498
                self.match(Java20Parser.SUPER)
                self.state = 2499
                self.match(Java20Parser.DOT)
                self.state = 2500
                self.match(Java20Parser.Identifier)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodName(self):
            return self.getTypedRuleContext(Java20Parser.MethodNameContext, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def argumentList(self):
            return self.getTypedRuleContext(Java20Parser.ArgumentListContext, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.DOT)
            else:
                return self.getToken(Java20Parser.DOT, i)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodInvocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodInvocation"):
                listener.enterMethodInvocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodInvocation"):
                listener.exitMethodInvocation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodInvocation"):
                return visitor.visitMethodInvocation(self)
            else:
                return visitor.visitChildren(self)

    def methodInvocation(self):

        localctx = Java20Parser.MethodInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_methodInvocation)
        self._la = 0  # Token type
        try:
            self.state = 2572
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 312, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2504
                self.methodName()
                self.state = 2505
                self.match(Java20Parser.LPAREN)
                self.state = 2507
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2506
                    self.argumentList()

                self.state = 2509
                self.match(Java20Parser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2511
                self.typeName()
                self.state = 2512
                self.match(Java20Parser.DOT)
                self.state = 2514
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2513
                    self.typeArguments()

                self.state = 2516
                self.match(Java20Parser.Identifier)
                self.state = 2517
                self.match(Java20Parser.LPAREN)
                self.state = 2519
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2518
                    self.argumentList()

                self.state = 2521
                self.match(Java20Parser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2523
                self.expressionName()
                self.state = 2524
                self.match(Java20Parser.DOT)
                self.state = 2526
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2525
                    self.typeArguments()

                self.state = 2528
                self.match(Java20Parser.Identifier)
                self.state = 2529
                self.match(Java20Parser.LPAREN)
                self.state = 2531
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2530
                    self.argumentList()

                self.state = 2533
                self.match(Java20Parser.RPAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2535
                self.primary()
                self.state = 2536
                self.match(Java20Parser.DOT)
                self.state = 2538
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2537
                    self.typeArguments()

                self.state = 2540
                self.match(Java20Parser.Identifier)
                self.state = 2541
                self.match(Java20Parser.LPAREN)
                self.state = 2543
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2542
                    self.argumentList()

                self.state = 2545
                self.match(Java20Parser.RPAREN)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2547
                self.match(Java20Parser.SUPER)
                self.state = 2548
                self.match(Java20Parser.DOT)
                self.state = 2550
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2549
                    self.typeArguments()

                self.state = 2552
                self.match(Java20Parser.Identifier)
                self.state = 2553
                self.match(Java20Parser.LPAREN)
                self.state = 2555
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2554
                    self.argumentList()

                self.state = 2557
                self.match(Java20Parser.RPAREN)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2558
                self.typeName()
                self.state = 2559
                self.match(Java20Parser.DOT)
                self.state = 2560
                self.match(Java20Parser.SUPER)
                self.state = 2561
                self.match(Java20Parser.DOT)
                self.state = 2563
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2562
                    self.typeArguments()

                self.state = 2565
                self.match(Java20Parser.Identifier)
                self.state = 2566
                self.match(Java20Parser.LPAREN)
                self.state = 2568
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1603651042876063744) != 0) or (
                        (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 288232437939441649) != 0):
                    self.state = 2567
                    self.argumentList()

                self.state = 2570
                self.match(Java20Parser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.ExpressionContext)
            else:
                return self.getTypedRuleContext(Java20Parser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_argumentList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArgumentList"):
                listener.enterArgumentList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArgumentList"):
                listener.exitArgumentList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArgumentList"):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)

    def argumentList(self):

        localctx = Java20Parser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_argumentList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2574
            self.expression()
            self.state = 2579
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 83:
                self.state = 2575
                self.match(Java20Parser.COMMA)
                self.state = 2576
                self.expression()
                self.state = 2581
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MethodReferenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def COLONCOLON(self):
            return self.getToken(Java20Parser.COLONCOLON, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def typeArguments(self):
            return self.getTypedRuleContext(Java20Parser.TypeArgumentsContext, 0)

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def SUPER(self):
            return self.getToken(Java20Parser.SUPER, 0)

        def typeName(self):
            return self.getTypedRuleContext(Java20Parser.TypeNameContext, 0)

        def DOT(self):
            return self.getToken(Java20Parser.DOT, 0)

        def classType(self):
            return self.getTypedRuleContext(Java20Parser.ClassTypeContext, 0)

        def NEW(self):
            return self.getToken(Java20Parser.NEW, 0)

        def arrayType(self):
            return self.getTypedRuleContext(Java20Parser.ArrayTypeContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_methodReference

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMethodReference"):
                listener.enterMethodReference(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMethodReference"):
                listener.exitMethodReference(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMethodReference"):
                return visitor.visitMethodReference(self)
            else:
                return visitor.visitChildren(self)

    def methodReference(self):

        localctx = Java20Parser.MethodReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_methodReference)
        self._la = 0  # Token type
        try:
            self.state = 2629
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 320, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2582
                self.expressionName()
                self.state = 2583
                self.match(Java20Parser.COLONCOLON)
                self.state = 2585
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2584
                    self.typeArguments()

                self.state = 2587
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2589
                self.primary()
                self.state = 2590
                self.match(Java20Parser.COLONCOLON)
                self.state = 2592
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2591
                    self.typeArguments()

                self.state = 2594
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2596
                self.referenceType()
                self.state = 2597
                self.match(Java20Parser.COLONCOLON)
                self.state = 2599
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2598
                    self.typeArguments()

                self.state = 2601
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2603
                self.match(Java20Parser.SUPER)
                self.state = 2604
                self.match(Java20Parser.COLONCOLON)
                self.state = 2606
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2605
                    self.typeArguments()

                self.state = 2608
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2609
                self.typeName()
                self.state = 2610
                self.match(Java20Parser.DOT)
                self.state = 2611
                self.match(Java20Parser.SUPER)
                self.state = 2612
                self.match(Java20Parser.COLONCOLON)
                self.state = 2614
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2613
                    self.typeArguments()

                self.state = 2616
                self.match(Java20Parser.Identifier)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2618
                self.classType()
                self.state = 2619
                self.match(Java20Parser.COLONCOLON)
                self.state = 2621
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 90:
                    self.state = 2620
                    self.typeArguments()

                self.state = 2623
                self.match(Java20Parser.NEW)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2625
                self.arrayType()
                self.state = 2626
                self.match(Java20Parser.COLONCOLON)
                self.state = 2627
                self.match(Java20Parser.NEW)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PostfixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primary(self):
            return self.getTypedRuleContext(Java20Parser.PrimaryContext, 0)

        def pfE(self):
            return self.getTypedRuleContext(Java20Parser.PfEContext, 0)

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_postfixExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPostfixExpression"):
                listener.enterPostfixExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPostfixExpression"):
                listener.exitPostfixExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPostfixExpression"):
                return visitor.visitPostfixExpression(self)
            else:
                return visitor.visitChildren(self)

    def postfixExpression(self):

        localctx = Java20Parser.PostfixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_postfixExpression)
        try:
            self.state = 2639
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 323, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2631
                self.primary()
                self.state = 2633
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 321, self._ctx)
                if la_ == 1:
                    self.state = 2632
                    self.pfE()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2635
                self.expressionName()
                self.state = 2637
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 322, self._ctx)
                if la_ == 1:
                    self.state = 2636
                    self.pfE()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PfEContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INC(self):
            return self.getToken(Java20Parser.INC, 0)

        def pfE(self):
            return self.getTypedRuleContext(Java20Parser.PfEContext, 0)

        def DEC(self):
            return self.getToken(Java20Parser.DEC, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_pfE

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPfE"):
                listener.enterPfE(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPfE"):
                listener.exitPfE(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPfE"):
                return visitor.visitPfE(self)
            else:
                return visitor.visitChildren(self)

    def pfE(self):

        localctx = Java20Parser.PfEContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_pfE)
        try:
            self.state = 2649
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [102]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2641
                self.match(Java20Parser.INC)
                self.state = 2643
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 324, self._ctx)
                if la_ == 1:
                    self.state = 2642
                    self.pfE()

                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2645
                self.match(Java20Parser.DEC)
                self.state = 2647
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 325, self._ctx)
                if la_ == 1:
                    self.state = 2646
                    self.pfE()

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PostIncrementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def postfixExpression(self):
            return self.getTypedRuleContext(Java20Parser.PostfixExpressionContext, 0)

        def INC(self):
            return self.getToken(Java20Parser.INC, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_postIncrementExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPostIncrementExpression"):
                listener.enterPostIncrementExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPostIncrementExpression"):
                listener.exitPostIncrementExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPostIncrementExpression"):
                return visitor.visitPostIncrementExpression(self)
            else:
                return visitor.visitChildren(self)

    def postIncrementExpression(self):

        localctx = Java20Parser.PostIncrementExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_postIncrementExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2651
            self.postfixExpression()
            self.state = 2652
            self.match(Java20Parser.INC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PostDecrementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def postfixExpression(self):
            return self.getTypedRuleContext(Java20Parser.PostfixExpressionContext, 0)

        def DEC(self):
            return self.getToken(Java20Parser.DEC, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_postDecrementExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPostDecrementExpression"):
                listener.enterPostDecrementExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPostDecrementExpression"):
                listener.exitPostDecrementExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPostDecrementExpression"):
                return visitor.visitPostDecrementExpression(self)
            else:
                return visitor.visitChildren(self)

    def postDecrementExpression(self):

        localctx = Java20Parser.PostDecrementExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_postDecrementExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2654
            self.postfixExpression()
            self.state = 2655
            self.match(Java20Parser.DEC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def preIncrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PreIncrementExpressionContext, 0)

        def preDecrementExpression(self):
            return self.getTypedRuleContext(Java20Parser.PreDecrementExpressionContext, 0)

        def ADD(self):
            return self.getToken(Java20Parser.ADD, 0)

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def SUB(self):
            return self.getToken(Java20Parser.SUB, 0)

        def unaryExpressionNotPlusMinus(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionNotPlusMinusContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unaryExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnaryExpression"):
                listener.enterUnaryExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnaryExpression"):
                listener.exitUnaryExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnaryExpression"):
                return visitor.visitUnaryExpression(self)
            else:
                return visitor.visitChildren(self)

    def unaryExpression(self):

        localctx = Java20Parser.UnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_unaryExpression)
        try:
            self.state = 2664
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [102]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2657
                self.preIncrementExpression()
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2658
                self.preDecrementExpression()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2659
                self.match(Java20Parser.ADD)
                self.state = 2660
                self.unaryExpression()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2661
                self.match(Java20Parser.SUB)
                self.state = 2662
                self.unaryExpression()
                pass
            elif token in [20, 22, 25, 31, 37, 44, 46, 48, 54, 57, 58, 60, 65, 69, 70, 71, 72, 73, 74, 75, 76, 86, 91,
                           92, 123]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2663
                self.unaryExpressionNotPlusMinus()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreIncrementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INC(self):
            return self.getToken(Java20Parser.INC, 0)

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_preIncrementExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPreIncrementExpression"):
                listener.enterPreIncrementExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPreIncrementExpression"):
                listener.exitPreIncrementExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPreIncrementExpression"):
                return visitor.visitPreIncrementExpression(self)
            else:
                return visitor.visitChildren(self)

    def preIncrementExpression(self):

        localctx = Java20Parser.PreIncrementExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_preIncrementExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2666
            self.match(Java20Parser.INC)
            self.state = 2667
            self.unaryExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreDecrementExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEC(self):
            return self.getToken(Java20Parser.DEC, 0)

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_preDecrementExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPreDecrementExpression"):
                listener.enterPreDecrementExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPreDecrementExpression"):
                listener.exitPreDecrementExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPreDecrementExpression"):
                return visitor.visitPreDecrementExpression(self)
            else:
                return visitor.visitChildren(self)

    def preDecrementExpression(self):

        localctx = Java20Parser.PreDecrementExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_preDecrementExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2669
            self.match(Java20Parser.DEC)
            self.state = 2670
            self.unaryExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryExpressionNotPlusMinusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def postfixExpression(self):
            return self.getTypedRuleContext(Java20Parser.PostfixExpressionContext, 0)

        def TILDE(self):
            return self.getToken(Java20Parser.TILDE, 0)

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def BANG(self):
            return self.getToken(Java20Parser.BANG, 0)

        def castExpression(self):
            return self.getTypedRuleContext(Java20Parser.CastExpressionContext, 0)

        def switchExpression(self):
            return self.getTypedRuleContext(Java20Parser.SwitchExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_unaryExpressionNotPlusMinus

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnaryExpressionNotPlusMinus"):
                listener.enterUnaryExpressionNotPlusMinus(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnaryExpressionNotPlusMinus"):
                listener.exitUnaryExpressionNotPlusMinus(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnaryExpressionNotPlusMinus"):
                return visitor.visitUnaryExpressionNotPlusMinus(self)
            else:
                return visitor.visitChildren(self)

    def unaryExpressionNotPlusMinus(self):

        localctx = Java20Parser.UnaryExpressionNotPlusMinusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_unaryExpressionNotPlusMinus)
        try:
            self.state = 2679
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 328, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2672
                self.postfixExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2673
                self.match(Java20Parser.TILDE)
                self.state = 2674
                self.unaryExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2675
                self.match(Java20Parser.BANG)
                self.state = 2676
                self.unaryExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2677
                self.castExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2678
                self.switchExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CastExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def primitiveType(self):
            return self.getTypedRuleContext(Java20Parser.PrimitiveTypeContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def unaryExpressionNotPlusMinus(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionNotPlusMinusContext, 0)

        def additionalBound(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.AdditionalBoundContext)
            else:
                return self.getTypedRuleContext(Java20Parser.AdditionalBoundContext, i)

        def lambdaExpression(self):
            return self.getTypedRuleContext(Java20Parser.LambdaExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_castExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCastExpression"):
                listener.enterCastExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCastExpression"):
                listener.exitCastExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCastExpression"):
                return visitor.visitCastExpression(self)
            else:
                return visitor.visitChildren(self)

    def castExpression(self):

        localctx = Java20Parser.CastExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_castExpression)
        self._la = 0  # Token type
        try:
            self.state = 2708
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 331, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2681
                self.match(Java20Parser.LPAREN)
                self.state = 2682
                self.primitiveType()
                self.state = 2683
                self.match(Java20Parser.RPAREN)
                self.state = 2684
                self.unaryExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2686
                self.match(Java20Parser.LPAREN)
                self.state = 2687
                self.referenceType()
                self.state = 2691
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 108:
                    self.state = 2688
                    self.additionalBound()
                    self.state = 2693
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2694
                self.match(Java20Parser.RPAREN)
                self.state = 2695
                self.unaryExpressionNotPlusMinus()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2697
                self.match(Java20Parser.LPAREN)
                self.state = 2698
                self.referenceType()
                self.state = 2702
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 108:
                    self.state = 2699
                    self.additionalBound()
                    self.state = 2704
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2705
                self.match(Java20Parser.RPAREN)
                self.state = 2706
                self.lambdaExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplicativeExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryExpression(self):
            return self.getTypedRuleContext(Java20Parser.UnaryExpressionContext, 0)

        def multiplicativeExpression(self):
            return self.getTypedRuleContext(Java20Parser.MultiplicativeExpressionContext, 0)

        def MUL(self):
            return self.getToken(Java20Parser.MUL, 0)

        def DIV(self):
            return self.getToken(Java20Parser.DIV, 0)

        def MOD(self):
            return self.getToken(Java20Parser.MOD, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_multiplicativeExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplicativeExpression"):
                listener.enterMultiplicativeExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplicativeExpression"):
                listener.exitMultiplicativeExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplicativeExpression"):
                return visitor.visitMultiplicativeExpression(self)
            else:
                return visitor.visitChildren(self)

    def multiplicativeExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.MultiplicativeExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 444
        self.enterRecursionRule(localctx, 444, self.RULE_multiplicativeExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2711
            self.unaryExpression()
            self._ctx.stop = self._input.LT(-1)
            self.state = 2724
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 333, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2722
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 332, self._ctx)
                    if la_ == 1:
                        localctx = Java20Parser.MultiplicativeExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_multiplicativeExpression)
                        self.state = 2713
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2714
                        self.match(Java20Parser.MUL)
                        self.state = 2715
                        self.unaryExpression()
                        pass

                    elif la_ == 2:
                        localctx = Java20Parser.MultiplicativeExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_multiplicativeExpression)
                        self.state = 2716
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2717
                        self.match(Java20Parser.DIV)
                        self.state = 2718
                        self.unaryExpression()
                        pass

                    elif la_ == 3:
                        localctx = Java20Parser.MultiplicativeExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_multiplicativeExpression)
                        self.state = 2719
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2720
                        self.match(Java20Parser.MOD)
                        self.state = 2721
                        self.unaryExpression()
                        pass

                self.state = 2726
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 333, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class AdditiveExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplicativeExpression(self):
            return self.getTypedRuleContext(Java20Parser.MultiplicativeExpressionContext, 0)

        def additiveExpression(self):
            return self.getTypedRuleContext(Java20Parser.AdditiveExpressionContext, 0)

        def ADD(self):
            return self.getToken(Java20Parser.ADD, 0)

        def SUB(self):
            return self.getToken(Java20Parser.SUB, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_additiveExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditiveExpression"):
                listener.enterAdditiveExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditiveExpression"):
                listener.exitAdditiveExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditiveExpression"):
                return visitor.visitAdditiveExpression(self)
            else:
                return visitor.visitChildren(self)

    def additiveExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.AdditiveExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 446
        self.enterRecursionRule(localctx, 446, self.RULE_additiveExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2728
            self.multiplicativeExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2738
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 335, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2736
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 334, self._ctx)
                    if la_ == 1:
                        localctx = Java20Parser.AdditiveExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_additiveExpression)
                        self.state = 2730
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2731
                        self.match(Java20Parser.ADD)
                        self.state = 2732
                        self.multiplicativeExpression(0)
                        pass

                    elif la_ == 2:
                        localctx = Java20Parser.AdditiveExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_additiveExpression)
                        self.state = 2733
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2734
                        self.match(Java20Parser.SUB)
                        self.state = 2735
                        self.multiplicativeExpression(0)
                        pass

                self.state = 2740
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 335, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ShiftExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additiveExpression(self):
            return self.getTypedRuleContext(Java20Parser.AdditiveExpressionContext, 0)

        def shiftExpression(self):
            return self.getTypedRuleContext(Java20Parser.ShiftExpressionContext, 0)

        def LT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.LT)
            else:
                return self.getToken(Java20Parser.LT, i)

        def GT(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.GT)
            else:
                return self.getToken(Java20Parser.GT, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_shiftExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterShiftExpression"):
                listener.enterShiftExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitShiftExpression"):
                listener.exitShiftExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShiftExpression"):
                return visitor.visitShiftExpression(self)
            else:
                return visitor.visitChildren(self)

    def shiftExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.ShiftExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 448
        self.enterRecursionRule(localctx, 448, self.RULE_shiftExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2742
            self.additiveExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2759
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 337, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2757
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 336, self._ctx)
                    if la_ == 1:
                        localctx = Java20Parser.ShiftExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_shiftExpression)
                        self.state = 2744
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2745
                        self.match(Java20Parser.LT)
                        self.state = 2746
                        self.match(Java20Parser.LT)
                        self.state = 2747
                        self.additiveExpression(0)
                        pass

                    elif la_ == 2:
                        localctx = Java20Parser.ShiftExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_shiftExpression)
                        self.state = 2748
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2749
                        self.match(Java20Parser.GT)
                        self.state = 2750
                        self.match(Java20Parser.GT)
                        self.state = 2751
                        self.additiveExpression(0)
                        pass

                    elif la_ == 3:
                        localctx = Java20Parser.ShiftExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_shiftExpression)
                        self.state = 2752
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2753
                        self.match(Java20Parser.GT)
                        self.state = 2754
                        self.match(Java20Parser.GT)
                        self.state = 2755
                        self.match(Java20Parser.GT)
                        self.state = 2756
                        self.additiveExpression(0)
                        pass

                self.state = 2761
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 337, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class RelationalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shiftExpression(self):
            return self.getTypedRuleContext(Java20Parser.ShiftExpressionContext, 0)

        def relationalExpression(self):
            return self.getTypedRuleContext(Java20Parser.RelationalExpressionContext, 0)

        def LT(self):
            return self.getToken(Java20Parser.LT, 0)

        def GT(self):
            return self.getToken(Java20Parser.GT, 0)

        def LE(self):
            return self.getToken(Java20Parser.LE, 0)

        def GE(self):
            return self.getToken(Java20Parser.GE, 0)

        def INSTANCEOF(self):
            return self.getToken(Java20Parser.INSTANCEOF, 0)

        def referenceType(self):
            return self.getTypedRuleContext(Java20Parser.ReferenceTypeContext, 0)

        def pattern(self):
            return self.getTypedRuleContext(Java20Parser.PatternContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_relationalExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRelationalExpression"):
                listener.enterRelationalExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRelationalExpression"):
                listener.exitRelationalExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRelationalExpression"):
                return visitor.visitRelationalExpression(self)
            else:
                return visitor.visitChildren(self)

    def relationalExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.RelationalExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 450
        self.enterRecursionRule(localctx, 450, self.RULE_relationalExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2763
            self.shiftExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2785
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 340, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2783
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 339, self._ctx)
                    if la_ == 1:
                        localctx = Java20Parser.RelationalExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_relationalExpression)
                        self.state = 2765
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 2766
                        self.match(Java20Parser.LT)
                        self.state = 2767
                        self.shiftExpression(0)
                        pass

                    elif la_ == 2:
                        localctx = Java20Parser.RelationalExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_relationalExpression)
                        self.state = 2768
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 2769
                        self.match(Java20Parser.GT)
                        self.state = 2770
                        self.shiftExpression(0)
                        pass

                    elif la_ == 3:
                        localctx = Java20Parser.RelationalExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_relationalExpression)
                        self.state = 2771
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2772
                        self.match(Java20Parser.LE)
                        self.state = 2773
                        self.shiftExpression(0)
                        pass

                    elif la_ == 4:
                        localctx = Java20Parser.RelationalExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_relationalExpression)
                        self.state = 2774
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2775
                        self.match(Java20Parser.GE)
                        self.state = 2776
                        self.shiftExpression(0)
                        pass

                    elif la_ == 5:
                        localctx = Java20Parser.RelationalExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_relationalExpression)
                        self.state = 2777
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2778
                        self.match(Java20Parser.INSTANCEOF)
                        self.state = 2781
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 338, self._ctx)
                        if la_ == 1:
                            self.state = 2779
                            self.referenceType()
                            pass

                        elif la_ == 2:
                            self.state = 2780
                            self.pattern()
                            pass

                        pass

                self.state = 2787
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 340, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class EqualityExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationalExpression(self):
            return self.getTypedRuleContext(Java20Parser.RelationalExpressionContext, 0)

        def equalityExpression(self):
            return self.getTypedRuleContext(Java20Parser.EqualityExpressionContext, 0)

        def EQUAL(self):
            return self.getToken(Java20Parser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(Java20Parser.NOTEQUAL, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_equalityExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEqualityExpression"):
                listener.enterEqualityExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEqualityExpression"):
                listener.exitEqualityExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEqualityExpression"):
                return visitor.visitEqualityExpression(self)
            else:
                return visitor.visitChildren(self)

    def equalityExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.EqualityExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 452
        self.enterRecursionRule(localctx, 452, self.RULE_equalityExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2789
            self.relationalExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2799
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 342, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2797
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 341, self._ctx)
                    if la_ == 1:
                        localctx = Java20Parser.EqualityExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_equalityExpression)
                        self.state = 2791
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2792
                        self.match(Java20Parser.EQUAL)
                        self.state = 2793
                        self.relationalExpression(0)
                        pass

                    elif la_ == 2:
                        localctx = Java20Parser.EqualityExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_equalityExpression)
                        self.state = 2794
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2795
                        self.match(Java20Parser.NOTEQUAL)
                        self.state = 2796
                        self.relationalExpression(0)
                        pass

                self.state = 2801
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 342, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class AndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equalityExpression(self):
            return self.getTypedRuleContext(Java20Parser.EqualityExpressionContext, 0)

        def andExpression(self):
            return self.getTypedRuleContext(Java20Parser.AndExpressionContext, 0)

        def BITAND(self):
            return self.getToken(Java20Parser.BITAND, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_andExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAndExpression"):
                listener.enterAndExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAndExpression"):
                listener.exitAndExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAndExpression"):
                return visitor.visitAndExpression(self)
            else:
                return visitor.visitChildren(self)

    def andExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.AndExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 454
        self.enterRecursionRule(localctx, 454, self.RULE_andExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2803
            self.equalityExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2810
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 343, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = Java20Parser.AndExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_andExpression)
                    self.state = 2805
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 2806
                    self.match(Java20Parser.BITAND)
                    self.state = 2807
                    self.equalityExpression(0)
                self.state = 2812
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 343, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ExclusiveOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def andExpression(self):
            return self.getTypedRuleContext(Java20Parser.AndExpressionContext, 0)

        def exclusiveOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.ExclusiveOrExpressionContext, 0)

        def CARET(self):
            return self.getToken(Java20Parser.CARET, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_exclusiveOrExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExclusiveOrExpression"):
                listener.enterExclusiveOrExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExclusiveOrExpression"):
                listener.exitExclusiveOrExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExclusiveOrExpression"):
                return visitor.visitExclusiveOrExpression(self)
            else:
                return visitor.visitChildren(self)

    def exclusiveOrExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.ExclusiveOrExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 456
        self.enterRecursionRule(localctx, 456, self.RULE_exclusiveOrExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2814
            self.andExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2821
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 344, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = Java20Parser.ExclusiveOrExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_exclusiveOrExpression)
                    self.state = 2816
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 2817
                    self.match(Java20Parser.CARET)
                    self.state = 2818
                    self.andExpression(0)
                self.state = 2823
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 344, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class InclusiveOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exclusiveOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.ExclusiveOrExpressionContext, 0)

        def inclusiveOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.InclusiveOrExpressionContext, 0)

        def BITOR(self):
            return self.getToken(Java20Parser.BITOR, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_inclusiveOrExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInclusiveOrExpression"):
                listener.enterInclusiveOrExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInclusiveOrExpression"):
                listener.exitInclusiveOrExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInclusiveOrExpression"):
                return visitor.visitInclusiveOrExpression(self)
            else:
                return visitor.visitChildren(self)

    def inclusiveOrExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.InclusiveOrExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 458
        self.enterRecursionRule(localctx, 458, self.RULE_inclusiveOrExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2825
            self.exclusiveOrExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2832
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 345, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = Java20Parser.InclusiveOrExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_inclusiveOrExpression)
                    self.state = 2827
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 2828
                    self.match(Java20Parser.BITOR)
                    self.state = 2829
                    self.exclusiveOrExpression(0)
                self.state = 2834
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 345, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ConditionalAndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inclusiveOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.InclusiveOrExpressionContext, 0)

        def conditionalAndExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalAndExpressionContext, 0)

        def AND(self):
            return self.getToken(Java20Parser.AND, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_conditionalAndExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditionalAndExpression"):
                listener.enterConditionalAndExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditionalAndExpression"):
                listener.exitConditionalAndExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditionalAndExpression"):
                return visitor.visitConditionalAndExpression(self)
            else:
                return visitor.visitChildren(self)

    def conditionalAndExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.ConditionalAndExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 460
        self.enterRecursionRule(localctx, 460, self.RULE_conditionalAndExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2836
            self.inclusiveOrExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2843
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 346, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = Java20Parser.ConditionalAndExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_conditionalAndExpression)
                    self.state = 2838
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 2839
                    self.match(Java20Parser.AND)
                    self.state = 2840
                    self.inclusiveOrExpression(0)
                self.state = 2845
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 346, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ConditionalOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalAndExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalAndExpressionContext, 0)

        def conditionalOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalOrExpressionContext, 0)

        def OR(self):
            return self.getToken(Java20Parser.OR, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_conditionalOrExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditionalOrExpression"):
                listener.enterConditionalOrExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditionalOrExpression"):
                listener.exitConditionalOrExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditionalOrExpression"):
                return visitor.visitConditionalOrExpression(self)
            else:
                return visitor.visitChildren(self)

    def conditionalOrExpression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = Java20Parser.ConditionalOrExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 462
        self.enterRecursionRule(localctx, 462, self.RULE_conditionalOrExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2847
            self.conditionalAndExpression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 2854
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 347, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = Java20Parser.ConditionalOrExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_conditionalOrExpression)
                    self.state = 2849
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 2850
                    self.match(Java20Parser.OR)
                    self.state = 2851
                    self.conditionalAndExpression(0)
                self.state = 2856
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 347, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ConditionalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalOrExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalOrExpressionContext, 0)

        def QUESTION(self):
            return self.getToken(Java20Parser.QUESTION, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def COLON(self):
            return self.getToken(Java20Parser.COLON, 0)

        def conditionalExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalExpressionContext, 0)

        def lambdaExpression(self):
            return self.getTypedRuleContext(Java20Parser.LambdaExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_conditionalExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditionalExpression"):
                listener.enterConditionalExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditionalExpression"):
                listener.exitConditionalExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditionalExpression"):
                return visitor.visitConditionalExpression(self)
            else:
                return visitor.visitChildren(self)

    def conditionalExpression(self):

        localctx = Java20Parser.ConditionalExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_conditionalExpression)
        try:
            self.state = 2870
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 348, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2857
                self.conditionalOrExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2858
                self.conditionalOrExpression(0)
                self.state = 2859
                self.match(Java20Parser.QUESTION)
                self.state = 2860
                self.expression()
                self.state = 2861
                self.match(Java20Parser.COLON)
                self.state = 2862
                self.conditionalExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2864
                self.conditionalOrExpression(0)
                self.state = 2865
                self.match(Java20Parser.QUESTION)
                self.state = 2866
                self.expression()
                self.state = 2867
                self.match(Java20Parser.COLON)
                self.state = 2868
                self.lambdaExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalExpression(self):
            return self.getTypedRuleContext(Java20Parser.ConditionalExpressionContext, 0)

        def assignment(self):
            return self.getTypedRuleContext(Java20Parser.AssignmentContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_assignmentExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignmentExpression"):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignmentExpression"):
                listener.exitAssignmentExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignmentExpression"):
                return visitor.visitAssignmentExpression(self)
            else:
                return visitor.visitChildren(self)

    def assignmentExpression(self):

        localctx = Java20Parser.AssignmentExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_assignmentExpression)
        try:
            self.state = 2874
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 349, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2872
                self.conditionalExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2873
                self.assignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def leftHandSide(self):
            return self.getTypedRuleContext(Java20Parser.LeftHandSideContext, 0)

        def assignmentOperator(self):
            return self.getTypedRuleContext(Java20Parser.AssignmentOperatorContext, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    def assignment(self):

        localctx = Java20Parser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2876
            self.leftHandSide()
            self.state = 2877
            self.assignmentOperator()
            self.state = 2878
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LeftHandSideContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionName(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionNameContext, 0)

        def fieldAccess(self):
            return self.getTypedRuleContext(Java20Parser.FieldAccessContext, 0)

        def arrayAccess(self):
            return self.getTypedRuleContext(Java20Parser.ArrayAccessContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_leftHandSide

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLeftHandSide"):
                listener.enterLeftHandSide(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLeftHandSide"):
                listener.exitLeftHandSide(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLeftHandSide"):
                return visitor.visitLeftHandSide(self)
            else:
                return visitor.visitChildren(self)

    def leftHandSide(self):

        localctx = Java20Parser.LeftHandSideContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_leftHandSide)
        try:
            self.state = 2883
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 350, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2880
                self.expressionName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(loc)
                self.state = 2881
                self.fieldAccess()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2882
                self.arrayAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(Java20Parser.ASSIGN, 0)

        def MUL_ASSIGN(self):
            return self.getToken(Java20Parser.MUL_ASSIGN, 0)

        def DIV_ASSIGN(self):
            return self.getToken(Java20Parser.DIV_ASSIGN, 0)

        def MOD_ASSIGN(self):
            return self.getToken(Java20Parser.MOD_ASSIGN, 0)

        def ADD_ASSIGN(self):
            return self.getToken(Java20Parser.ADD_ASSIGN, 0)

        def SUB_ASSIGN(self):
            return self.getToken(Java20Parser.SUB_ASSIGN, 0)

        def LSHIFT_ASSIGN(self):
            return self.getToken(Java20Parser.LSHIFT_ASSIGN, 0)

        def RSHIFT_ASSIGN(self):
            return self.getToken(Java20Parser.RSHIFT_ASSIGN, 0)

        def URSHIFT_ASSIGN(self):
            return self.getToken(Java20Parser.URSHIFT_ASSIGN, 0)

        def AND_ASSIGN(self):
            return self.getToken(Java20Parser.AND_ASSIGN, 0)

        def XOR_ASSIGN(self):
            return self.getToken(Java20Parser.XOR_ASSIGN, 0)

        def OR_ASSIGN(self):
            return self.getToken(Java20Parser.OR_ASSIGN, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_assignmentOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignmentOperator"):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignmentOperator"):
                listener.exitAssignmentOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignmentOperator"):
                return visitor.visitAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)

    def assignmentOperator(self):

        localctx = Java20Parser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_assignmentOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2885
            _la = self._input.LA(1)
            if not (((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & 34342961153) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaParameters(self):
            return self.getTypedRuleContext(Java20Parser.LambdaParametersContext, 0)

        def ARROW(self):
            return self.getToken(Java20Parser.ARROW, 0)

        def lambdaBody(self):
            return self.getTypedRuleContext(Java20Parser.LambdaBodyContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaExpression"):
                listener.enterLambdaExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaExpression"):
                listener.exitLambdaExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaExpression"):
                return visitor.visitLambdaExpression(self)
            else:
                return visitor.visitChildren(self)

    def lambdaExpression(self):

        localctx = Java20Parser.LambdaExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_lambdaExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2887
            self.lambdaParameters()
            self.state = 2888
            self.match(Java20Parser.ARROW)
            self.state = 2889
            self.lambdaBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def lambdaParameterList(self):
            return self.getTypedRuleContext(Java20Parser.LambdaParameterListContext, 0)

        def Identifier(self):
            return self.getToken(Java20Parser.Identifier, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaParameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaParameters"):
                listener.enterLambdaParameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaParameters"):
                listener.exitLambdaParameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaParameters"):
                return visitor.visitLambdaParameters(self)
            else:
                return visitor.visitChildren(self)

    def lambdaParameters(self):

        localctx = Java20Parser.LambdaParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_lambdaParameters)
        self._la = 0  # Token type
        try:
            self.state = 2897
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [76]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2891
                self.match(Java20Parser.LPAREN)
                self.state = 2893
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 18102533424709632) != 0) or _la == 86 or _la == 123:
                    self.state = 2892
                    self.lambdaParameterList()

                self.state = 2895
                self.match(Java20Parser.RPAREN)
                pass
            elif token in [123]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2896
                self.match(Java20Parser.Identifier)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaParameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.LambdaParameterContext)
            else:
                return self.getTypedRuleContext(Java20Parser.LambdaParameterContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.COMMA)
            else:
                return self.getToken(Java20Parser.COMMA, i)

        def Identifier(self, i: int = None):
            if i is None:
                return self.getTokens(Java20Parser.Identifier)
            else:
                return self.getToken(Java20Parser.Identifier, i)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaParameterList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaParameterList"):
                listener.enterLambdaParameterList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaParameterList"):
                listener.exitLambdaParameterList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaParameterList"):
                return visitor.visitLambdaParameterList(self)
            else:
                return visitor.visitChildren(self)

    def lambdaParameterList(self):

        localctx = Java20Parser.LambdaParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_lambdaParameterList)
        self._la = 0  # Token type
        try:
            self.state = 2915
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 355, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2899
                self.lambdaParameter()
                self.state = 2904
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 83:
                    self.state = 2900
                    self.match(Java20Parser.COMMA)
                    self.state = 2901
                    self.lambdaParameter()
                    self.state = 2906
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2907
                self.match(Java20Parser.Identifier)
                self.state = 2912
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 83:
                    self.state = 2908
                    self.match(Java20Parser.COMMA)
                    self.state = 2909
                    self.match(Java20Parser.Identifier)
                    self.state = 2914
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaParameterType(self):
            return self.getTypedRuleContext(Java20Parser.LambdaParameterTypeContext, 0)

        def variableDeclaratorId(self):
            return self.getTypedRuleContext(Java20Parser.VariableDeclaratorIdContext, 0)

        def variableModifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(Java20Parser.VariableModifierContext)
            else:
                return self.getTypedRuleContext(Java20Parser.VariableModifierContext, i)

        def variableArityParameter(self):
            return self.getTypedRuleContext(Java20Parser.VariableArityParameterContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaParameter"):
                listener.enterLambdaParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaParameter"):
                listener.exitLambdaParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaParameter"):
                return visitor.visitLambdaParameter(self)
            else:
                return visitor.visitChildren(self)

    def lambdaParameter(self):

        localctx = Java20Parser.LambdaParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_lambdaParameter)
        self._la = 0  # Token type
        try:
            self.state = 2927
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 357, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2920
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 35 or _la == 86:
                    self.state = 2917
                    self.variableModifier()
                    self.state = 2922
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2923
                self.lambdaParameterType()
                self.state = 2924
                self.variableDeclaratorId()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2926
                self.variableArityParameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaParameterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unannType(self):
            return self.getTypedRuleContext(Java20Parser.UnannTypeContext, 0)

        def VAR(self):
            return self.getToken(Java20Parser.VAR, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaParameterType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaParameterType"):
                listener.enterLambdaParameterType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaParameterType"):
                listener.exitLambdaParameterType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaParameterType"):
                return visitor.visitLambdaParameterType(self)
            else:
                return visitor.visitChildren(self)

    def lambdaParameterType(self):

        localctx = Java20Parser.LambdaParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_lambdaParameterType)
        try:
            self.state = 2931
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 54, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2929
                self.unannType()
                pass
            elif token in [15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2930
                self.match(Java20Parser.VAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdaBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def block(self):
            return self.getTypedRuleContext(Java20Parser.BlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_lambdaBody

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLambdaBody"):
                listener.enterLambdaBody(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLambdaBody"):
                listener.exitLambdaBody(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLambdaBody"):
                return visitor.visitLambdaBody(self)
            else:
                return visitor.visitChildren(self)

    def lambdaBody(self):

        localctx = Java20Parser.LambdaBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_lambdaBody)
        try:
            self.state = 2935
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20, 22, 25, 31, 37, 44, 46, 48, 54, 57, 58, 60, 65, 69, 70, 71, 72, 73, 74, 75, 76, 86, 91, 92,
                         102, 103, 104, 105, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2933
                self.expression()
                pass
            elif token in [78]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2934
                self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SwitchExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(Java20Parser.SWITCH, 0)

        def LPAREN(self):
            return self.getToken(Java20Parser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def RPAREN(self):
            return self.getToken(Java20Parser.RPAREN, 0)

        def switchBlock(self):
            return self.getTypedRuleContext(Java20Parser.SwitchBlockContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_switchExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSwitchExpression"):
                listener.enterSwitchExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSwitchExpression"):
                listener.exitSwitchExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSwitchExpression"):
                return visitor.visitSwitchExpression(self)
            else:
                return visitor.visitChildren(self)

    def switchExpression(self):

        localctx = Java20Parser.SwitchExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_switchExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2937
            self.match(Java20Parser.SWITCH)
            self.state = 2938
            self.match(Java20Parser.LPAREN)
            self.state = 2939
            self.expression()
            self.state = 2940
            self.match(Java20Parser.RPAREN)
            self.state = 2941
            self.switchBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(Java20Parser.ExpressionContext, 0)

        def getRuleIndex(self):
            return Java20Parser.RULE_constantExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstantExpression"):
                listener.enterConstantExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstantExpression"):
                listener.exitConstantExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstantExpression"):
                return visitor.visitConstantExpression(self)
            else:
                return visitor.visitChildren(self)

    def constantExpression(self):

        localctx = Java20Parser.ConstantExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_constantExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2943
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[222] = self.multiplicativeExpression_sempred
        self._predicates[223] = self.additiveExpression_sempred
        self._predicates[224] = self.shiftExpression_sempred
        self._predicates[225] = self.relationalExpression_sempred
        self._predicates[226] = self.equalityExpression_sempred
        self._predicates[227] = self.andExpression_sempred
        self._predicates[228] = self.exclusiveOrExpression_sempred
        self._predicates[229] = self.inclusiveOrExpression_sempred
        self._predicates[230] = self.conditionalAndExpression_sempred
        self._predicates[231] = self.conditionalOrExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def multiplicativeExpression_sempred(self, localctx: MultiplicativeExpressionContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 3)

        if predIndex == 1:
            return self.precpred(self._ctx, 2)

        if predIndex == 2:
            return self.precpred(self._ctx, 1)

    def additiveExpression_sempred(self, localctx: AdditiveExpressionContext, predIndex: int):
        if predIndex == 3:
            return self.precpred(self._ctx, 2)

        if predIndex == 4:
            return self.precpred(self._ctx, 1)

    def shiftExpression_sempred(self, localctx: ShiftExpressionContext, predIndex: int):
        if predIndex == 5:
            return self.precpred(self._ctx, 3)

        if predIndex == 6:
            return self.precpred(self._ctx, 2)

        if predIndex == 7:
            return self.precpred(self._ctx, 1)

    def relationalExpression_sempred(self, localctx: RelationalExpressionContext, predIndex: int):
        if predIndex == 8:
            return self.precpred(self._ctx, 5)

        if predIndex == 9:
            return self.precpred(self._ctx, 4)

        if predIndex == 10:
            return self.precpred(self._ctx, 3)

        if predIndex == 11:
            return self.precpred(self._ctx, 2)

        if predIndex == 12:
            return self.precpred(self._ctx, 1)

    def equalityExpression_sempred(self, localctx: EqualityExpressionContext, predIndex: int):
        if predIndex == 13:
            return self.precpred(self._ctx, 2)

        if predIndex == 14:
            return self.precpred(self._ctx, 1)

    def andExpression_sempred(self, localctx: AndExpressionContext, predIndex: int):
        if predIndex == 15:
            return self.precpred(self._ctx, 1)

    def exclusiveOrExpression_sempred(self, localctx: ExclusiveOrExpressionContext, predIndex: int):
        if predIndex == 16:
            return self.precpred(self._ctx, 1)

    def inclusiveOrExpression_sempred(self, localctx: InclusiveOrExpressionContext, predIndex: int):
        if predIndex == 17:
            return self.precpred(self._ctx, 1)

    def conditionalAndExpression_sempred(self, localctx: ConditionalAndExpressionContext, predIndex: int):
        if predIndex == 18:
            return self.precpred(self._ctx, 1)

    def conditionalOrExpression_sempred(self, localctx: ConditionalOrExpressionContext, predIndex: int):
        if predIndex == 19:
            return self.precpred(self._ctx, 1)





