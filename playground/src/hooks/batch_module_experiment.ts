import type { Feedback } from "@/model/feedback";
import type { Submission } from "@/model/submission";
import type { Experiment } from "@/components/view_mode/evaluation_mode/define_experiment";

import { useEffect, useState } from "react";
import { useSendFeedbacks } from "./athena/send_feedbacks";
import useRequestSubmissionSelection from "./athena/request_submission_selection";
import useRequestFeedbackSuggestions from "./athena/request_feedback_suggestions";
import useSendSubmissions from "./athena/send_submissions";

type BatchModuleExperimentState = {
  // The current step of the experiment
  step:
    | "sendingSubmissions"
    | "sendingTrainingFeedbacks"
    | "generatingFeedbackSuggestions"
    | "finished";
  // Submissions that have been sent to Athena
  didSendSubmissions: boolean;
  // Tutor feedbacks for training submissions that have been sent to Athena
  sentTrainingSubmissions: number[];
  // Feedback suggestions for evaluation submissions that have been generated by Athena
  // SubmissionId -> { suggestions: Feedback[]; meta: any;} where meta is the metadata of the request
  submissionsWithFeedbackSuggestions: Map<number, { suggestions: Feedback[]; meta: any }>;
};

export default function useBatchModuleExperiment(experiment: Experiment) {
  // State of the module experiment
  const [state, setState] = useState<BatchModuleExperimentState>({
    step: "sendingSubmissions",
    didSendSubmissions: false,
    sentTrainingSubmissions: [],
    submissionsWithFeedbackSuggestions: new Map(),
  });

  // Info message to display the progress to the user
  const [info, setInfo] = useState<string>("");

  // Module requests
  const sendSubmissions = useSendSubmissions();
  const sendFeedbacks = useSendFeedbacks();
  const requestSubmissionSelection = useRequestSubmissionSelection();
  const requestFeedbackSuggestions = useRequestFeedbackSuggestions();

  // 1. Send submissions to Athena
  const stepSendSubmissions = () => {
    console.log("Sending submissions to Athena...");
    setInfo("Sending submissions to Athena...");
    sendSubmissions.mutate(
      {
        exercise: experiment.exercise,
        submissions: [
          ...(experiment.trainingSubmissions ?? []),
          ...experiment.evaluationSubmissions,
        ],
      },
      {
        onSuccess: () => {
          console.log("Sending submissions done!");
          setState({
            ...state,
            step: "sendingTrainingFeedbacks", // next step
            didSendSubmissions: true,
          });
        },
        onError: (error) => {
          console.error("Error while sending submissions to Athena:", error);
          setInfo("Error while sending submissions to Athena.");
          // TODO: Recover?
        },
      }
    );
  };

  // 2. Send tutor feedbacks for training submissions to Athena
  const stepSendTrainingFeedbacks = () => {
    // Skip if there are no training submissions
    if (!experiment.trainingSubmissions) {
      console.log("No training submissions, skipping");
      setState({
        ...state,
        step: "generatingFeedbackSuggestions",
      });
      return;
    }

    console.log("Sending training feedbacks to Athena...");
    setInfo("Sending training feedbacks to Athena...");

    // Recursive function to send all training submissions
    const sendNextSubmission = () => {
      const submission = experiment.trainingSubmissions?.find(
        (submission) => !state.sentTrainingSubmissions.includes(submission.id)
      );

      // No more submissions to send -> Go to evaluation
      if (!submission) {
        console.log("Sending training feedbacks done!");
        setState({
          ...state,
          step: "generatingFeedbackSuggestions", // next step
        });
        return;
      }

      const submissionFeedbacks = experiment.tutorFeedbacks.filter(
        (feedback) => feedback.submission_id === submission?.id
      );

      // Skip submission if there are no feedbacks
      if (submissionFeedbacks.length === 0) {
        setState({
          ...state,
          sentTrainingSubmissions: [
            ...state.sentTrainingSubmissions,
            submission.id,
          ],
        });
        sendNextSubmission();
        return;
      }

      setInfo(
        `Sending training feedbacks to Athena... (${
          state.sentTrainingSubmissions.length + 1
        }/${experiment.trainingSubmissions?.length ?? 0})`
      );

      sendFeedbacks.mutate(
        {
          exercise: experiment.exercise,
          submission,
          feedbacks: submissionFeedbacks,
        },
        {
          onSuccess: () => {
            console.log(
              `Sending training feedbacks for submission ${submission.id} success`
            );
            setState({
              ...state,
              sentTrainingSubmissions: [
                ...state.sentTrainingSubmissions,
                submission.id,
              ],
            });
            sendNextSubmission();
          },
          onError: (error) => {
            console.error(
              `Sending training feedbacks for submission ${submission.id} failed with error:`,
              error
            );
            setInfo(
              `Error while sending training feedbacks to Athena for submission ${submission.id}.`
            );
          },
        }
      );
    };

    // Start sending submissions
    sendNextSubmission();
  };

  // 3. Generate feedback suggestions
  const stepGenerateFeedbackSuggestions = () => {
    console.log("Generating feedback suggestions...");

    const generateFeedbackSuggestions = (submission: Submission) => {
      setInfo(
        `Generating feedback suggestions... (${
          state.submissionsWithFeedbackSuggestions.size + 1
        }/${
          experiment.evaluationSubmissions.length
        }) - Requesting feedback suggestions for submission ${submission.id}...`
      );
      requestFeedbackSuggestions.mutate(
        {
          exercise: experiment.exercise,
          submission,
        },
        {
          onSuccess: (response) => {
            console.log("Received feedback suggestions:", response.data);
            setState({
              ...state,
              submissionsWithFeedbackSuggestions: new Map(
                state.submissionsWithFeedbackSuggestions.set(submission.id, {
                  suggestions: response.data,
                  meta: response.meta,
                })
              ),
            });
            selectNextSubmissionAndGenerate();
          },
          onError: (error) => {
            console.error(
              `Error while generating feedback suggestions for submission ${submission.id}:`,
              error
            );
            setInfo(
              `Error while generating feedback suggestions for submission ${submission.id}.`
            );
            // TODO: Recover?
          },
        }
      );
    };

    const selectNextSubmissionAndGenerate = () => {
      const remainingSubmissions = experiment.evaluationSubmissions.filter(
        (submission) => !state.submissionsWithFeedbackSuggestions.has(submission.id)
      );

      // No more submissions to evaluate -> Go to finished
      if (remainingSubmissions.length === 0) {
        console.log("Generating feedback suggestions done!");
        setState({
          ...state,
          step: "finished",
        });
        return;
      }
      setInfo(
        `Generating feedback suggestions... (${
          state.submissionsWithFeedbackSuggestions.size + 1
        }/${
          experiment.evaluationSubmissions.length
        }) - Requesting submission selection...`
      );

      requestSubmissionSelection.mutate(
        {
          exercise: experiment.exercise,
          submissions: remainingSubmissions,
        },
        {
          onSuccess: (response) => {
            console.log("Received submission selection:", response.data);
            let submissionIndex = -1;
            if (response.data !== -1) {
              submissionIndex = remainingSubmissions.findIndex(
                (submission) => submission.id === response.data
              );
            }
            if (submissionIndex === -1) {
              // Pick random submission from remaining submissions
              submissionIndex = Math.floor(
                Math.random() * remainingSubmissions.length
              );
            }

            const submission = remainingSubmissions[submissionIndex];
            generateFeedbackSuggestions(submission);
          },
          onError: (error) => {
            console.error(
              "Error while requesting submission selection:",
              error
            );
            setInfo("Error while requesting submission selection.");
            // TODO: Recover?
          },
        }
      );
    };

    // Start generating feedback suggestions for all evaluation submissions
    selectNextSubmissionAndGenerate();
  };


  useEffect(() => {
    if (experiment.executionMode !== "batch") {
      console.error(
        "Using useBatchModuleExperiment in non-batch experiment!"
      );
      return;
    }

    console.log("Step changed");
    if (state.step === "sendingSubmissions") {
      stepSendSubmissions();
    } else if (state.step === "sendingTrainingFeedbacks") {
      stepSendTrainingFeedbacks();
    } else if (state.step === "generatingFeedbackSuggestions") {
      stepGenerateFeedbackSuggestions();
    }
    // TODO: Add automatic evaluation step here
    // Note: Evaluate tutor feedback more globally to not do it multiple times
    // Note 2: Actually, I probably want to have it in parallel with the feedback suggestions for the interactive mode!
  }, [state.step]);

  return { state, info };
}
