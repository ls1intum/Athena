import type { Feedback } from "@/model/feedback";
import type { Submission } from "@/model/submission";
import type { Experiment } from "@/components/view_mode/evaluation_mode/define_experiment";
import type { ModuleConfiguration } from "@/components/view_mode/evaluation_mode/configure_modules";

import { useEffect, useState } from "react";
import { useSendFeedbacks } from "./athena/send_feedbacks";
import useRequestSubmissionSelection from "./athena/request_submission_selection";
import useRequestFeedbackSuggestions from "./athena/request_feedback_suggestions";
import useSendSubmissions from "./athena/send_submissions";

type ModuleExperimentState = {
  experiment: Experiment;
  moduleConfiguration: ModuleConfiguration;
  // The current step of the experiment
  step:
    | "sendingSubmissions"
    | "sendingTrainingFeedbacks"
    | "generatingFeedbackSuggestions"
    | "finished";
  // Submissions that have been sent to Athena
  didSendSubmissions: boolean;
  // Tutor feedbacks for training submissions that have been sent to Athena
  sentTrainingSubmissions: number[];
  // Adjusted tutor feedbacks for evaluation submissions that have been sent to Athena
  // SubmissionId -> Feedbacks
  sentFeedbacks: Map<number, Feedback[]>;
  // Feedback suggestions for evaluation submissions that have been generated by Athena
  // SubmissionId -> { suggestions: Feedback[]; meta: any;} where meta is the metadata of the request
  feedbackSuggestions: Map<number, { suggestions: Feedback[]; meta: any }>;
};

export default function useModuleExperiment(
  experiment: Experiment,
  moduleConfiguration: ModuleConfiguration
) {
  // State of the module experiment
  const [state, setState] = useState<ModuleExperimentState>({
    step: "sendingSubmissions",
    experiment,
    moduleConfiguration,
    didSendSubmissions: false,
    sentTrainingSubmissions: [],
    sentFeedbacks: new Map(),
    feedbackSuggestions: new Map(),
  });

  // Info message to display the progress to the user
  const [info, setInfo] = useState<string>("");

  // Interactive mode: Selected submission id
  // Current submission that is being
  const [interactiveSelectedSubmissionId, setInteractiveSelectedSubmissionId] =
    useState<number | undefined>(undefined);

  // Interactive mode: Queue of submissions that are waiting for feedback suggestions
  // In interactive mode, the module might lag behind the module that selects submissions
  const [interactiveSubmissionQueue, setInteractiveSubmissionQueue] = useState<
    number[]
  >([]);

  // Interactive mode: Submissions that are not in the interactiveSubmissionQueue nor in the remaining submissions
  // of the module that selects submissions
  // This might happen if the progress got imported from a previous session
  const [
    interactiveCatchUpWithSubmissions,
    setInteractiveCatchUpWithSubmissions,
  ] = useState<number[]>([]);

  // Module requests
  const sendSubmissions = useSendSubmissions();
  const sendFeedbacks = useSendFeedbacks();
  const requestSubmissionSelection = useRequestSubmissionSelection();
  const requestFeedbackSuggestions = useRequestFeedbackSuggestions();

  // Interactive mode: add the selected submission id
  const interactiveAddSelectedSubmissionId = (
    submissionId: number,
    remainingSubmissionIds: number[]
  ) => {
    if (experiment.executionMode !== "incremental") {
      return;
    }

    // Handle submissionId
    if (
      interactiveSelectedSubmissionId === undefined &&
      interactiveSelectedSubmissionId !== submissionId
    ) {
      setInteractiveSelectedSubmissionId(submissionId);
    } else if (
      !interactiveSubmissionQueue.includes(submissionId) &&
      !interactiveCatchUpWithSubmissions.includes(submissionId)
    ) {
      setInteractiveSubmissionQueue([
        ...interactiveSubmissionQueue,
        submissionId,
      ]);
    }
    // Otherwise the selected submission is already in the queue

    // Handle remainingSubmissionIds
    // We have to catch up with submissions that are not in the remaining submissions of the submission selector module
    const submissionIdsToIgnore = new Set([
      ...interactiveSubmissionQueue,
      ...interactiveCatchUpWithSubmissions,
    ]);
    if (interactiveSelectedSubmissionId !== undefined) {
      submissionIdsToIgnore.add(interactiveSelectedSubmissionId);
    }
    remainingSubmissionIds.forEach((submissionId) =>
      submissionIdsToIgnore.add(submissionId)
    );
    state.feedbackSuggestions.forEach((_, submissionId) =>
      submissionIdsToIgnore.add(submissionId)
    );

    // Submissions that are skipped in the evaliation submissions
    const newCatchUpWithSubmissionIds = experiment.evaluationSubmissions
      .filter((submission) => !submissionIdsToIgnore.has(submission.id))
      .map((submission) => submission.id);

    setInteractiveCatchUpWithSubmissions([
      ...interactiveCatchUpWithSubmissions,
      ...newCatchUpWithSubmissionIds,
    ]);
  };

  // Interactive mode: request submission selection from the submission selector module
  // This does not set the selected submission id
  const interactiveRequestSubmissionSelection = async () => {
    if (experiment.executionMode !== "incremental") {
      return undefined;
    }

    const remainingSubmissions = state.experiment.evaluationSubmissions.filter(
      (submission) => !state.feedbackSuggestions.has(submission.id)
    );

    if (remainingSubmissions.length === 0) {
      return undefined;
    }

    try {
      const response = await requestSubmissionSelection.mutateAsync({
        exercise: experiment.exercise,
        submissions: remainingSubmissions,
      });
      console.log("Received submission selection:", response.data);

      const remainingSubmissionIds = remainingSubmissions.map(
        (submission) => submission.id
      );

      let submissionId = response.data as number;
      if (submissionId === -1) {
        // Pick random submission from remaining submissions
        const randomIndex = Math.floor(
          Math.random() * remainingSubmissions.length
        );
        submissionId = remainingSubmissions[randomIndex].id;
      }

      return {
        submissionId,
        remainingSubmissionIds: remainingSubmissionIds.filter(
          (id) => id !== submissionId
        ),
      };
    } catch (error) {
      console.error("Error while requesting submission selection:", error);
      setInfo("Error while requesting submission selection.");
      return undefined;
    }
  };

  // Interactive mode: select the next submission from the enqueued submissions
  const interactiveSelectNextSubmission = async () => {
    if (experiment.executionMode !== "incremental") {
      return;
    }

    // If there is a selected submission, we do not need to select a new one
    if (interactiveSelectedSubmissionId !== undefined) {
      return;
    }

    // First, try to pick from interactiveCatchUpWithSubmissions if there are any
    if (interactiveCatchUpWithSubmissions.length > 0) {
      try {
        const response = await requestSubmissionSelection.mutateAsync({
          exercise: experiment.exercise,
          submissions: experiment.evaluationSubmissions.filter((submission) =>
            interactiveCatchUpWithSubmissions.includes(submission.id)
          ),
        });

        let submissionId = response.data as number;
        if (submissionId === -1) {
          // Pick random submission from interactiveCatchUpWithSubmissions
          const randomIndex = Math.floor(
            Math.random() * interactiveCatchUpWithSubmissions.length
          );
          submissionId = interactiveCatchUpWithSubmissions[randomIndex];
        }

        setInteractiveSelectedSubmissionId(submissionId);
        setInteractiveCatchUpWithSubmissions([
          ...interactiveCatchUpWithSubmissions.filter(
            (id) => id !== submissionId
          ),
        ]);
        return;
      } catch (error) {
        console.error("Error while requesting submission selection:", error);
        setInfo("Error while requesting submission selection.");
      }
    }

    // Second, pick the first submission from the interactiveSubmissionQueue
    if (interactiveSubmissionQueue.length > 0) {
      const submissionId = interactiveSubmissionQueue[0];
      setInteractiveSelectedSubmissionId(submissionId);
      setInteractiveSubmissionQueue([
        ...interactiveSubmissionQueue.slice(1),
      ]);
      return;
    }

    // Third, there is no submission to select
    // Waiting for interactiveAddSelectedSubmissionId
  };

  // 1. Send submissions to Athena
  const stepSendSubmissions = () => {
    console.log("Sending submissions to Athena...");
    setInfo("Sending submissions to Athena...");
    sendSubmissions.mutate(
      {
        exercise: experiment.exercise,
        submissions: [
          ...(experiment.trainingSubmissions ?? []),
          ...experiment.evaluationSubmissions,
        ],
      },
      {
        onSuccess: () => {
          console.log("Sending submissions done!");
          setState({
            ...state,
            step: "sendingTrainingFeedbacks", // next step
            didSendSubmissions: true,
          });
        },
        onError: (error) => {
          console.error("Error while sending submissions to Athena:", error);
          setInfo("Error while sending submissions to Athena.");
          // TODO: Recover?
        },
      }
    );
  };

  // 2. Send tutor feedbacks for training submissions to Athena
  const stepSendTrainingFeedbacks = () => {
    // Skip if there are no training submissions
    if (!experiment.trainingSubmissions) {
      console.log("No training submissions, skipping");
      setState({
        ...state,
        step: "generatingFeedbackSuggestions",
      });
      return;
    }

    console.log("Sending training feedbacks to Athena...");
    setInfo("Sending training feedbacks to Athena...");

    // Recursive function to send all training submissions
    const sendNextSubmission = () => {
      const submission = experiment.trainingSubmissions?.find(
        (submission) => !state.sentTrainingSubmissions.includes(submission.id)
      );

      // No more submissions to send -> Go to evaluation
      if (!submission) {
        console.log("Sending training feedbacks done!");
        setState({
          ...state,
          step: "generatingFeedbackSuggestions", // next step
        });
        return;
      }

      const submissionFeedbacks = experiment.tutorFeedbacks.filter(
        (feedback) => feedback.submission_id === submission?.id
      );

      // Skip submission if there are no feedbacks
      if (submissionFeedbacks.length === 0) {
        setState({
          ...state,
          sentTrainingSubmissions: [
            ...state.sentTrainingSubmissions,
            submission.id,
          ],
        });
        sendNextSubmission();
        return;
      }

      setInfo(
        `Sending training feedbacks to Athena... (${
          state.sentTrainingSubmissions.length + 1
        }/${experiment.trainingSubmissions?.length ?? 0})`
      );

      sendFeedbacks.mutate(
        {
          exercise: experiment.exercise,
          submission,
          feedbacks: submissionFeedbacks,
        },
        {
          onSuccess: () => {
            console.log(
              `Sending training feedbacks for submission ${submission.id} success`
            );
            setState({
              ...state,
              sentTrainingSubmissions: [
                ...state.sentTrainingSubmissions,
                submission.id,
              ],
            });
            sendNextSubmission();
          },
          onError: (error) => {
            console.error(
              `Sending training feedbacks for submission ${submission.id} failed with error:`,
              error
            );
            setInfo(
              `Error while sending training feedbacks to Athena for submission ${submission.id}.`
            );
          },
        }
      );
    };

    // Start sending submissions
    sendNextSubmission();
  };

  // 3. Generate feedback suggestions
  const stepGenerateFeedbackSuggestions = () => {
    console.log("Generating feedback suggestions...");
    setInfo("Generating feedback suggestions...");

    const generateFeedbackSuggestions = (submission: Submission) => {
      setInfo(
        `Generating feedback suggestions... (${
          state.feedbackSuggestions.size + 1
        }/${
          experiment.evaluationSubmissions.length
        }) - Requesting feedback suggestions for submission ${submission.id}...`
      );
      requestFeedbackSuggestions.mutate(
        {
          exercise: experiment.exercise,
          submission,
        },
        {
          onSuccess: (response) => {
            console.log("Received feedback suggestions:", response.data);
            setState({
              ...state,
              feedbackSuggestions: new Map(
                state.feedbackSuggestions.set(submission.id, {
                  suggestions: response.data,
                  meta: response.meta,
                })
              ),
            });
            selectNextSubmissionAndGenerate();
          },
          onError: (error) => {
            console.error(
              `Error while generating feedback suggestions for submission ${submission.id}:`,
              error
            );
            setInfo(
              `Error while generating feedback suggestions for submission ${submission.id}.`
            );
            // TODO: Recover?
          },
        }
      );
    };

    const selectNextSubmissionAndGenerate = () => {
      const remainingSubmissions = experiment.evaluationSubmissions.filter(
        (submission) => !state.feedbackSuggestions.has(submission.id)
      );

      // No more submissions to evaluate -> Go to finished
      if (remainingSubmissions.length === 0) {
        console.log("Generating feedback suggestions done!");
        setState({
          ...state,
          step: "finished",
        });
        return;
      }
      setInfo(
        `Generating feedback suggestions... (${
          state.feedbackSuggestions.size + 1
        }/${
          experiment.evaluationSubmissions.length
        }) - Requesting submission selection...`
      );

      requestSubmissionSelection.mutate(
        {
          exercise: experiment.exercise,
          submissions: remainingSubmissions,
        },
        {
          onSuccess: (response) => {
            console.log("Received submission selection:", response.data);
            let submissionIndex = -1;
            if (response.data !== -1) {
              submissionIndex = remainingSubmissions.findIndex(
                (submission) => submission.id === response.data
              );
            }
            if (submissionIndex === -1) {
              // Pick random submission from remaining submissions
              submissionIndex = Math.floor(
                Math.random() * remainingSubmissions.length
              );
            }

            const submission = remainingSubmissions[submissionIndex];
            generateFeedbackSuggestions(submission);
          },
          onError: (error) => {
            console.error(
              "Error while requesting submission selection:",
              error
            );
            setInfo("Error while requesting submission selection.");
            // TODO: Recover?
          },
        }
      );
    };

    // Let's do just the batch mode for now
    // TODO: Interactive mode
    selectNextSubmissionAndGenerate();
  };
  // I need to handle requestSubmissionSelection(remainingSubmissions) -> selection
  // If there are selections that are remaining what are not in remaining submissions I need
  // to do them with the own module submission selector

  useEffect(() => {
    console.log("Step changed");
    if (state.step === "sendingSubmissions") {
      stepSendSubmissions();
    } else if (state.step === "sendingTrainingFeedbacks") {
      stepSendTrainingFeedbacks();
    } else if (state.step === "generatingFeedbackSuggestions") {
      stepGenerateFeedbackSuggestions();
    }
    // TODO: Add automatic evaluation step here
    // Note: Evaluate tutor feedback more globally to not do it multiple times
    // Note 2: Actually, I probably want to have it in parallel with the feedback suggestions for the interactive mode!
  }, [state.step]);

  // Callback function for requesting submission selection
  return {
    state,
    info,
    interactiveAddSelectedSubmissionId,
    interactiveRequestSubmissionSelection,
  };
}
